<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Chunks of Bytecode &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Chunks of Bytecode<small>14</small></a></h3>

<ul>
    <li><a href="#bytecode"><small>14.1</small> Bytecode?</a></li>
    <li><a href="#getting-started"><small>14.2</small> Getting Started</a></li>
    <li><a href="#chunks-of-instructions"><small>14.3</small> Chunks of Instructions</a></li>
    <li><a href="#disassembling-chunks"><small>14.4</small> Disassembling Chunks</a></li>
    <li><a href="#constants"><small>14.5</small> Constants</a></li>
    <li><a href="#line-information"><small>14.6</small> Line Information</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Test Your Language</a></li>
</ul>


<div class="prev-next">
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="a-virtual-machine.html" title="A Virtual Machine" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine" class="prev">←</a>
<a href="a-virtual-machine.html" title="A Virtual Machine" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Chunks of Bytecode<small>14</small></a></h3>

<ul>
    <li><a href="#bytecode"><small>14.1</small> Bytecode?</a></li>
    <li><a href="#getting-started"><small>14.2</small> Getting Started</a></li>
    <li><a href="#chunks-of-instructions"><small>14.3</small> Chunks of Instructions</a></li>
    <li><a href="#disassembling-chunks"><small>14.4</small> Disassembling Chunks</a></li>
    <li><a href="#constants"><small>14.5</small> Constants</a></li>
    <li><a href="#line-information"><small>14.6</small> Line Information</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Test Your Language</a></li>
</ul>


<div class="prev-next">
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="a-virtual-machine.html" title="A Virtual Machine" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">14</div>
  <h1>Chunks of Bytecode</h1>

<blockquote>
<p>If you find that you&rsquo;re spending almost all your time on theory, start turning
some attention to practical things; it will improve your theories. If you find
that you&rsquo;re spending almost all your time on practice, start turning some
attention to theoretical things; it will improve your practice.</p>
<p><cite>Donald Knuth</cite></p>
</blockquote>
<p>We already have ourselves a complete implementation of Lox with jlox, so why
isn&rsquo;t the book over yet? Part of this is because jlox relies on the <span
name="metal">JVM</span> to do lots of things for us. If we want to understand
how an interpreter works all the way down to the metal, we need to build those
bits and pieces ourselves.</p>
<aside name="metal">
<p>Of course, our second interpreter relies on the C standard library for basics
like memory allocation, and the C compiler frees us from details of the
underlying machine code we&rsquo;re running it on. Heck, that machine code is probably
implemented in terms of microcode on the chip. And the C runtime relies on the
operating system to hand out pages of memory. But we have to stop <em>somewhere</em> if
this book is going to fit on your bookshelf.</p>
</aside>
<p>An even more fundamental reason that jlox isn&rsquo;t sufficient is that it&rsquo;s too damn
slow. A tree-walk interpreter is fine for some kinds of high-level, declarative
languages. But for a general-purpose, imperative language<span class="em">&mdash;</span>even a &ldquo;scripting&rdquo;
language like Lox<span class="em">&mdash;</span>it won&rsquo;t fly. Take this little script:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">fib</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> &lt; <span class="n">2</span>) <span class="k">return</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">fib</span>(<span class="i">n</span> - <span class="n">1</span>) + <span class="i">fib</span>(<span class="i">n</span> - <span class="n">2</span>);<span name="fib"> </span>
}

<span class="k">var</span> <span class="i">before</span> = <span class="i">clock</span>();
<span class="k">print</span> <span class="i">fib</span>(<span class="n">40</span>);
<span class="k">var</span> <span class="i">after</span> = <span class="i">clock</span>();
<span class="k">print</span> <span class="i">after</span> - <span class="i">before</span>;
</pre></div>
<aside name="fib">
<p>This is a comically inefficient way to actually calculate Fibonacci numbers.
Our goal is to see how fast the <em>interpreter</em> runs, not to see how fast of a
program we can write. A slow program that does a lot of work<span class="em">&mdash;</span>pointless or not<span class="em">&mdash;</span>is a good test case for that.</p>
</aside>
<p>On my laptop, that takes jlox about 72 seconds to execute. An equivalent C
program finishes in half a second. Our dynamically typed scripting language is
never going to be as fast as a statically typed language with manual memory
management, but we don&rsquo;t need to settle for more than <em>two orders of magnitude</em>
slower.</p>
<p>We could take jlox and run it in a profiler and start tuning and tweaking
hotspots, but that will only get us so far. The execution model<span class="em">&mdash;</span>walking the
AST<span class="em">&mdash;</span>is fundamentally the wrong design. We can&rsquo;t micro-optimize that to the
performance we want any more than you can polish an AMC Gremlin into an SR-71
Blackbird.</p>
<p>We need to rethink the core model. This chapter introduces that model, bytecode,
and begins our new interpreter, clox.</p>
<h2><a href="#bytecode" id="bytecode"><small>14&#8202;.&#8202;1</small>Bytecode?</a></h2>
<p>In engineering, few choices are without trade-offs. To best understand why we&rsquo;re
going with bytecode, let&rsquo;s stack it up against a couple of alternatives.</p>
<h3><a href="#why-not-walk-the-ast" id="why-not-walk-the-ast"><small>14&#8202;.&#8202;1&#8202;.&#8202;1</small>Why not walk the AST?</a></h3>
<p>Our existing interpreter has a couple of things going for it:</p>
<ul>
<li>
<p>Well, first, we already wrote it. It&rsquo;s done. And the main reason it&rsquo;s done
is because this style of interpreter is <em>really simple to implement</em>. The
runtime representation of the code directly maps to the syntax. It&rsquo;s
virtually effortless to get from the parser to the data structures we need
at runtime.</p>
</li>
<li>
<p>It&rsquo;s <em>portable</em>. Our current interpreter is written in Java and runs on any
platform Java supports. We could write a new implementation in C using the
same approach and compile and run our language on basically every platform
under the sun.</p>
</li>
</ul>
<p>Those are real advantages. But, on the other hand, it&rsquo;s <em>not memory-efficient</em>.
Each piece of syntax becomes an AST node. A tiny Lox expression like <code>1 + 2</code>
turns into a slew of objects with lots of pointers between them, something like:</p>
<p><span name="header"></span></p>
<aside name="header">
<p>The &ldquo;(header)&rdquo; parts are the bookkeeping information the Java virtual machine
uses to support memory management and store the object&rsquo;s type. Those take up
space too!</p>
</aside><img src="image/chunks-of-bytecode/ast.png" alt="The tree of Java objects created to represent '1 + 2'." />
<p>Each of those pointers adds an extra 32 or 64 bits of overhead to the object.
Worse, sprinkling our data across the heap in a loosely connected web of objects
does bad things for <span name="locality"><em>spatial locality</em></span>.</p>
<aside name="locality">
<p>I wrote <a href="http://gameprogrammingpatterns.com/data-locality.html">an entire chapter</a> about this exact problem in my first
book, <em>Game Programming Patterns</em>, if you want to really dig in.</p>
</aside>
<p>Modern CPUs process data way faster than they can pull it from RAM. To
compensate for that, chips have multiple layers of caching. If a piece of memory
it needs is already in the cache, it can be loaded more quickly. We&rsquo;re talking
upwards of 100 <em>times</em> faster.</p>
<p>How does data get into that cache? The machine speculatively stuffs things in
there for you. Its heuristic is pretty simple. Whenever the CPU reads a bit of
data from RAM, it pulls in a whole little bundle of adjacent bytes and stuffs
them in the cache.</p>
<p>If our program next requests some data close enough to be inside that cache
line, our CPU runs like a well-oiled conveyor belt in a factory. We <em>really</em>
want to take advantage of this. To use the cache effectively, the way we
represent code in memory should be dense and ordered like it&rsquo;s read.</p>
<p>Now look up at that tree. Those sub-objects could be <span
name="anywhere"><em>anywhere</em></span>. Every step the tree-walker takes where it
follows a reference to a child node may step outside the bounds of the cache and
force the CPU to stall until a new lump of data can be slurped in from RAM. Just
the <em>overhead</em> of those tree nodes with all of their pointer fields and object
headers tends to push objects away from each other and out of the cache.</p>
<aside name="anywhere">
<p>Even if the objects happened to be allocated in sequential memory when the
parser first produced them, after a couple of rounds of garbage collection<span class="em">&mdash;</span>which may move objects around in memory<span class="em">&mdash;</span>there&rsquo;s no telling where they&rsquo;ll be.</p>
</aside>
<p>Our AST walker has other overhead too around interface dispatch and the Visitor
pattern, but the locality issues alone are enough to justify a better code
representation.</p>
<h3><a href="#why-not-compile-to-native-code" id="why-not-compile-to-native-code"><small>14&#8202;.&#8202;1&#8202;.&#8202;2</small>Why not compile to native code?</a></h3>
<p>If you want to go <em>real</em> fast, you want to get all of those layers of
indirection out of the way. Right down to the metal. Machine code. It even
<em>sounds</em> fast. <em>Machine code.</em></p>
<p>Compiling directly to the native instruction set the chip supports is what the
fastest languages do. Targeting native code has been the most efficient option
since way back in the early days when engineers actually <span
name="hand">handwrote</span> programs in machine code.</p>
<aside name="hand">
<p>Yes, they actually wrote machine code by hand. On punched cards. Which,
presumably, they punched <em>with their fists</em>.</p>
</aside>
<p>If you&rsquo;ve never written any machine code, or its slightly more human-palatable
cousin assembly code before, I&rsquo;ll give you the gentlest of introductions. Native
code is a dense series of operations, encoded directly in binary. Each
instruction is between one and a few bytes long, and is almost mind-numbingly
low level. &ldquo;Move a value from this address to this register.&rdquo; &ldquo;Add the integers
in these two registers.&rdquo; Stuff like that.</p>
<p>The CPU cranks through the instructions, decoding and executing each one in
order. There is no tree structure like our AST, and control flow is handled by
jumping from one point in the code directly to another. No indirection, no
overhead, no unnecessary skipping around or chasing pointers.</p>
<p>Lightning fast, but that performance comes at a cost. First of all, compiling to
native code ain&rsquo;t easy. Most chips in wide use today have sprawling Byzantine
architectures with heaps of instructions that accreted over decades. They
require sophisticated register allocation, pipelining, and instruction
scheduling.</p>
<p>And, of course, you&rsquo;ve thrown <span name="back">portability</span> out. Spend a
few years mastering some architecture and that still only gets you onto <em>one</em> of
the several popular instruction sets out there. To get your language on all of
them, you need to learn all of their instruction sets and write a separate back
end for each one.</p>
<aside name="back">
<p>The situation isn&rsquo;t entirely dire. A well-architected compiler lets you
share the front end and most of the middle layer optimization passes across the
different architectures you support. It&rsquo;s mainly the code generation and some of
the details around instruction selection that you&rsquo;ll need to write afresh each
time.</p>
<p>The <a href="https://llvm.org/">LLVM</a> project gives you some of this out of the box. If your compiler
outputs LLVM&rsquo;s own special intermediate language, LLVM in turn compiles that to
native code for a plethora of architectures.</p>
</aside>
<h3><a href="#what-is-bytecode" id="what-is-bytecode"><small>14&#8202;.&#8202;1&#8202;.&#8202;3</small>What is bytecode?</a></h3>
<p>Fix those two points in your mind. On one end, a tree-walk interpreter is
simple, portable, and slow. On the other, native code is complex and
platform-specific but fast. Bytecode sits in the middle. It retains the
portability of a tree-walker<span class="em">&mdash;</span>we won&rsquo;t be getting our hands dirty with
assembly code in this book. It sacrifices <em>some</em> simplicity to get a performance
boost in return, though not as fast as going fully native.</p>
<p>Structurally, bytecode resembles machine code. It&rsquo;s a dense, linear sequence of
binary instructions. That keeps overhead low and plays nice with the cache.
However, it&rsquo;s a much simpler, higher-level instruction set than any real chip
out there. (In many bytecode formats, each instruction is only a single byte
long, hence &ldquo;bytecode&rdquo;.)</p>
<p>Imagine you&rsquo;re writing a native compiler from some source language and you&rsquo;re
given carte blanche to define the easiest possible architecture to target.
Bytecode is kind of like that. It&rsquo;s an idealized fantasy instruction set that
makes your life as the compiler writer easier.</p>
<p>The problem with a fantasy architecture, of course, is that it doesn&rsquo;t exist. We
solve that by writing an <em>emulator</em><span class="em">&mdash;</span>a simulated chip written in software that
interprets the bytecode one instruction at a time. A <em>virtual machine (VM)</em>, if
you will.</p>
<p>That emulation layer adds <span name="p-code">overhead</span>, which is a key
reason bytecode is slower than native code. But in return, it gives us
portability. Write our VM in a language like C that is already supported on all
the machines we care about, and we can run our emulator on top of any hardware
we like.</p>
<aside name="p-code">
<p>One of the first bytecode formats was <a href="https://en.wikipedia.org/wiki/P-code_machine">p-code</a>, developed for Niklaus Wirth&rsquo;s
Pascal language. You might think a PDP-11 running at 15MHz couldn&rsquo;t afford the
overhead of emulating a virtual machine. But back then, computers were in their
Cambrian explosion and new architectures appeared every day. Keeping up with the
latest chips was worth more than squeezing the maximum performance from each
one. That&rsquo;s why the &ldquo;p&rdquo; in p-code doesn&rsquo;t stand for &ldquo;Pascal&rdquo;, but &ldquo;portable&rdquo;.</p>
</aside>
<p>This is the path we&rsquo;ll take with our new interpreter, clox. We&rsquo;ll follow in the
footsteps of the main implementations of Python, Ruby, Lua, OCaml, Erlang, and
others. In many ways, our VM&rsquo;s design will parallel the structure of our
previous interpreter:</p>
<p><img src="image/chunks-of-bytecode/phases.png" alt="Phases of the two
implementations. jlox is Parser to Syntax Trees to Interpreter. clox is Compiler
to Bytecode to Virtual Machine." /></p>
<p>Of course, we won&rsquo;t implement the phases strictly in order. Like our previous
interpreter, we&rsquo;ll bounce around, building up the implementation one language
feature at a time. In this chapter, we&rsquo;ll get the skeleton of the application in
place and create the data structures needed to store and represent a chunk of
bytecode.</p>
<h2><a href="#getting-started" id="getting-started"><small>14&#8202;.&#8202;2</small>Getting Started</a></h2>
<p>Where else to begin, but at <code>main()</code>? <span name="ready">Fire</span> up your
trusty text editor and start typing.</p>
<aside name="ready">
<p>Now is a good time to stretch, maybe crack your knuckles. A little montage music
wouldn&rsquo;t hurt either.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>main.c</em><br>
create new file</div>
<pre><span class="a">#include &quot;common.h&quot;</span>

<span class="t">int</span> <span class="i">main</span>(<span class="t">int</span> <span class="i">argc</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">argv</span>[]) {
  <span class="k">return</span> <span class="n">0</span>;
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, create new file</div>

<p>From this tiny seed, we will grow our entire VM. Since C provides us with so
little, we first need to spend some time amending the soil. Some of that goes
into this header:</p>
<div class="codehilite"><div class="source-file"><em>common.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_common_h</span>
<span class="a">#define clox_common_h</span>

<span class="a">#include &lt;stdbool.h&gt;</span>
<span class="a">#include &lt;stddef.h&gt;</span>
<span class="a">#include &lt;stdint.h&gt;</span>

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>common.h</em>, create new file</div>

<p>There are a handful of types and constants we&rsquo;ll use throughout the interpreter,
and this is a convenient place to put them. For now, it&rsquo;s the venerable <code>NULL</code>,
<code>size_t</code>, the nice C99 Boolean <code>bool</code>, and explicit-sized integer types<span class="em">&mdash;</span><code>uint8_t</code> and friends.</p>
<h2><a href="#chunks-of-instructions" id="chunks-of-instructions"><small>14&#8202;.&#8202;3</small>Chunks of Instructions</a></h2>
<p>Next, we need a module to define our code representation. I&rsquo;ve been using
&ldquo;chunk&rdquo; to refer to sequences of bytecode, so let&rsquo;s make that the official name
for that module.</p>
<div class="codehilite"><div class="source-file"><em>chunk.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_chunk_h</span>
<span class="a">#define clox_chunk_h</span>

<span class="a">#include &quot;common.h&quot;</span>

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, create new file</div>

<p>In our bytecode format, each instruction has a one-byte <strong>operation code</strong>
(universally shortened to <strong>opcode</strong>). That number controls what kind of
instruction we&rsquo;re dealing with<span class="em">&mdash;</span>add, subtract, look up variable, etc. We
define those here:</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>chunk.h</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">OP_RETURN</span>,
} <span class="t">OpCode</span>;
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em></div>

<p>For now, we start with a single instruction, <code>OP_RETURN</code>. When we have a
full-featured VM, this instruction will mean &ldquo;return from the current function&rdquo;.
I admit this isn&rsquo;t exactly useful yet, but we have to start somewhere, and this
is a particularly simple instruction, for reasons we&rsquo;ll get to later.</p>
<h3><a href="#a-dynamic-array-of-instructions" id="a-dynamic-array-of-instructions"><small>14&#8202;.&#8202;3&#8202;.&#8202;1</small>A dynamic array of instructions</a></h3>
<p>Bytecode is a series of instructions. Eventually, we&rsquo;ll store some other data
along with the instructions, so let&rsquo;s go ahead and create a struct to hold it
all.</p>
<div class="codehilite"><pre class="insert-before">} OpCode;
</pre><div class="source-file"><em>chunk.h</em><br>
add after enum <em>OpCode</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">uint8_t</span>* <span class="i">code</span>;
} <span class="t">Chunk</span>;
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, add after enum <em>OpCode</em></div>

<p>At the moment, this is simply a wrapper around an array of bytes. Since we don&rsquo;t
know how big the array needs to be before we start compiling a chunk, it must be
dynamic. Dynamic arrays are one of my favorite data structures. That sounds like
claiming vanilla is my favorite ice cream <span name="flavor">flavor</span>, but
hear me out. Dynamic arrays provide:</p>
<aside name="flavor">
<p>Butter pecan is actually my favorite.</p>
</aside>
<ul>
<li>
<p>Cache-friendly, dense storage</p>
</li>
<li>
<p>Constant-time indexed element lookup</p>
</li>
<li>
<p>Constant-time appending to the end of the array</p>
</li>
</ul>
<p>Those features are exactly why we used dynamic arrays all the time in jlox under
the guise of Java&rsquo;s ArrayList class. Now that we&rsquo;re in C, we get to roll our
own. If you&rsquo;re rusty on dynamic arrays, the idea is pretty simple. In addition
to the array itself, we keep two numbers: the number of elements in the array we
have allocated (&ldquo;capacity&rdquo;) and how many of those allocated entries are actually
in use (&ldquo;count&rdquo;).</p>
<div class="codehilite"><pre class="insert-before">typedef struct {
</pre><div class="source-file"><em>chunk.h</em><br>
in struct <em>Chunk</em></div>
<pre class="insert">  <span class="t">int</span> <span class="i">count</span>;
  <span class="t">int</span> <span class="i">capacity</span>;
</pre><pre class="insert-after">  uint8_t* code;
} Chunk;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in struct <em>Chunk</em></div>

<p>When we add an element, if the count is less than the capacity, then there is
already available space in the array. We store the new element right in there
and bump the count.</p>
<p><img src="image/chunks-of-bytecode/insert.png" alt="Storing an element in an
array that has enough capacity." /></p>
<p>If we have no spare capacity, then the process is a little more involved.</p>
<p><img src="image/chunks-of-bytecode/grow.png" alt="Growing the dynamic array
before storing an element." class="wide" /></p>
<ol>
<li><span name="amortized">Allocate</span> a new array with more capacity.</li>
<li>Copy the existing elements from the old array to the new one.</li>
<li>Store the new <code>capacity</code>.</li>
<li>Delete the old array.</li>
<li>Update <code>code</code> to point to the new array.</li>
<li>Store the element in the new array now that there is room.</li>
<li>Update the <code>count</code>.</li>
</ol>
<aside name="amortized">
<p>Copying the existing elements when you grow the array makes it seem like
appending an element is <em>O(n)</em>, not <em>O(1)</em> like I said above. However, you need
to do this copy step only on <em>some</em> of the appends. Most of the time, there is
already extra capacity, so you don&rsquo;t need to copy.</p>
<p>To understand how this works, we need <a href="https://en.wikipedia.org/wiki/Amortized_analysis"><strong>amortized
analysis</strong></a>. That shows us
that as long as we grow the array by a multiple of its current size, when we
average out the cost of a <em>sequence</em> of appends, each append is <em>O(1)</em>.</p>
</aside>
<p>We have our struct ready, so let&rsquo;s implement the functions to work with it. C
doesn&rsquo;t have constructors, so we declare a function to initialize a new chunk.</p>
<div class="codehilite"><pre class="insert-before">} Chunk;
</pre><div class="source-file"><em>chunk.h</em><br>
add after struct <em>Chunk</em></div>
<pre class="insert">

<span class="t">void</span> <span class="i">initChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, add after struct <em>Chunk</em></div>

<p>And implement it thusly:</p>
<div class="codehilite"><div class="source-file"><em>chunk.c</em><br>
create new file</div>
<pre><span class="a">#include &lt;stdlib.h&gt;</span>

<span class="a">#include &quot;chunk.h&quot;</span>

<span class="t">void</span> <span class="i">initChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>) {
  <span class="i">chunk</span>-&gt;<span class="i">count</span> = <span class="n">0</span>;
  <span class="i">chunk</span>-&gt;<span class="i">capacity</span> = <span class="n">0</span>;
  <span class="i">chunk</span>-&gt;<span class="i">code</span> = <span class="a">NULL</span>;
}
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, create new file</div>

<p>The dynamic array starts off completely empty. We don&rsquo;t even allocate a raw
array yet. To append a byte to the end of the chunk, we use a new function.</p>
<div class="codehilite"><pre class="insert-before">void initChunk(Chunk* chunk);
</pre><div class="source-file"><em>chunk.h</em><br>
add after <em>initChunk</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">writeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">uint8_t</span> <span class="i">byte</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, add after <em>initChunk</em>()</div>

<p>This is where the interesting work happens.</p>
<div class="codehilite"><div class="source-file"><em>chunk.c</em><br>
add after <em>initChunk</em>()</div>
<pre><span class="t">void</span> <span class="i">writeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">uint8_t</span> <span class="i">byte</span>) {
  <span class="k">if</span> (<span class="i">chunk</span>-&gt;<span class="i">capacity</span> &lt; <span class="i">chunk</span>-&gt;<span class="i">count</span> + <span class="n">1</span>) {
    <span class="t">int</span> <span class="i">oldCapacity</span> = <span class="i">chunk</span>-&gt;<span class="i">capacity</span>;
    <span class="i">chunk</span>-&gt;<span class="i">capacity</span> = <span class="a">GROW_CAPACITY</span>(<span class="i">oldCapacity</span>);
    <span class="i">chunk</span>-&gt;<span class="i">code</span> = <span class="a">GROW_ARRAY</span>(<span class="t">uint8_t</span>, <span class="i">chunk</span>-&gt;<span class="i">code</span>,
        <span class="i">oldCapacity</span>, <span class="i">chunk</span>-&gt;<span class="i">capacity</span>);
  }

  <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">chunk</span>-&gt;<span class="i">count</span>] = <span class="i">byte</span>;
  <span class="i">chunk</span>-&gt;<span class="i">count</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, add after <em>initChunk</em>()</div>

<p>The first thing we need to do is see if the current array already has capacity
for the new byte. If it doesn&rsquo;t, then we first need to grow the array to make
room. (We also hit this case on the very first write when the array is <code>NULL</code>
and <code>capacity</code> is 0.)</p>
<p>To grow the array, first we figure out the new capacity and grow the array to
that size. Both of those lower-level memory operations are defined in a new
module.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>chunk.c</em></div>
<pre class="insert"><span class="a">#include &quot;memory.h&quot;</span>
</pre><pre class="insert-after">

void initChunk(Chunk* chunk) {
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em></div>

<p>This is enough to get us started.</p>
<div class="codehilite"><div class="source-file"><em>memory.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_memory_h</span>
<span class="a">#define clox_memory_h</span>

<span class="a">#include &quot;common.h&quot;</span>

<span class="a">#define GROW_CAPACITY(capacity) \</span>
<span class="a">    ((capacity) &lt; 8 ? 8 : (capacity) * 2)</span>

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>memory.h</em>, create new file</div>

<p>This macro calculates a new capacity based on a given current capacity. In order
to get the performance we want, the important part is that it <em>scales</em> based on
the old size. We grow by a factor of two, which is pretty typical. 1.5&times; is
another common choice.</p>
<p>We also handle when the current capacity is zero. In that case, we jump straight
to eight elements instead of starting at one. That <span
name="profile">avoids</span> a little extra memory churn when the array is very
small, at the expense of wasting a few bytes on very small chunks.</p>
<aside name="profile">
<p>I picked the number eight somewhat arbitrarily for the book. Most dynamic array
implementations have a minimum threshold like this. The right way to pick a
value for this is to profile against real-world usage and see which constant
makes the best performance trade-off between extra grows versus wasted space.</p>
</aside>
<p>Once we know the desired capacity, we create or grow the array to that size
using <code>GROW_ARRAY()</code>.</p>
<div class="codehilite"><pre class="insert-before">#define GROW_CAPACITY(capacity) \
    ((capacity) &lt; 8 ? 8 : (capacity) * 2)
</pre><div class="source-file"><em>memory.h</em></div>
<pre class="insert">

<span class="a">#define GROW_ARRAY(type, pointer, oldCount, newCount) \</span>
<span class="a">    (type*)reallocate(pointer, sizeof(type) * (oldCount), \</span>
<span class="a">        sizeof(type) * (newCount))</span>

<span class="t">void</span>* <span class="i">reallocate</span>(<span class="t">void</span>* <span class="i">pointer</span>, <span class="t">size_t</span> <span class="i">oldSize</span>, <span class="t">size_t</span> <span class="i">newSize</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>memory.h</em></div>

<p>This macro pretties up a function call to <code>reallocate()</code> where the real work
happens. The macro itself takes care of getting the size of the array&rsquo;s element
type and casting the resulting <code>void*</code> back to a pointer of the right type.</p>
<p>This <code>reallocate()</code> function is the single function we&rsquo;ll use for all dynamic
memory management in clox<span class="em">&mdash;</span>allocating memory, freeing it, and changing the
size of an existing allocation. Routing all of those operations through a single
function will be important later when we add a garbage collector that needs to
keep track of how much memory is in use.</p>
<p>The two size arguments passed to <code>reallocate()</code> control which operation to
perform:</p><table>
  <thead>
    <tr>
      <td>oldSize</td>
      <td>newSize</td>
      <td>Operation</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>Non&#8209;zero</td>
      <td>Allocate new block.</td>
    </tr>
    <tr>
      <td>Non&#8209;zero</td>
      <td>0</td>
      <td>Free allocation.</td>
    </tr>
    <tr>
      <td>Non&#8209;zero</td>
      <td>Smaller&nbsp;than&nbsp;<code>oldSize</code></td>
      <td>Shrink existing allocation.</td>
    </tr>
    <tr>
      <td>Non&#8209;zero</td>
      <td>Larger&nbsp;than&nbsp;<code>oldSize</code></td>
      <td>Grow existing allocation.</td>
    </tr>
  </tbody>
</table>
<p>That sounds like a lot of cases to handle, but here&rsquo;s the implementation:</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
create new file</div>
<pre><span class="a">#include &lt;stdlib.h&gt;</span>

<span class="a">#include &quot;memory.h&quot;</span>

<span class="t">void</span>* <span class="i">reallocate</span>(<span class="t">void</span>* <span class="i">pointer</span>, <span class="t">size_t</span> <span class="i">oldSize</span>, <span class="t">size_t</span> <span class="i">newSize</span>) {
  <span class="k">if</span> (<span class="i">newSize</span> == <span class="n">0</span>) {
    <span class="i">free</span>(<span class="i">pointer</span>);
    <span class="k">return</span> <span class="a">NULL</span>;
  }

  <span class="t">void</span>* <span class="i">result</span> = <span class="i">realloc</span>(<span class="i">pointer</span>, <span class="i">newSize</span>);
  <span class="k">return</span> <span class="i">result</span>;
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, create new file</div>

<p>When <code>newSize</code> is zero, we handle the deallocation case ourselves by calling
<code>free()</code>. Otherwise, we rely on the C standard library&rsquo;s <code>realloc()</code> function.
That function conveniently supports the other three aspects of our policy. When
<code>oldSize</code> is zero, <code>realloc()</code> is equivalent to calling <code>malloc()</code>.</p>
<p>The interesting cases are when both <code>oldSize</code> and <code>newSize</code> are not zero. Those
tell <code>realloc()</code> to resize the previously allocated block. If the new size is
smaller than the existing block of memory, it simply <span
name="shrink">updates</span> the size of the block and returns the same pointer
you gave it. If the new size is larger, it attempts to grow the existing block
of memory.</p>
<p>It can do that only if the memory after that block isn&rsquo;t already in use. If
there isn&rsquo;t room to grow the block, <code>realloc()</code> instead allocates a <em>new</em> block
of memory of the desired size, copies over the old bytes, frees the old block,
and then returns a pointer to the new block. Remember, that&rsquo;s exactly the
behavior we want for our dynamic array.</p>
<p>Because computers are finite lumps of matter and not the perfect mathematical
abstractions computer science theory would have us believe, allocation can fail
if there isn&rsquo;t enough memory and <code>realloc()</code> will return <code>NULL</code>. We should
handle that.</p>
<div class="codehilite"><pre class="insert-before">  void* result = realloc(pointer, newSize);
</pre><div class="source-file"><em>memory.c</em><br>
in <em>reallocate</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">result</span> == <span class="a">NULL</span>) <span class="i">exit</span>(<span class="n">1</span>);
</pre><pre class="insert-after">  return result;
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>reallocate</em>()</div>

<p>There&rsquo;s not really anything <em>useful</em> that our VM can do if it can&rsquo;t get the
memory it needs, but we at least detect that and abort the process immediately
instead of returning a <code>NULL</code> pointer and letting it go off the rails later.</p>
<aside name="shrink">
<p>Since all we passed in was a bare pointer to the first byte of memory, what does
it mean to &ldquo;update&rdquo; the block&rsquo;s size? Under the hood, the memory allocator
maintains additional bookkeeping information for each block of heap-allocated
memory, including its size.</p>
<p>Given a pointer to some previously allocated memory, it can find this
bookkeeping information, which is necessary to be able to cleanly free it. It&rsquo;s
this size metadata that <code>realloc()</code> updates.</p>
<p>Many implementations of <code>malloc()</code> store the allocated size in memory right
<em>before</em> the returned address.</p>
</aside>
<p>OK, we can create new chunks and write instructions to them. Are we done? Nope!
We&rsquo;re in C now, remember, we have to manage memory ourselves, like in Ye Olden
Times, and that means <em>freeing</em> it too.</p>
<div class="codehilite"><pre class="insert-before">void initChunk(Chunk* chunk);
</pre><div class="source-file"><em>chunk.h</em><br>
add after <em>initChunk</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">freeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after">void writeChunk(Chunk* chunk, uint8_t byte);
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, add after <em>initChunk</em>()</div>

<p>The implementation is:</p>
<div class="codehilite"><div class="source-file"><em>chunk.c</em><br>
add after <em>initChunk</em>()</div>
<pre><span class="t">void</span> <span class="i">freeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>) {
  <span class="a">FREE_ARRAY</span>(<span class="t">uint8_t</span>, <span class="i">chunk</span>-&gt;<span class="i">code</span>, <span class="i">chunk</span>-&gt;<span class="i">capacity</span>);
  <span class="i">initChunk</span>(<span class="i">chunk</span>);
}
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, add after <em>initChunk</em>()</div>

<p>We deallocate all of the memory and then call <code>initChunk()</code> to zero out the
fields leaving the chunk in a well-defined empty state. To free the memory, we
add one more macro.</p>
<div class="codehilite"><pre class="insert-before">#define GROW_ARRAY(type, pointer, oldCount, newCount) \
    (type*)reallocate(pointer, sizeof(type) * (oldCount), \
        sizeof(type) * (newCount))
</pre><div class="source-file"><em>memory.h</em></div>
<pre class="insert">

<span class="a">#define FREE_ARRAY(type, pointer, oldCount) \</span>
<span class="a">    reallocate(pointer, sizeof(type) * (oldCount), 0)</span>
</pre><pre class="insert-after">

void* reallocate(void* pointer, size_t oldSize, size_t newSize);
</pre></div>
<div class="source-file-narrow"><em>memory.h</em></div>

<p>Like <code>GROW_ARRAY()</code>, this is a wrapper around a call to <code>reallocate()</code>. This one
frees the memory by passing in zero for the new size. I know, this is a lot of
boring low-level stuff. Don&rsquo;t worry, we&rsquo;ll get a lot of use out of these in
later chapters and will get to program at a higher level. Before we can do that,
though, we gotta lay our own foundation.</p>
<h2><a href="#disassembling-chunks" id="disassembling-chunks"><small>14&#8202;.&#8202;4</small>Disassembling Chunks</a></h2>
<p>Now we have a little module for creating chunks of bytecode. Let&rsquo;s try it out by
hand-building a sample chunk.</p>
<div class="codehilite"><pre class="insert-before">int main(int argc, const char* argv[]) {
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="t">Chunk</span> <span class="i">chunk</span>;
  <span class="i">initChunk</span>(&amp;<span class="i">chunk</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_RETURN</span>);
  <span class="i">freeChunk</span>(&amp;<span class="i">chunk</span>);
</pre><pre class="insert-after">  return 0;
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>Don&rsquo;t forget the include.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>main.c</em></div>
<pre class="insert"><span class="a">#include &quot;chunk.h&quot;</span>
</pre><pre class="insert-after">

int main(int argc, const char* argv[]) {
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>

<p>Run that and give it a try. Did it work? Uh<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>who knows? All we&rsquo;ve done is push
some bytes around in memory. We have no human-friendly way to see what&rsquo;s
actually inside that chunk we made.</p>
<p>To fix this, we&rsquo;re going to create a <strong>disassembler</strong>. An <strong>assembler</strong> is an
old-school program that takes a file containing human-readable mnemonic names
for CPU instructions like &ldquo;ADD&rdquo; and &ldquo;MULT&rdquo; and translates them to their binary
machine code equivalent. A <em>dis</em>assembler goes in the other direction<span class="em">&mdash;</span>given a
blob of machine code, it spits out a textual listing of the instructions.</p>
<p>We&rsquo;ll implement something <span name="printer">similar</span>. Given a chunk, it
will print out all of the instructions in it. A Lox <em>user</em> won&rsquo;t use this, but
we Lox <em>maintainers</em> will certainly benefit since it gives us a window into the
interpreter&rsquo;s internal representation of code.</p>
<aside name="printer">
<p>In jlox, our analogous tool was the <a href="representing-code.html#a-not-very-pretty-printer">AstPrinter class</a>.</p>
</aside>
<p>In <code>main()</code>, after we create the chunk, we pass it to the disassembler.</p>
<div class="codehilite"><pre class="insert-before">  initChunk(&amp;chunk);
  writeChunk(&amp;chunk, OP_RETURN);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">

  <span class="i">disassembleChunk</span>(&amp;<span class="i">chunk</span>, <span class="s">&quot;test chunk&quot;</span>);
</pre><pre class="insert-after">  freeChunk(&amp;chunk);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>Again, we whip up <span name="module">yet another</span> module.</p>
<aside name="module">
<p>I promise you we won&rsquo;t be creating this many new files in later chapters.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>main.c</em></div>
<pre class="insert"><span class="a">#include &quot;debug.h&quot;</span>
</pre><pre class="insert-after">

int main(int argc, const char* argv[]) {
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>

<p>Here&rsquo;s that header:</p>
<div class="codehilite"><div class="source-file"><em>debug.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_debug_h</span>
<span class="a">#define clox_debug_h</span>

<span class="a">#include &quot;chunk.h&quot;</span>

<span class="t">void</span> <span class="i">disassembleChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>);
<span class="t">int</span> <span class="i">disassembleInstruction</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">int</span> <span class="i">offset</span>);

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>debug.h</em>, create new file</div>

<p>In <code>main()</code>, we call <code>disassembleChunk()</code> to disassemble all of the instructions
in the entire chunk. That&rsquo;s implemented in terms of the other function, which
just disassembles a single instruction. It shows up here in the header because
we&rsquo;ll call it from the VM in later chapters.</p>
<p>Here&rsquo;s a start at the implementation file:</p>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
create new file</div>
<pre><span class="a">#include &lt;stdio.h&gt;</span>

<span class="a">#include &quot;debug.h&quot;</span>

<span class="t">void</span> <span class="i">disassembleChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>) {
  <span class="i">printf</span>(<span class="s">&quot;== %s ==</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">name</span>);

  <span class="k">for</span> (<span class="t">int</span> <span class="i">offset</span> = <span class="n">0</span>; <span class="i">offset</span> &lt; <span class="i">chunk</span>-&gt;<span class="i">count</span>;) {
    <span class="i">offset</span> = <span class="i">disassembleInstruction</span>(<span class="i">chunk</span>, <span class="i">offset</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, create new file</div>

<p>To disassemble a chunk, we print a little header (so we can tell <em>which</em> chunk
we&rsquo;re looking at) and then crank through the bytecode, disassembling each
instruction. The way we iterate through the code is a little odd. Instead of
incrementing <code>offset</code> in the loop, we let <code>disassembleInstruction()</code> do it for
us. When we call that function, after disassembling the instruction at the given
offset, it returns the offset of the <em>next</em> instruction. This is because, as
we&rsquo;ll see later, instructions can have different sizes.</p>
<p>The core of the &ldquo;debug&rdquo; module is this function:</p>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
add after <em>disassembleChunk</em>()</div>
<pre><span class="t">int</span> <span class="i">disassembleInstruction</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">int</span> <span class="i">offset</span>) {
  <span class="i">printf</span>(<span class="s">&quot;%04d &quot;</span>, <span class="i">offset</span>);

  <span class="t">uint8_t</span> <span class="i">instruction</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span>];
  <span class="k">switch</span> (<span class="i">instruction</span>) {
    <span class="k">case</span> <span class="a">OP_RETURN</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_RETURN&quot;</span>, <span class="i">offset</span>);
    <span class="k">default</span>:
      <span class="i">printf</span>(<span class="s">&quot;Unknown opcode %d</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">instruction</span>);
      <span class="k">return</span> <span class="i">offset</span> + <span class="n">1</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>disassembleChunk</em>()</div>

<p>First, it prints the byte offset of the given instruction<span class="em">&mdash;</span>that tells us where
in the chunk this instruction is. This will be a helpful signpost when we start
doing control flow and jumping around in the bytecode.</p>
<p>Next, it reads a single byte from the bytecode at the given offset. That&rsquo;s our
opcode. We <span name="switch">switch</span> on that. For each kind of
instruction, we dispatch to a little utility function for displaying it. On the
off chance that the given byte doesn&rsquo;t look like an instruction at all<span class="em">&mdash;</span>a bug
in our compiler<span class="em">&mdash;</span>we print that too. For the one instruction we do have,
<code>OP_RETURN</code>, the display function is:</p>
<aside name="switch">
<p>We have only one instruction right now, but this switch will grow throughout the
rest of the book.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
add after <em>disassembleChunk</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">simpleInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">int</span> <span class="i">offset</span>) {
  <span class="i">printf</span>(<span class="s">&quot;%s</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">name</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>disassembleChunk</em>()</div>

<p>There isn&rsquo;t much to a return instruction, so all it does is print the name of
the opcode, then return the next byte offset past this instruction. Other
instructions will have more going on.</p>
<p>If we run our nascent interpreter now, it actually prints something:</p>
<div class="codehilite"><pre>== test chunk ==
0000 OP_RETURN
</pre></div>
<p>It worked! This is sort of the &ldquo;Hello, world!&rdquo; of our code representation. We
can create a chunk, write an instruction to it, and then extract that
instruction back out. Our encoding and decoding of the binary bytecode is
working.</p>
<h2><a href="#constants" id="constants"><small>14&#8202;.&#8202;5</small>Constants</a></h2>
<p>Now that we have a rudimentary chunk structure working, let&rsquo;s start making it
more useful. We can store <em>code</em> in chunks, but what about <em>data</em>? Many values
the interpreter works with are created at runtime as the result of operations.</p>
<div class="codehilite"><pre><span class="n">1</span> + <span class="n">2</span>;
</pre></div>
<p>The value 3 appears nowhere in the code here. However, the literals <code>1</code> and <code>2</code>
do. To compile that statement to bytecode, we need some sort of instruction that
means &ldquo;produce a constant&rdquo; and those literal values need to get stored in the
chunk somewhere. In jlox, the Expr.Literal AST node held the value. We need a
different solution now that we don&rsquo;t have a syntax tree.</p>
<h3><a href="#representing-values" id="representing-values"><small>14&#8202;.&#8202;5&#8202;.&#8202;1</small>Representing values</a></h3>
<p>We won&rsquo;t be <em>running</em> any code in this chapter, but since constants have a foot
in both the static and dynamic worlds of our interpreter, they force us to start
thinking at least a little bit about how our VM should represent values.</p>
<p>For now, we&rsquo;re going to start as simple as possible<span class="em">&mdash;</span>we&rsquo;ll support only
double-precision, floating-point numbers. This will obviously expand over time,
so we&rsquo;ll set up a new module to give ourselves room to grow.</p>
<div class="codehilite"><div class="source-file"><em>value.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_value_h</span>
<span class="a">#define clox_value_h</span>

<span class="a">#include &quot;common.h&quot;</span>

<span class="k">typedef</span> <span class="t">double</span> <span class="t">Value</span>;

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, create new file</div>

<p>This typedef abstracts how Lox values are concretely represented in C. That way,
we can change that representation without needing to go back and fix existing
code that passes around values.</p>
<p>Back to the question of where to store constants in a chunk. For small
fixed-size values like integers, many instruction sets store the value directly
in the code stream right after the opcode. These are called <strong>immediate
instructions</strong> because the bits for the value are immediately after the opcode.</p>
<p>That doesn&rsquo;t work well for large or variable-sized constants like strings. In a
native compiler to machine code, those bigger constants get stored in a separate
&ldquo;constant data&rdquo; region in the binary executable. Then, the instruction to load a
constant has an address or offset pointing to where the value is stored in that
section.</p>
<p>Most virtual machines do something similar. For example, the Java Virtual
Machine <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4">associates a <strong>constant pool</strong></a> with each compiled class.
That sounds good enough for clox to me. Each chunk will carry with it a list of
the values that appear as literals in the program. To keep things <span
name="immediate">simpler</span>, we&rsquo;ll put <em>all</em> constants in there, even simple
integers.</p>
<aside name="immediate">
<p>In addition to needing two kinds of constant instructions<span class="em">&mdash;</span>one for immediate
values and one for constants in the constant table<span class="em">&mdash;</span>immediates also force us
to worry about alignment, padding, and endianness. Some architectures aren&rsquo;t
happy if you try to say, stuff a 4-byte integer at an odd address.</p>
</aside>
<h3><a href="#value-arrays" id="value-arrays"><small>14&#8202;.&#8202;5&#8202;.&#8202;2</small>Value arrays</a></h3>
<p>The constant pool is an array of values. The instruction to load a constant
looks up the value by index in that array. As with our <span
name="generic">bytecode</span> array, the compiler doesn&rsquo;t know how big the
array needs to be ahead of time. So, again, we need a dynamic one. Since C
doesn&rsquo;t have generic data structures, we&rsquo;ll write another dynamic array data
structure, this time for Value.</p>
<aside name="generic">
<p>Defining a new struct and manipulation functions each time we need a dynamic
array of a different type is a chore. We could cobble together some preprocessor
macros to fake generics, but that&rsquo;s overkill for clox. We won&rsquo;t need many more
of these.</p>
</aside>
<div class="codehilite"><pre class="insert-before">typedef double Value;
</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">int</span> <span class="i">capacity</span>;
  <span class="t">int</span> <span class="i">count</span>;
  <span class="t">Value</span>* <span class="i">values</span>;
} <span class="t">ValueArray</span>;
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<p>As with the bytecode array in Chunk, this struct wraps a pointer to an array
along with its allocated capacity and the number of elements in use. We also
need the same three functions to work with value arrays.</p>
<div class="codehilite"><pre class="insert-before">} ValueArray;
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>ValueArray</em></div>
<pre class="insert">

<span class="t">void</span> <span class="i">initValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>);
<span class="t">void</span> <span class="i">writeValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>, <span class="t">Value</span> <span class="i">value</span>);
<span class="t">void</span> <span class="i">freeValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>ValueArray</em></div>

<p>The implementations will probably give you déjà vu. First, to create a new one:</p>
<div class="codehilite"><div class="source-file"><em>value.c</em><br>
create new file</div>
<pre><span class="a">#include &lt;stdio.h&gt;</span>

<span class="a">#include &quot;memory.h&quot;</span>
<span class="a">#include &quot;value.h&quot;</span>

<span class="t">void</span> <span class="i">initValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>) {
  <span class="i">array</span>-&gt;<span class="i">values</span> = <span class="a">NULL</span>;
  <span class="i">array</span>-&gt;<span class="i">capacity</span> = <span class="n">0</span>;
  <span class="i">array</span>-&gt;<span class="i">count</span> = <span class="n">0</span>;
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, create new file</div>

<p>Once we have an initialized array, we can start <span name="add">adding</span>
values to it.</p>
<aside name="add">
<p>Fortunately, we don&rsquo;t need other operations like insertion and removal.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>value.c</em><br>
add after <em>initValueArray</em>()</div>
<pre><span class="t">void</span> <span class="i">writeValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>, <span class="t">Value</span> <span class="i">value</span>) {
  <span class="k">if</span> (<span class="i">array</span>-&gt;<span class="i">capacity</span> &lt; <span class="i">array</span>-&gt;<span class="i">count</span> + <span class="n">1</span>) {
    <span class="t">int</span> <span class="i">oldCapacity</span> = <span class="i">array</span>-&gt;<span class="i">capacity</span>;
    <span class="i">array</span>-&gt;<span class="i">capacity</span> = <span class="a">GROW_CAPACITY</span>(<span class="i">oldCapacity</span>);
    <span class="i">array</span>-&gt;<span class="i">values</span> = <span class="a">GROW_ARRAY</span>(<span class="t">Value</span>, <span class="i">array</span>-&gt;<span class="i">values</span>,
                               <span class="i">oldCapacity</span>, <span class="i">array</span>-&gt;<span class="i">capacity</span>);
  }

  <span class="i">array</span>-&gt;<span class="i">values</span>[<span class="i">array</span>-&gt;<span class="i">count</span>] = <span class="i">value</span>;
  <span class="i">array</span>-&gt;<span class="i">count</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, add after <em>initValueArray</em>()</div>

<p>The memory-management macros we wrote earlier do let us reuse some of the logic
from the code array, so this isn&rsquo;t too bad. Finally, to release all memory used
by the array:</p>
<div class="codehilite"><div class="source-file"><em>value.c</em><br>
add after <em>writeValueArray</em>()</div>
<pre><span class="t">void</span> <span class="i">freeValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>) {
  <span class="a">FREE_ARRAY</span>(<span class="t">Value</span>, <span class="i">array</span>-&gt;<span class="i">values</span>, <span class="i">array</span>-&gt;<span class="i">capacity</span>);
  <span class="i">initValueArray</span>(<span class="i">array</span>);
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, add after <em>writeValueArray</em>()</div>

<p>Now that we have growable arrays of values, we can add one to Chunk to store the
chunk&rsquo;s constants.</p>
<div class="codehilite"><pre class="insert-before">  uint8_t* code;
</pre><div class="source-file"><em>chunk.h</em><br>
in struct <em>Chunk</em></div>
<pre class="insert">  <span class="t">ValueArray</span> <span class="i">constants</span>;
</pre><pre class="insert-after">} Chunk;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in struct <em>Chunk</em></div>

<p>Don&rsquo;t forget the include.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>chunk.h</em></div>
<pre class="insert"><span class="a">#include &quot;value.h&quot;</span>
</pre><pre class="insert-after">

typedef enum {
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em></div>

<p>Ah, C, and its Stone Age modularity story. Where were we? Right. When we
initialize a new chunk, we initialize its constant list too.</p>
<div class="codehilite"><pre class="insert-before">  chunk-&gt;code = NULL;
</pre><div class="source-file"><em>chunk.c</em><br>
in <em>initChunk</em>()</div>
<pre class="insert">  <span class="i">initValueArray</span>(&amp;<span class="i">chunk</span>-&gt;<span class="i">constants</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>initChunk</em>()</div>

<p>Likewise, we free the constants when we free the chunk.</p>
<div class="codehilite"><pre class="insert-before">  FREE_ARRAY(uint8_t, chunk-&gt;code, chunk-&gt;capacity);
</pre><div class="source-file"><em>chunk.c</em><br>
in <em>freeChunk</em>()</div>
<pre class="insert">  <span class="i">freeValueArray</span>(&amp;<span class="i">chunk</span>-&gt;<span class="i">constants</span>);
</pre><pre class="insert-after">  initChunk(chunk);
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>freeChunk</em>()</div>

<p>Next, we define a convenience method to add a new constant to the chunk. Our
yet-to-be-written compiler could write to the constant array inside Chunk
directly<span class="em">&mdash;</span>it&rsquo;s not like C has private fields or anything<span class="em">&mdash;</span>but it&rsquo;s a little
nicer to add an explicit function.</p>
<div class="codehilite"><pre class="insert-before">void writeChunk(Chunk* chunk, uint8_t byte);
</pre><div class="source-file"><em>chunk.h</em><br>
add after <em>writeChunk</em>()</div>
<pre class="insert"><span class="t">int</span> <span class="i">addConstant</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">Value</span> <span class="i">value</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, add after <em>writeChunk</em>()</div>

<p>Then we implement it.</p>
<div class="codehilite"><div class="source-file"><em>chunk.c</em><br>
add after <em>writeChunk</em>()</div>
<pre><span class="t">int</span> <span class="i">addConstant</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">Value</span> <span class="i">value</span>) {
  <span class="i">writeValueArray</span>(&amp;<span class="i">chunk</span>-&gt;<span class="i">constants</span>, <span class="i">value</span>);
  <span class="k">return</span> <span class="i">chunk</span>-&gt;<span class="i">constants</span>.<span class="i">count</span> - <span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, add after <em>writeChunk</em>()</div>

<p>After we add the constant, we return the index where the constant was appended
so that we can locate that same constant later.</p>
<h3><a href="#constant-instructions" id="constant-instructions"><small>14&#8202;.&#8202;5&#8202;.&#8202;3</small>Constant instructions</a></h3>
<p>We can <em>store</em> constants in chunks, but we also need to <em>execute</em> them. In a
piece of code like:</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="n">1</span>;
<span class="k">print</span> <span class="n">2</span>;
</pre></div>
<p>The compiled chunk needs to not only contain the values 1 and 2, but know <em>when</em>
to produce them so that they are printed in the right order. Thus, we need an
instruction that produces a particular constant.</p>
<div class="codehilite"><pre class="insert-before">typedef enum {
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_CONSTANT</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>When the VM executes a constant instruction, it <span name="load">&ldquo;loads&rdquo;</span>
the constant for use. This new instruction is a little more complex than
<code>OP_RETURN</code>. In the above example, we load two different constants. A single
bare opcode isn&rsquo;t enough to know <em>which</em> constant to load.</p>
<aside name="load">
<p>I&rsquo;m being vague about what it means to &ldquo;load&rdquo; or &ldquo;produce&rdquo; a constant because we
haven&rsquo;t learned how the virtual machine actually executes code at runtime yet.
For that, you&rsquo;ll have to wait until you get to (or skip ahead to, I suppose) the
<a href="a-virtual-machine.html">next chapter</a>.</p>
</aside>
<p>To handle cases like this, our bytecode<span class="em">&mdash;</span>like most others<span class="em">&mdash;</span>allows
instructions to have <span name="operand"><strong>operands</strong></span>. These are stored
as binary data immediately after the opcode in the instruction stream and let us
parameterize what the instruction does.</p>
<p><img src="image/chunks-of-bytecode/format.png" alt="OP_CONSTANT is a byte for
the opcode followed by a byte for the constant index." /></p>
<p>Each opcode determines how many operand bytes it has and what they mean. For
example, a simple operation like &ldquo;return&rdquo; may have no operands, where an
instruction for &ldquo;load local variable&rdquo; needs an operand to identify which
variable to load. Each time we add a new opcode to clox, we specify what its
operands look like<span class="em">&mdash;</span>its <strong>instruction format</strong>.</p>
<aside name="operand">
<p>Bytecode instruction operands are <em>not</em> the same as the operands passed to an
arithmetic operator. You&rsquo;ll see when we get to expressions that arithmetic
operand values are tracked separately. Instruction operands are a lower-level
notion that modify how the bytecode instruction itself behaves.</p>
</aside>
<p>In this case, <code>OP_CONSTANT</code> takes a single byte operand that specifies which
constant to load from the chunk&rsquo;s constant array. Since we don&rsquo;t have a compiler
yet, we &ldquo;hand-compile&rdquo; an instruction in our test chunk.</p>
<div class="codehilite"><pre class="insert-before">  initChunk(&amp;chunk);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">

  <span class="t">int</span> <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">1.2</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>);

</pre><pre class="insert-after">  writeChunk(&amp;chunk, OP_RETURN);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>We add the constant value itself to the chunk&rsquo;s constant pool. That returns the
index of the constant in the array. Then we write the constant instruction,
starting with its opcode. After that, we write the one-byte constant index
operand. Note that <code>writeChunk()</code> can write opcodes or operands. It&rsquo;s all raw
bytes as far as that function is concerned.</p>
<p>If we try to run this now, the disassembler is going to yell at us because it
doesn&rsquo;t know how to decode the new instruction. Let&rsquo;s fix that.</p>
<div class="codehilite"><pre class="insert-before">  switch (instruction) {
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_CONSTANT</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_CONSTANT&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>This instruction has a different instruction format, so we write a new helper
function to disassemble it.</p>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
add after <em>disassembleChunk</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">constantInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>,
                               <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>];
  <span class="i">printf</span>(<span class="s">&quot;%-16s %4d &#39;&quot;</span>, <span class="i">name</span>, <span class="i">constant</span>);
  <span class="i">printValue</span>(<span class="i">chunk</span>-&gt;<span class="i">constants</span>.<span class="i">values</span>[<span class="i">constant</span>]);
  <span class="i">printf</span>(<span class="s">&quot;&#39;</span><span class="e">\n</span><span class="s">&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>disassembleChunk</em>()</div>

<p>There&rsquo;s more going on here. As with <code>OP_RETURN</code>, we print out the name of the
opcode. Then we pull out the constant index from the subsequent byte in the
chunk. We print that index, but that isn&rsquo;t super useful to us human readers. So
we also look up the actual constant value<span class="em">&mdash;</span>since constants <em>are</em> known at
compile time after all<span class="em">&mdash;</span>and display the value itself too.</p>
<p>This requires some way to print a clox Value. That function will live in the
&ldquo;value&rdquo; module, so we include that.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;debug.h&quot;
</pre><div class="source-file"><em>debug.c</em></div>
<pre class="insert"><span class="a">#include &quot;value.h&quot;</span>
</pre><pre class="insert-after">

void disassembleChunk(Chunk* chunk, const char* name) {
</pre></div>
<div class="source-file-narrow"><em>debug.c</em></div>

<p>Over in that header, we declare:</p>
<div class="codehilite"><pre class="insert-before">void freeValueArray(ValueArray* array);
</pre><div class="source-file"><em>value.h</em><br>
add after <em>freeValueArray</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">printValue</span>(<span class="t">Value</span> <span class="i">value</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after <em>freeValueArray</em>()</div>

<p>And here&rsquo;s an implementation:</p>
<div class="codehilite"><div class="source-file"><em>value.c</em><br>
add after <em>freeValueArray</em>()</div>
<pre><span class="t">void</span> <span class="i">printValue</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="i">printf</span>(<span class="s">&quot;%g&quot;</span>, <span class="i">value</span>);
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, add after <em>freeValueArray</em>()</div>

<p>Magnificent, right? As you can imagine, this is going to get more complex once
we add dynamic typing to Lox and have values of different types.</p>
<p>Back in <code>constantInstruction()</code>, the only remaining piece is the return value.</p>
<div class="codehilite"><pre class="insert-before">  printf(&quot;'\n&quot;);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>constantInstruction</em>()</div>
<pre class="insert">  <span class="k">return</span> <span class="i">offset</span> + <span class="n">2</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>constantInstruction</em>()</div>

<p>Remember that <code>disassembleInstruction()</code> also returns a number to tell the
caller the offset of the beginning of the <em>next</em> instruction. Where <code>OP_RETURN</code>
was only a single byte, <code>OP_CONSTANT</code> is two<span class="em">&mdash;</span>one for the opcode and one for
the operand.</p>
<h2><a href="#line-information" id="line-information"><small>14&#8202;.&#8202;6</small>Line Information</a></h2>
<p>Chunks contain almost all of the information that the runtime needs from the
user&rsquo;s source code. It&rsquo;s kind of crazy to think that we can reduce all of the
different AST classes that we created in jlox down to an array of bytes and an
array of constants. There&rsquo;s only one piece of data we&rsquo;re missing. We need it,
even though the user hopes to never see it.</p>
<p>When a runtime error occurs, we show the user the line number of the offending
source code. In jlox, those numbers live in tokens, which we in turn store in
the AST nodes. We need a different solution for clox now that we&rsquo;ve ditched
syntax trees in favor of bytecode. Given any bytecode instruction, we need to be
able to determine the line of the user&rsquo;s source program that it was compiled
from.</p>
<p>There are a lot of clever ways we could encode this. I took the absolute <span
name="side">simplest</span> approach I could come up with, even though it&rsquo;s
embarrassingly inefficient with memory. In the chunk, we store a separate array
of integers that parallels the bytecode. Each number in the array is the line
number for the corresponding byte in the bytecode. When a runtime error occurs,
we look up the line number at the same index as the current instruction&rsquo;s offset
in the code array.</p>
<aside name="side">
<p>This braindead encoding does do one thing right: it keeps the line information
in a <em>separate</em> array instead of interleaving it in the bytecode itself. Since
line information is only used when a runtime error occurs, we don&rsquo;t want it
between the instructions, taking up precious space in the CPU cache and causing
more cache misses as the interpreter skips past it to get to the opcodes and
operands it cares about.</p>
</aside>
<p>To implement this, we add another array to Chunk.</p>
<div class="codehilite"><pre class="insert-before">  uint8_t* code;
</pre><div class="source-file"><em>chunk.h</em><br>
in struct <em>Chunk</em></div>
<pre class="insert">  <span class="t">int</span>* <span class="i">lines</span>;
</pre><pre class="insert-after">  ValueArray constants;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in struct <em>Chunk</em></div>

<p>Since it exactly parallels the bytecode array, we don&rsquo;t need a separate count or
capacity. Every time we touch the code array, we make a corresponding change to
the line number array, starting with initialization.</p>
<div class="codehilite"><pre class="insert-before">  chunk-&gt;code = NULL;
</pre><div class="source-file"><em>chunk.c</em><br>
in <em>initChunk</em>()</div>
<pre class="insert">  <span class="i">chunk</span>-&gt;<span class="i">lines</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">  initValueArray(&amp;chunk-&gt;constants);
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>initChunk</em>()</div>

<p>And likewise deallocation:</p>
<div class="codehilite"><pre class="insert-before">  FREE_ARRAY(uint8_t, chunk-&gt;code, chunk-&gt;capacity);
</pre><div class="source-file"><em>chunk.c</em><br>
in <em>freeChunk</em>()</div>
<pre class="insert">  <span class="a">FREE_ARRAY</span>(<span class="t">int</span>, <span class="i">chunk</span>-&gt;<span class="i">lines</span>, <span class="i">chunk</span>-&gt;<span class="i">capacity</span>);
</pre><pre class="insert-after">  freeValueArray(&amp;chunk-&gt;constants);
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>freeChunk</em>()</div>

<p>When we write a byte of code to the chunk, we need to know what source line it
came from, so we add an extra parameter in the declaration of <code>writeChunk()</code>.</p>
<div class="codehilite"><pre class="insert-before">void freeChunk(Chunk* chunk);
</pre><div class="source-file"><em>chunk.h</em><br>
function <em>writeChunk</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="t">void</span> <span class="i">writeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">uint8_t</span> <span class="i">byte</span>, <span class="t">int</span> <span class="i">line</span>);
</pre><pre class="insert-after">int addConstant(Chunk* chunk, Value value);
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, function <em>writeChunk</em>(), replace 1 line</div>

<p>And in the implementation:</p>
<div class="codehilite"><div class="source-file"><em>chunk.c</em><br>
function <em>writeChunk</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="t">void</span> <span class="i">writeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">uint8_t</span> <span class="i">byte</span>, <span class="t">int</span> <span class="i">line</span>) {
</pre><pre class="insert-after">  if (chunk-&gt;capacity &lt; chunk-&gt;count + 1) {
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, function <em>writeChunk</em>(), replace 1 line</div>

<p>When we allocate or grow the code array, we do the same for the line info too.</p>
<div class="codehilite"><pre class="insert-before">    chunk-&gt;code = GROW_ARRAY(uint8_t, chunk-&gt;code,
        oldCapacity, chunk-&gt;capacity);
</pre><div class="source-file"><em>chunk.c</em><br>
in <em>writeChunk</em>()</div>
<pre class="insert">    <span class="i">chunk</span>-&gt;<span class="i">lines</span> = <span class="a">GROW_ARRAY</span>(<span class="t">int</span>, <span class="i">chunk</span>-&gt;<span class="i">lines</span>,
        <span class="i">oldCapacity</span>, <span class="i">chunk</span>-&gt;<span class="i">capacity</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>writeChunk</em>()</div>

<p>Finally, we store the line number in the array.</p>
<div class="codehilite"><pre class="insert-before">  chunk-&gt;code[chunk-&gt;count] = byte;
</pre><div class="source-file"><em>chunk.c</em><br>
in <em>writeChunk</em>()</div>
<pre class="insert">  <span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">chunk</span>-&gt;<span class="i">count</span>] = <span class="i">line</span>;
</pre><pre class="insert-after">  chunk-&gt;count++;
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>writeChunk</em>()</div>

<h3><a href="#disassembling-line-information" id="disassembling-line-information"><small>14&#8202;.&#8202;6&#8202;.&#8202;1</small>Disassembling line information</a></h3>
<p>Alright, let&rsquo;s try this out with our little, uh, artisanal chunk. First, since
we added a new parameter to <code>writeChunk()</code>, we need to fix those calls to pass
in some<span class="em">&mdash;</span>arbitrary at this point<span class="em">&mdash;</span>line number.</p>
<div class="codehilite"><pre class="insert-before">  int constant = addConstant(&amp;chunk, 1.2);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()<br>
replace 4 lines</div>
<pre class="insert">  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_RETURN</span>, <span class="n">123</span>);
</pre><pre class="insert-after">

  disassembleChunk(&amp;chunk, &quot;test chunk&quot;);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>(), replace 4 lines</div>

<p>Once we have a real front end, of course, the compiler will track the current
line as it parses and pass that in.</p>
<p>Now that we have line information for every instruction, let&rsquo;s put it to good
use. In our disassembler, it&rsquo;s helpful to show which source line each
instruction was compiled from. That gives us a way to map back to the original
code when we&rsquo;re trying to figure out what some blob of bytecode is supposed to
do. After printing the offset of the instruction<span class="em">&mdash;</span>the number of bytes from the
beginning of the chunk<span class="em">&mdash;</span>we show its source line.</p>
<div class="codehilite"><pre class="insert-before">int disassembleInstruction(Chunk* chunk, int offset) {
  printf(&quot;%04d &quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">offset</span> &gt; <span class="n">0</span> &amp;&amp;
      <span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">offset</span>] == <span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">offset</span> - <span class="n">1</span>]) {
    <span class="i">printf</span>(<span class="s">&quot;   | &quot;</span>);
  } <span class="k">else</span> {
    <span class="i">printf</span>(<span class="s">&quot;%4d &quot;</span>, <span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">offset</span>]);
  }
</pre><pre class="insert-after">

  uint8_t instruction = chunk-&gt;code[offset];
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Bytecode instructions tend to be pretty fine-grained. A single line of source
code often compiles to a whole sequence of instructions. To make that more
visually clear, we show a <code>|</code> for any instruction that comes from the same
source line as the preceding one. The resulting output for our handwritten
chunk looks like:</p>
<div class="codehilite"><pre>== test chunk ==
0000  123 OP_CONSTANT         0 '1.2'
0002    | OP_RETURN
</pre></div>
<p>We have a three-byte chunk. The first two bytes are a constant instruction that
loads 1.2 from the chunk&rsquo;s constant pool. The first byte is the <code>OP_CONSTANT</code>
opcode and the second is the index in the constant pool. The third byte (at
offset 2) is a single-byte return instruction.</p>
<p>In the remaining chapters, we will flesh this out with lots more kinds of
instructions. But the basic structure is here, and we have everything we need
now to completely represent an executable piece of code at runtime in our
virtual machine. Remember that whole family of AST classes we defined in jlox?
In clox, we&rsquo;ve reduced that down to three arrays: bytes of code, constant
values, and line information for debugging.</p>
<p>This reduction is a key reason why our new interpreter will be faster than jlox.
You can think of bytecode as a sort of compact serialization of the AST, highly
optimized for how the interpreter will deserialize it in the order it needs as
it executes. In the <a href="a-virtual-machine.html">next chapter</a>, we will see how the virtual machine does
exactly that.</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Our encoding of line information is hilariously wasteful of memory. Given
that a series of instructions often correspond to the same source line, a
natural solution is something akin to <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding</a> of the line
numbers.</p>
<p>Devise an encoding that compresses the line information for a
series of instructions on the same line. Change <code>writeChunk()</code> to write this
compressed form, and implement a <code>getLine()</code> function that, given the index
of an instruction, determines the line where the instruction occurs.</p>
<p><em>Hint: It&rsquo;s not necessary for <code>getLine()</code> to be particularly efficient.
Since it is called only when a runtime error occurs, it is well off the
critical path where performance matters.</em></p>
</li>
<li>
<p>Because <code>OP_CONSTANT</code> uses only a single byte for its operand, a chunk may
only contain up to 256 different constants. That&rsquo;s small enough that people
writing real-world code will hit that limit. We could use two or more bytes
to store the operand, but that makes <em>every</em> constant instruction take up
more space. Most chunks won&rsquo;t need that many unique constants, so that
wastes space and sacrifices some locality in the common case to support the
rare case.</p>
<p>To balance those two competing aims, many instruction sets feature multiple
instructions that perform the same operation but with operands of different
sizes. Leave our existing one-byte <code>OP_CONSTANT</code> instruction alone, and
define a second <code>OP_CONSTANT_LONG</code> instruction. It stores the operand as a
24-bit number, which should be plenty.</p>
<p>Implement this function:</p>
<div class="codehilite"><pre><span class="t">void</span> <span class="i">writeConstant</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">Value</span> <span class="i">value</span>, <span class="t">int</span> <span class="i">line</span>) {
  <span class="c">// Implement me...</span>
}
</pre></div>
<p>It adds <code>value</code> to <code>chunk</code>&rsquo;s constant array and then writes an appropriate
instruction to load the constant. Also add support to the disassembler for
<code>OP_CONSTANT_LONG</code> instructions.</p>
<p>Defining two instructions seems to be the best of both worlds. What
sacrifices, if any, does it force on us?</p>
</li>
<li>
<p>Our <code>reallocate()</code> function relies on the C standard library for dynamic
memory allocation and freeing. <code>malloc()</code> and <code>free()</code> aren&rsquo;t magic. Find
a couple of open source implementations of them and explain how they work.
How do they keep track of which bytes are allocated and which are free?
What is required to allocate a block of memory? Free it? How do they make
that efficient? What do they do about fragmentation?</p>
<p><em>Hardcore mode:</em> Implement <code>reallocate()</code> without calling <code>realloc()</code>,
<code>malloc()</code>, or <code>free()</code>. You are allowed to call <code>malloc()</code> <em>once</em>, at the
beginning of the interpreter&rsquo;s execution, to allocate a single big block of
memory, which your <code>reallocate()</code> function has access to. It parcels out
blobs of memory from that single region, your own personal heap. It&rsquo;s your
job to define how it does that.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: Test Your Language</a></h2>
<p>We&rsquo;re almost halfway through the book and one thing we haven&rsquo;t talked about is
<em>testing</em> your language implementation. That&rsquo;s not because testing isn&rsquo;t
important. I can&rsquo;t possibly stress enough how vital it is to have a good,
comprehensive test suite for your language.</p>
<p>I wrote a <a href="https://github.com/munificent/craftinginterpreters/tree/master/test">test suite for Lox</a> (which you are welcome to use on your own
Lox implementation) before I wrote a single word of this book. Those tests found
countless bugs in my implementations.</p>
<p>Tests are important in all software, but they&rsquo;re even more important for a
programming language for at least a couple of reasons:</p>
<ul>
<li>
<p><strong>Users expect their programming languages to be rock solid.</strong> We are so
used to mature, stable compilers and interpreters that &ldquo;It&rsquo;s your code, not
the compiler&rdquo; is <a href="https://blog.codinghorror.com/the-first-rule-of-programming-its-always-your-fault/">an ingrained part of software culture</a>. If there
are bugs in your language implementation, users will go through the full
five stages of grief before they can figure out what&rsquo;s going on, and you
don&rsquo;t want to put them through all that.</p>
</li>
<li>
<p><strong>A language implementation is a deeply interconnected piece of software.</strong>
Some codebases are broad and shallow. If the file loading code is broken in
your text editor, it<span class="em">&mdash;</span>hopefully!<span class="em">&mdash;</span>won&rsquo;t cause failures in the text
rendering on screen. Language implementations are narrower and deeper,
especially the core of the interpreter that handles the language&rsquo;s actual
semantics. That makes it easy for subtle bugs to creep in caused by weird
interactions between various parts of the system. It takes good tests to
flush those out.</p>
</li>
<li>
<p><strong>The input to a language implementation is, by design, combinatorial.</strong>
There are an infinite number of possible programs a user could write, and
your implementation needs to run them all correctly. You obviously can&rsquo;t
test that exhaustively, but you need to work hard to cover as much of the
input space as you can.</p>
</li>
<li>
<p><strong>Language implementations are often complex, constantly changing, and full
of optimizations.</strong> That leads to gnarly code with lots of dark corners
where bugs can hide.</p>
</li>
</ul>
<p>All of that means you&rsquo;re gonna want a lot of tests. But <em>what</em> tests? Projects
I&rsquo;ve seen focus mostly on end-to-end &ldquo;language tests&rdquo;. Each test is a program
written in the language along with the output or errors it is expected to
produce. Then you have a test runner that pushes the test program through your
language implementation and validates that it does what it&rsquo;s supposed to.
Writing your tests in the language itself has a few nice advantages:</p>
<ul>
<li>
<p>The tests aren&rsquo;t coupled to any particular API or internal architecture
decisions of the implementation. This frees you to reorganize or rewrite
parts of your interpreter or compiler without needing to update a slew of
tests.</p>
</li>
<li>
<p>You can use the same tests for multiple implementations of the language.</p>
</li>
<li>
<p>Tests can often be terse and easy to read and maintain since they are
simply scripts in your language.</p>
</li>
</ul>
<p>It&rsquo;s not all rosy, though:</p>
<ul>
<li>
<p>End-to-end tests help you determine <em>if</em> there is a bug, but not <em>where</em> the
bug is. It can be harder to figure out where the erroneous code in the
implementation is because all the test tells you is that the right output
didn&rsquo;t appear.</p>
</li>
<li>
<p>It can be a chore to craft a valid program that tickles some obscure corner
of the implementation. This is particularly true for highly optimized
compilers where you may need to write convoluted code to ensure that you
end up on just the right optimization path where a bug may be hiding.</p>
</li>
<li>
<p>The overhead can be high to fire up the interpreter, parse, compile, and
run each test script. With a big suite of tests<span class="em">&mdash;</span>which you <em>do</em> want,
remember<span class="em">&mdash;</span>that can mean a lot of time spent waiting for the tests to
finish running.</p>
</li>
</ul>
<p>I could go on, but I don&rsquo;t want this to turn into a sermon. Also, I don&rsquo;t
pretend to be an expert on <em>how</em> to test languages. I just want you to
internalize how important it is <em>that</em> you test yours. Seriously. Test your
language. You&rsquo;ll thank me for it.</p>
</div>

<footer>
<a href="a-virtual-machine.html" class="next">
  Next Chapter: &ldquo;A Virtual Machine&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>A Virtual Machine &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">A Virtual Machine<small>15</small></a></h3>

<ul>
    <li><a href="#an-instruction-execution-machine"><small>15.1</small> An Instruction Execution Machine</a></li>
    <li><a href="#a-value-stack-manipulator"><small>15.2</small> A Value Stack Manipulator</a></li>
    <li><a href="#an-arithmetic-calculator"><small>15.3</small> An Arithmetic Calculator</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Register-Based Bytecode</a></li>
</ul>


<div class="prev-next">
    <a href="chunks-of-bytecode.html" title="Chunks of Bytecode" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="scanning-on-demand.html" title="Scanning on Demand" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="chunks-of-bytecode.html" title="Chunks of Bytecode" class="prev">←</a>
<a href="scanning-on-demand.html" title="Scanning on Demand" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">A Virtual Machine<small>15</small></a></h3>

<ul>
    <li><a href="#an-instruction-execution-machine"><small>15.1</small> An Instruction Execution Machine</a></li>
    <li><a href="#a-value-stack-manipulator"><small>15.2</small> A Value Stack Manipulator</a></li>
    <li><a href="#an-arithmetic-calculator"><small>15.3</small> An Arithmetic Calculator</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Register-Based Bytecode</a></li>
</ul>


<div class="prev-next">
    <a href="chunks-of-bytecode.html" title="Chunks of Bytecode" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="scanning-on-demand.html" title="Scanning on Demand" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">15</div>
  <h1>A Virtual Machine</h1>

<blockquote>
<p>Magicians protect their secrets not because the secrets are large and
important, but because they are so small and trivial. The wonderful effects
created on stage are often the result of a secret so absurd that the magician
would be embarrassed to admit that that was how it was done.</p>
<p><cite>Christopher Priest, <em>The Prestige</em></cite></p>
</blockquote>
<p>We&rsquo;ve spent a lot of time talking about how to represent a program as a sequence
of bytecode instructions, but it feels like learning biology using only stuffed,
dead animals. We know what instructions are in theory, but we&rsquo;ve never seen them
in action, so it&rsquo;s hard to really understand what they <em>do</em>. It would be hard to
write a compiler that outputs bytecode when we don&rsquo;t have a good understanding
of how that bytecode behaves.</p>
<p>So, before we go and build the front end of our new interpreter, we will begin
with the back end<span class="em">&mdash;</span>the virtual machine that executes instructions. It breathes
life into the bytecode. Watching the instructions prance around gives us a
clearer picture of how a compiler might translate the user&rsquo;s source code into a
series of them.</p>
<h2><a href="#an-instruction-execution-machine" id="an-instruction-execution-machine"><small>15&#8202;.&#8202;1</small>An Instruction Execution Machine</a></h2>
<p>The virtual machine is one part of our interpreter&rsquo;s internal architecture. You
hand it a chunk of code<span class="em">&mdash;</span>literally a Chunk<span class="em">&mdash;</span>and it runs it. The code and
data structures for the VM reside in a new module.</p>
<div class="codehilite"><div class="source-file"><em>vm.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_vm_h</span>
<span class="a">#define clox_vm_h</span>

<span class="a">#include &quot;chunk.h&quot;</span>

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Chunk</span>* <span class="i">chunk</span>;
} <span class="a">VM</span>;

<span class="t">void</span> <span class="i">initVM</span>();
<span class="t">void</span> <span class="i">freeVM</span>();

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, create new file</div>

<p>As usual, we start simple. The VM will gradually acquire a whole pile of state
it needs to keep track of, so we define a struct now to stuff that all in.
Currently, all we store is the chunk that it executes.</p>
<p>Like we do with most of the data structures we create, we also define functions
to create and tear down a VM. Here&rsquo;s the implementation:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
create new file</div>
<pre><span class="a">#include &quot;common.h&quot;</span>
<span class="a">#include &quot;vm.h&quot;</span>

<span class="a">VM</span> <span class="i">vm</span>;<span name="one"> </span>

<span class="t">void</span> <span class="i">initVM</span>() {
}

<span class="t">void</span> <span class="i">freeVM</span>() {
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, create new file</div>

<p>OK, calling those functions &ldquo;implementations&rdquo; is a stretch. We don&rsquo;t have any
interesting state to initialize or free yet, so the functions are empty. Trust
me, we&rsquo;ll get there.</p>
<p>The slightly more interesting line here is that declaration of <code>vm</code>. This module
is eventually going to have a slew of functions and it would be a chore to pass
around a pointer to the VM to all of them. Instead, we declare a single global
VM object. We need only one anyway, and this keeps the code in the book a little
lighter on the page.</p>
<aside name="one">
<p>The choice to have a static VM instance is a concession for the book, but not
necessarily a sound engineering choice for a real language implementation. If
you&rsquo;re building a VM that&rsquo;s designed to be embedded in other host applications,
it gives the host more flexibility if you <em>do</em> explicitly take a VM pointer
and pass it around.</p>
<p>That way, the host app can control when and where memory for the VM is
allocated, run multiple VMs in parallel, etc.</p>
<p>What I&rsquo;m doing here is a global variable, and <a href="http://gameprogrammingpatterns.com/singleton.html">everything bad you&rsquo;ve heard about
global variables</a> is still true when programming in the large. But when
keeping things small for a book<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
</aside>
<p>Before we start pumping fun code into our VM, let&rsquo;s go ahead and wire it up to
the interpreter&rsquo;s main entrypoint.</p>
<div class="codehilite"><pre class="insert-before">int main(int argc, const char* argv[]) {
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">initVM</span>();

</pre><pre class="insert-after">  Chunk chunk;
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>We spin up the VM when the interpreter first starts. Then when we&rsquo;re about to
exit, we wind it down.</p>
<div class="codehilite"><pre class="insert-before">  disassembleChunk(&amp;chunk, &quot;test chunk&quot;);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">freeVM</span>();
</pre><pre class="insert-after">  freeChunk(&amp;chunk);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>One last ceremonial obligation:</p>
<div class="codehilite"><pre class="insert-before">#include &quot;debug.h&quot;
</pre><div class="source-file"><em>main.c</em></div>
<pre class="insert"><span class="a">#include &quot;vm.h&quot;</span>
</pre><pre class="insert-after">

int main(int argc, const char* argv[]) {
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>

<p>Now when you run clox, it starts up the VM before it creates that hand-authored
chunk from the <a href="chunks-of-bytecode.html#disassembling-chunks">last chapter</a>. The VM is ready and waiting, so let&rsquo;s teach it
to do something.</p>
<h3><a href="#executing-instructions" id="executing-instructions"><small>15&#8202;.&#8202;1&#8202;.&#8202;1</small>Executing instructions</a></h3>
<p>The VM springs into action when we command it to interpret a chunk of bytecode.</p>
<div class="codehilite"><pre class="insert-before">  disassembleChunk(&amp;chunk, &quot;test chunk&quot;);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">interpret</span>(&amp;<span class="i">chunk</span>);
</pre><pre class="insert-after">  freeVM();
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>This function is the main entrypoint into the VM. It&rsquo;s declared like so:</p>
<div class="codehilite"><pre class="insert-before">void freeVM();
</pre><div class="source-file"><em>vm.h</em><br>
add after <em>freeVM</em>()</div>
<pre class="insert"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after <em>freeVM</em>()</div>

<p>The VM runs the chunk and then responds with a value from this enum:</p>
<div class="codehilite"><pre class="insert-before">} VM;

</pre><div class="source-file"><em>vm.h</em><br>
add after struct <em>VM</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">INTERPRET_OK</span>,
  <span class="a">INTERPRET_COMPILE_ERROR</span>,
  <span class="a">INTERPRET_RUNTIME_ERROR</span>
} <span class="t">InterpretResult</span>;

</pre><pre class="insert-after">void initVM();
void freeVM();
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after struct <em>VM</em></div>

<p>We aren&rsquo;t using the result yet, but when we have a compiler that reports static
errors and a VM that detects runtime errors, the interpreter will use this to
know how to set the exit code of the process.</p>
<p>We&rsquo;re inching towards some actual implementation.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>freeVM</em>()</div>
<pre><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>) {
  <span class="i">vm</span>.<span class="i">chunk</span> = <span class="i">chunk</span>;
  <span class="i">vm</span>.<span class="i">ip</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>;
  <span class="k">return</span> <span class="i">run</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>

<p>First, we store the chunk being executed in the VM. Then we call <code>run()</code>, an
internal helper function that actually runs the bytecode instructions. Between
those two parts is an intriguing line. What is this <code>ip</code> business?</p>
<p>As the VM works its way through the bytecode, it keeps track of where it is<span class="em">&mdash;</span>the location of the instruction currently being executed. We don&rsquo;t use a <span
name="local">local</span> variable inside <code>run()</code> for this because eventually
other functions will need to access it. Instead, we store it as a field in VM.</p>
<aside name="local">
<p>If we were trying to squeeze every ounce of speed out of our bytecode
interpreter, we would store <code>ip</code> in a local variable. It gets modified so often
during execution that we want the C compiler to keep it in a register.</p>
</aside>
<div class="codehilite"><pre class="insert-before">typedef struct {
  Chunk* chunk;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">uint8_t</span>* <span class="i">ip</span>;
</pre><pre class="insert-after">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>Its type is a byte pointer. We use an actual real C pointer pointing right into
the middle of the bytecode array instead of something like an integer index
because it&rsquo;s faster to dereference a pointer than look up an element in an array
by index.</p>
<p>The name &ldquo;IP&rdquo; is traditional, and<span class="em">&mdash;</span>unlike many traditional names in CS<span class="em">&mdash;</span>actually makes sense: it&rsquo;s an <strong><a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a></strong>. Almost every
instruction set in the <span name="ip">world</span>, real and virtual, has a
register or variable like this.</p>
<aside name="ip">
<p>x86, x64, and the CLR call it &ldquo;IP&rdquo;. 68k, PowerPC, ARM, p-code, and the JVM call
it &ldquo;PC&rdquo;, for <strong>program counter</strong>.</p>
</aside>
<p>We initialize <code>ip</code> by pointing it at the first byte of code in the chunk. We
haven&rsquo;t executed that instruction yet, so <code>ip</code> points to the instruction <em>about
to be executed</em>. This will be true during the entire time the VM is running: the
IP always points to the next instruction, not the one currently being handled.</p>
<p>The real fun happens in <code>run</code>().</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>freeVM</em>()</div>
<pre><span class="k">static</span> <span class="t">InterpretResult</span> <span class="i">run</span>() {
<span class="a">#define READ_BYTE() (*vm.ip++)</span>

  <span class="k">for</span> (;;) {
    <span class="t">uint8_t</span> <span class="i">instruction</span>;
    <span class="k">switch</span> (<span class="i">instruction</span> = <span class="a">READ_BYTE</span>()) {
      <span class="k">case</span> <span class="a">OP_RETURN</span>: {
        <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
      }
    }
  }

<span class="a">#undef READ_BYTE</span>
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>

<p>This is the single most <span name="important">important</span> function in all
of clox, by far. When the interpreter executes a user&rsquo;s program, it will spend
something like 90% of its time inside <code>run()</code>. It is the beating heart of the
VM.</p>
<aside name="important">
<p>Or, at least, it <em>will</em> be in a few chapters when it has enough content to be
useful. Right now, it&rsquo;s not exactly a wonder of software wizardry.</p>
</aside>
<p>Despite that dramatic intro, it&rsquo;s conceptually pretty simple. We have an outer
loop that goes and goes. Each turn through that loop, we read and execute a
single bytecode instruction.</p>
<p>To process an instruction, we first figure out what kind of instruction we&rsquo;re
dealing with. The <code>READ_BYTE</code> macro reads the byte currently pointed at by <code>ip</code>
and then <span name="next">advances</span> the instruction pointer. The first
byte of any instruction is the opcode. Given a numeric opcode, we need to get to
the right C code that implements that instruction&rsquo;s semantics. This process is
called <strong>decoding</strong> or <strong>dispatching</strong> the instruction.</p>
<aside name="next">
<p>Note that <code>ip</code> advances as soon as we read the opcode, before we&rsquo;ve actually
started executing the instruction. So, again, <code>ip</code> points to the <em>next</em>
byte of code to be used.</p>
</aside>
<p>We do that process for every single instruction, every single time one is
executed, so this is the most performance critical part of the entire virtual
machine. Programming language lore is filled with <span
name="dispatch">clever</span> techniques to do bytecode dispatch efficiently,
going all the way back to the early days of computers.</p>
<aside name="dispatch">
<p>If you want to learn some of these techniques, look up &ldquo;direct threaded code&rdquo;,
&ldquo;jump table&rdquo;, and &ldquo;computed goto&rdquo;.</p>
</aside>
<p>Alas, the fastest solutions require either non-standard extensions to C, or
handwritten assembly code. For clox, we&rsquo;ll keep it simple. Just like our
disassembler, we have a single giant <code>switch</code> statement with a case for each
opcode. The body of each case implements that opcode&rsquo;s behavior.</p>
<p>So far, we handle only a single instruction, <code>OP_RETURN</code>, and the only thing it
does is exit the loop entirely. Eventually, that instruction will be used to
return from the current Lox function, but we don&rsquo;t have functions yet, so we&rsquo;ll
repurpose it temporarily to end the execution.</p>
<p>Let&rsquo;s go ahead and support our one other instruction.</p>
<div class="codehilite"><pre class="insert-before">    switch (instruction = READ_BYTE()) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_CONSTANT</span>: {
        <span class="t">Value</span> <span class="i">constant</span> = <span class="a">READ_CONSTANT</span>();
        <span class="i">printValue</span>(<span class="i">constant</span>);
        <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We don&rsquo;t have enough machinery in place yet to do anything useful with a
constant. For now, we&rsquo;ll just print it out so we interpreter hackers can see
what&rsquo;s going on inside our VM. That call to <code>printf()</code> necessitates an include.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add to top of file</div>
<pre class="insert"><span class="a">#include &lt;stdio.h&gt;</span>

</pre><pre class="insert-after">#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add to top of file</div>

<p>We also have a new macro to define.</p>
<div class="codehilite"><pre class="insert-before">#define READ_BYTE() (*vm.ip++)
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])</span>
</pre><pre class="insert-after">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p><code>READ_CONSTANT()</code> reads the next byte from the bytecode, treats the resulting
number as an index, and looks up the corresponding Value in the chunk&rsquo;s constant
table. In later chapters, we&rsquo;ll add a few more instructions with operands that
refer to constants, so we&rsquo;re setting up this helper macro now.</p>
<p>Like the previous <code>READ_BYTE</code> macro, <code>READ_CONSTANT</code> is only used inside
<code>run()</code>. To make that scoping more explicit, the macro definitions themselves
are confined to that function. We <span name="macro">define</span> them at the
beginning and<span class="em">&mdash;</span>because we care<span class="em">&mdash;</span>undefine them at the end.</p>
<div class="codehilite"><pre class="insert-before">#undef READ_BYTE
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#undef READ_CONSTANT</span>
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<aside name="macro">
<p>Undefining these macros explicitly might seem needlessly fastidious, but C tends
to punish sloppy users, and the C preprocessor doubly so.</p>
</aside>
<h3><a href="#execution-tracing" id="execution-tracing"><small>15&#8202;.&#8202;1&#8202;.&#8202;2</small>Execution tracing</a></h3>
<p>If you run clox now, it executes the chunk we hand-authored in the last chapter
and spits out <code>1.2</code> to your terminal. We can see that it&rsquo;s working, but that&rsquo;s
only because our implementation of <code>OP_CONSTANT</code> has temporary code to log the
value. Once that instruction is doing what it&rsquo;s supposed to do and plumbing that
constant along to other operations that want to consume it, the VM will become a
black box. That makes our lives as VM implementers harder.</p>
<p>To help ourselves out, now is a good time to add some diagnostic logging to the
VM like we did with chunks themselves. In fact, we&rsquo;ll even reuse the same code.
We don&rsquo;t want this logging enabled all the time<span class="em">&mdash;</span>it&rsquo;s just for us VM hackers,
not Lox users<span class="em">&mdash;</span>so first we create a flag to hide it behind.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdint.h&gt;
</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert">

<span class="a">#define DEBUG_TRACE_EXECUTION</span>
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>When this flag is defined, the VM disassembles and prints each instruction right
before executing it. Where our previous disassembler walked an entire chunk
once, statically, this disassembles instructions dynamically, on the fly.</p>
<div class="codehilite"><pre class="insert-before">  for (;;) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#ifdef DEBUG_TRACE_EXECUTION</span>
    <span class="i">disassembleInstruction</span>(<span class="i">vm</span>.<span class="i">chunk</span>,
                           (<span class="t">int</span>)(<span class="i">vm</span>.<span class="i">ip</span> - <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>));
<span class="a">#endif</span>

</pre><pre class="insert-after">    uint8_t instruction;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Since <code>disassembleInstruction()</code> takes an integer byte <em>offset</em> and we store the
current instruction reference as a direct pointer, we first do a little pointer
math to convert <code>ip</code> back to a relative offset from the beginning of the
bytecode. Then we disassemble the instruction that begins at that byte.</p>
<p>As ever, we need to bring in the declaration of the function before we can call
it.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert"><span class="a">#include &quot;debug.h&quot;</span>
</pre><pre class="insert-after">#include &quot;vm.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>

<p>I know this code isn&rsquo;t super impressive so far<span class="em">&mdash;</span>it&rsquo;s literally a switch
statement wrapped in a <code>for</code> loop but, believe it or not, this is one of the two
major components of our VM. With this, we can imperatively execute instructions.
Its simplicity is a virtue<span class="em">&mdash;</span>the less work it does, the faster it can do it.
Contrast this with all of the complexity and overhead we had in jlox with the
Visitor pattern for walking the AST.</p>
<h2><a href="#a-value-stack-manipulator" id="a-value-stack-manipulator"><small>15&#8202;.&#8202;2</small>A Value Stack Manipulator</a></h2>
<p>In addition to imperative side effects, Lox has expressions that produce,
modify, and consume values. Thus, our compiled bytecode needs a way to shuttle
values around between the different instructions that need them. For example:</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="n">3</span> - <span class="n">2</span>;
</pre></div>
<p>We obviously need instructions for the constants 3 and 2, the <code>print</code> statement,
and the subtraction. But how does the subtraction instruction know that 3 is
the <span name="word">minuend</span> and 2 is the subtrahend? How does the print
instruction know to print the result of that?</p>
<aside name="word">
<p>Yes, I did have to look up &ldquo;subtrahend&rdquo; and &ldquo;minuend&rdquo; in a dictionary. But
aren&rsquo;t they delightful words? &ldquo;Minuend&rdquo; sounds like a kind of Elizabethan dance
and &ldquo;subtrahend&rdquo; might be some sort of underground Paleolithic monument.</p>
</aside>
<p>To put a finer point on it, look at this thing right here:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">echo</span>(<span class="i">n</span>) {
  <span class="k">print</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">n</span>;
}

<span class="k">print</span> <span class="i">echo</span>(<span class="i">echo</span>(<span class="n">1</span>) + <span class="i">echo</span>(<span class="n">2</span>)) + <span class="i">echo</span>(<span class="i">echo</span>(<span class="n">4</span>) + <span class="i">echo</span>(<span class="n">5</span>));
</pre></div>
<p>I wrapped each subexpression in a call to <code>echo()</code> that prints and returns its
argument. That side effect means we can see the exact order of operations.</p>
<p>Don&rsquo;t worry about the VM for a minute. Think about just the semantics of Lox
itself. The operands to an arithmetic operator obviously need to be evaluated
before we can perform the operation itself. (It&rsquo;s pretty hard to add <code>a + b</code> if
you don&rsquo;t know what <code>a</code> and <code>b</code> are.) Also, when we implemented expressions in
jlox, we <span name="undefined">decided</span> that the left operand must be
evaluated before the right.</p>
<aside name="undefined">
<p>We could have left evaluation order unspecified and let each implementation
decide. That leaves the door open for optimizing compilers to reorder arithmetic
expressions for efficiency, even in cases where the operands have visible side
effects. C and Scheme leave evaluation order unspecified. Java specifies
left-to-right evaluation like we do for Lox.</p>
<p>I think nailing down stuff like this is generally better for users. When
expressions are not evaluated in the order users intuit<span class="em">&mdash;</span>possibly in different
orders across different implementations!<span class="em">&mdash;</span>it can be a burning hellscape of
pain to figure out what&rsquo;s going on.</p>
</aside>
<p>Here is the syntax tree for the <code>print</code> statement:</p>
<p><img src="image/a-virtual-machine/ast.png" alt="The AST for the example
statement, with numbers marking the order that the nodes are evaluated." /></p>
<p>Given left-to-right evaluation, and the way the expressions are nested, any
correct Lox implementation <em>must</em> print these numbers in this order:</p>
<div class="codehilite"><pre>1  // from echo(1)
2  // from echo(2)
3  // from echo(1 + 2)
4  // from echo(4)
5  // from echo(5)
9  // from echo(4 + 5)
12 // from print 3 + 9
</pre></div>
<p>Our old jlox interpreter accomplishes this by recursively traversing the AST. It
does a postorder traversal. First it recurses down the left operand branch,
then the right operand, then finally it evaluates the node itself.</p>
<p>After evaluating the left operand, jlox needs to store that result somewhere
temporarily while it&rsquo;s busy traversing down through the right operand tree. We
use a local variable in Java for that. Our recursive tree-walk interpreter
creates a unique Java call frame for each node being evaluated, so we could have
as many of these local variables as we needed.</p>
<p>In clox, our <code>run()</code> function is not recursive<span class="em">&mdash;</span>the nested expression tree is
flattened out into a linear series of instructions. We don&rsquo;t have the luxury of
using C local variables, so how and where should we store these temporary
values? You can probably <span name="guess">guess</span> already, but I want to
really drill into this because it&rsquo;s an aspect of programming that we take for
granted, but we rarely learn <em>why</em> computers are architected this way.</p>
<aside name="guess">
<p>Hint: it&rsquo;s in the name of this section, and it&rsquo;s how Java and C manage recursive
calls to functions.</p>
</aside>
<p>Let&rsquo;s do a weird exercise. We&rsquo;ll walk through the execution of the above program
a step at a time:</p>
<p><img src="image/a-virtual-machine/bars.png" alt="The series of instructions with
bars showing which numbers need to be preserved across which instructions." /></p>
<p>On the left are the steps of code. On the right are the values we&rsquo;re tracking.
Each bar represents a number. It starts when the value is first produced<span class="em">&mdash;</span>either a constant or the result of an addition. The length of the bar tracks
when a previously produced value needs to be kept around, and it ends when that
value finally gets consumed by an operation.</p>
<p>As you step through, you see values appear and then later get eaten. The
longest-lived ones are the values produced from the left-hand side of an
addition. Those stick around while we work through the right-hand operand
expression.</p>
<p>In the above diagram, I gave each unique number its own visual column. Let&rsquo;s be
a little more parsimonious. Once a number is consumed, we allow its column to be
reused for another later value. In other words, we take all of those gaps
up there and fill them in, pushing in numbers from the right:</p>
<p><img src="image/a-virtual-machine/bars-stacked.png" alt="Like the previous
diagram, but with number bars pushed to the left, forming a stack." /></p>
<p>There&rsquo;s some interesting stuff going on here. When we shift everything over,
each number still manages to stay in a single column for its entire life. Also,
there are no gaps left. In other words, whenever a number appears earlier than
another, then it will live at least as long as that second one. The first number
to appear is the last to be consumed. Hmm<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>last-in, first-out<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>why, that&rsquo;s a
<span name="pancakes">stack</span>!</p>
<aside name="pancakes">
<p>This is also a stack:</p><img src="image/a-virtual-machine/pancakes.png" alt="A stack... of pancakes." />
</aside>
<p>In the second diagram, each time we introduce a number, we push it onto the
stack from the right. When numbers are consumed, they are always popped off from
rightmost to left.</p>
<p>Since the temporary values we need to track naturally have stack-like behavior,
our VM will use a stack to manage them. When an instruction &ldquo;produces&rdquo; a value,
it pushes it onto the stack. When it needs to consume one or more values, it
gets them by popping them off the stack.</p>
<h3><a href="#the-vms-stack" id="the-vms-stack"><small>15&#8202;.&#8202;2&#8202;.&#8202;1</small>The VM&rsquo;s Stack</a></h3>
<p>Maybe this doesn&rsquo;t seem like a revelation, but I <em>love</em> stack-based VMs. When
you first see a magic trick, it feels like something actually magical. But then
you learn how it works<span class="em">&mdash;</span>usually some mechanical gimmick or misdirection<span class="em">&mdash;</span>and
the sense of wonder evaporates. There are a <span name="wonder">couple</span> of
ideas in computer science where even after I pulled them apart and learned all
the ins and outs, some of the initial sparkle remained. Stack-based VMs are one
of those.</p>
<aside name="wonder">
<p>Heaps<span class="em">&mdash;</span><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">the data structure</a>, not <a href="https://en.wikipedia.org/wiki/Memory_management#HEAP">the memory management thing</a><span class="em">&mdash;</span>are another. And Vaughan Pratt&rsquo;s top-down operator precedence parsing scheme,
which we&rsquo;ll learn about <a href="compiling-expressions.html">in due time</a>.</p>
</aside>
<p>As you&rsquo;ll see in this chapter, executing instructions in a stack-based VM is
dead <span name="cheat">simple</span>. In later chapters, you&rsquo;ll also discover
that compiling a source language to a stack-based instruction set is a piece of
cake. And yet, this architecture is fast enough to be used by production
language implementations. It almost feels like cheating at the programming
language game.</p>
<aside name="cheat">
<p>To take a bit of the sheen off: stack-based interpreters aren&rsquo;t a silver bullet.
They&rsquo;re often <em>adequate</em>, but modern implementations of the JVM, the CLR, and
JavaScript all use sophisticated <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">just-in-time compilation</a> pipelines to
generate <em>much</em> faster native code on the fly.</p>
</aside>
<p>Alrighty, it&rsquo;s codin&rsquo; time! Here&rsquo;s the stack:</p>
<div class="codehilite"><pre class="insert-before">typedef struct {
  Chunk* chunk;
  uint8_t* ip;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">Value</span> <span class="i">stack</span>[<span class="a">STACK_MAX</span>];
  <span class="t">Value</span>* <span class="i">stackTop</span>;
</pre><pre class="insert-after">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>We implement the stack semantics ourselves on top of a raw C array. The bottom
of the stack<span class="em">&mdash;</span>the first value pushed and the last to be popped<span class="em">&mdash;</span>is at
element zero in the array, and later pushed values follow it. If we push the
letters of &ldquo;crepe&rdquo;<span class="em">&mdash;</span>my favorite stackable breakfast item<span class="em">&mdash;</span>onto the stack, in
order, the resulting C array looks like this:</p>
<p><img src="image/a-virtual-machine/array.png" alt="An array containing the
letters in 'crepe' in order starting at element 0." /></p>
<p>Since the stack grows and shrinks as values are pushed and popped, we need to
track where the top of the stack is in the array. As with <code>ip</code>, we use a direct
pointer instead of an integer index since it&rsquo;s faster to dereference the pointer
than calculate the offset from the index each time we need it.</p>
<p>The pointer points at the array element just <em>past</em> the element containing the
top value on the stack. That seems a little odd, but almost every implementation
does this. It means we can indicate that the stack is empty by pointing at
element zero in the array.</p>
<p><img src="image/a-virtual-machine/stack-empty.png" alt="An empty array with
stackTop pointing at the first element." /></p>
<p>If we pointed to the top element, then for an empty stack we&rsquo;d need to point at
element -1. That&rsquo;s <span name="defined">undefined</span> in C. As we push values
onto the stack<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<aside name="defined">
<p>What about when the stack is <em>full</em>, you ask, Clever Reader? The C standard is
one step ahead of you. It <em>is</em> allowed and well-specified to have an array
pointer that points just past the end of an array.</p>
</aside>
<p><img src="image/a-virtual-machine/stack-c.png" alt="An array with 'c' at element
zero." /></p>
<p><span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span><code>stackTop</code> always points just past the last item.</p>
<p><img src="image/a-virtual-machine/stack-crepe.png" alt="An array with 'c', 'r',
'e', 'p', and 'e' in the first five elements." /></p>
<p>I remember it like this: <code>stackTop</code> points to where the next value to be pushed
will go. The maximum number of values we can store on the stack (for now, at
least) is:</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert">

<span class="a">#define STACK_MAX 256</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>

<p>Giving our VM a fixed stack size means it&rsquo;s possible for some sequence of
instructions to push too many values and run out of stack space<span class="em">&mdash;</span>the classic
&ldquo;stack overflow&rdquo;. We could grow the stack dynamically as needed, but for now
we&rsquo;ll keep it simple. Since VM uses Value, we need to include its declaration.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert"><span class="a">#include &quot;value.h&quot;</span>
</pre><pre class="insert-after">

#define STACK_MAX 256
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>

<p>Now that VM has some interesting state, we get to initialize it.</p>
<div class="codehilite"><pre class="insert-before">void initVM() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">  <span class="i">resetStack</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>That uses this helper function:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after variable <em>vm</em></div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">resetStack</span>() {
  <span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">vm</span>.<span class="i">stack</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after variable <em>vm</em></div>

<p>Since the stack array is declared directly inline in the VM struct, we don&rsquo;t
need to allocate it. We don&rsquo;t even need to clear the unused cells in the
array<span class="em">&mdash;</span>we simply won&rsquo;t access them until after values have been stored in
them. The only initialization we need is to set <code>stackTop</code> to point to the
beginning of the array to indicate that the stack is empty.</p>
<p>The stack protocol supports two operations:</p>
<div class="codehilite"><pre class="insert-before">InterpretResult interpret(Chunk* chunk);
</pre><div class="source-file"><em>vm.h</em><br>
add after <em>interpret</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">push</span>(<span class="t">Value</span> <span class="i">value</span>);
<span class="t">Value</span> <span class="i">pop</span>();
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after <em>interpret</em>()</div>

<p>You can push a new value onto the top of the stack, and you can pop the most
recently pushed value back off. Here&rsquo;s the first function:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>freeVM</em>()</div>
<pre><span class="t">void</span> <span class="i">push</span>(<span class="t">Value</span> <span class="i">value</span>) {
  *<span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">value</span>;
  <span class="i">vm</span>.<span class="i">stackTop</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>

<p>If you&rsquo;re rusty on your C pointer syntax and operations, this is a good warm-up.
The first line stores <code>value</code> in the array element at the top of the stack.
Remember, <code>stackTop</code> points just <em>past</em> the last used element, at the next
available one. This stores the value in that slot. Then we increment the pointer
itself to point to the next unused slot in the array now that the previous slot
is occupied.</p>
<p>Popping is the mirror image.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>push</em>()</div>
<pre><span class="t">Value</span> <span class="i">pop</span>() {
  <span class="i">vm</span>.<span class="i">stackTop</span>--;
  <span class="k">return</span> *<span class="i">vm</span>.<span class="i">stackTop</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>push</em>()</div>

<p>First, we move the stack pointer <em>back</em> to get to the most recent used slot in
the array. Then we look up the value at that index and return it. We don&rsquo;t need
to explicitly &ldquo;remove&rdquo; it from the array<span class="em">&mdash;</span>moving <code>stackTop</code> down is enough to
mark that slot as no longer in use.</p>
<h3><a href="#stack-tracing" id="stack-tracing"><small>15&#8202;.&#8202;2&#8202;.&#8202;2</small>Stack tracing</a></h3>
<p>We have a working stack, but it&rsquo;s hard to <em>see</em> that it&rsquo;s working. When we start
implementing more complex instructions and compiling and running larger pieces
of code, we&rsquo;ll end up with a lot of values crammed into that array. It would
make our lives as VM hackers easier if we had some visibility into the stack.</p>
<p>To that end, whenever we&rsquo;re tracing execution, we&rsquo;ll also show the current
contents of the stack before we interpret each instruction.</p>
<div class="codehilite"><pre class="insert-before">#ifdef DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">    <span class="i">printf</span>(<span class="s">&quot;          &quot;</span>);
    <span class="k">for</span> (<span class="t">Value</span>* <span class="i">slot</span> = <span class="i">vm</span>.<span class="i">stack</span>; <span class="i">slot</span> &lt; <span class="i">vm</span>.<span class="i">stackTop</span>; <span class="i">slot</span>++) {
      <span class="i">printf</span>(<span class="s">&quot;[ &quot;</span>);
      <span class="i">printValue</span>(*<span class="i">slot</span>);
      <span class="i">printf</span>(<span class="s">&quot; ]&quot;</span>);
    }
    <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
</pre><pre class="insert-after">    disassembleInstruction(vm.chunk,
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We loop, printing each value in the array, starting at the first (bottom of the
stack) and ending when we reach the top. This lets us observe the effect of each
instruction on the stack. The output is pretty verbose, but it&rsquo;s useful when
we&rsquo;re surgically extracting a nasty bug from the bowels of the interpreter.</p>
<p>Stack in hand, let&rsquo;s revisit our two instructions. First up:</p>
<div class="codehilite"><pre class="insert-before">      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">        <span class="i">push</span>(<span class="i">constant</span>);
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>In the last chapter, I was hand-wavey about how the <code>OP_CONSTANT</code> instruction
&ldquo;loads&rdquo; a constant. Now that we have a stack you know what it means to actually
produce a value: it gets pushed onto the stack.</p>
<div class="codehilite"><pre class="insert-before">      case OP_RETURN: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="i">printValue</span>(<span class="i">pop</span>());
        <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
</pre><pre class="insert-after">        return INTERPRET_OK;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Then we make <code>OP_RETURN</code> pop the stack and print the top value before exiting.
When we add support for real functions to clox, we&rsquo;ll change this code. But, for
now, it gives us a way to get the VM executing simple instruction sequences and
displaying the result.</p>
<h2><a href="#an-arithmetic-calculator" id="an-arithmetic-calculator"><small>15&#8202;.&#8202;3</small>An Arithmetic Calculator</a></h2>
<p>The heart and soul of our VM are in place now. The bytecode loop dispatches and
executes instructions. The stack grows and shrinks as values flow through it.
The two halves work, but it&rsquo;s hard to get a feel for how cleverly they interact
with only the two rudimentary instructions we have so far. So let&rsquo;s teach our
interpreter to do arithmetic.</p>
<p>We&rsquo;ll start with the simplest arithmetic operation, unary negation.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">1.2</span>;
<span class="k">print</span> -<span class="i">a</span>; <span class="c">// -1.2.</span>
</pre></div>
<p>The prefix <code>-</code> operator takes one operand, the value to negate. It produces a
single result. We aren&rsquo;t fussing with a parser yet, but we can add the
bytecode instruction that the above syntax will compile to.</p>
<div class="codehilite"><pre class="insert-before">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_NEGATE</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>We execute it like so:</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NEGATE</span>:   <span class="i">push</span>(-<span class="i">pop</span>()); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>The instruction needs a value to operate on, which it gets by popping from the
stack. It negates that, then pushes the result back on for later instructions to
use. Doesn&rsquo;t get much easier than that. We can disassemble it too.</p>
<div class="codehilite"><pre class="insert-before">    case OP_CONSTANT:
      return constantInstruction(&quot;OP_CONSTANT&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_NEGATE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_NEGATE&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>And we can try it out in our test chunk.</p>
<div class="codehilite"><pre class="insert-before">  writeChunk(&amp;chunk, constant, 123);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_NEGATE</span>, <span class="n">123</span>);
</pre><pre class="insert-after">

  writeChunk(&amp;chunk, OP_RETURN, 123);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>After loading the constant, but before returning, we execute the negate
instruction. That replaces the constant on the stack with its negation. Then the
return instruction prints that out:</p>
<div class="codehilite"><pre>-1.2
</pre></div>
<p>Magical!</p>
<h3><a href="#binary-operators" id="binary-operators"><small>15&#8202;.&#8202;3&#8202;.&#8202;1</small>Binary operators</a></h3>
<p>OK, unary operators aren&rsquo;t <em>that</em> impressive. We still only ever have a single
value on the stack. To really see some depth, we need binary operators. Lox has
four binary <span name="ops">arithmetic</span> operators: addition, subtraction,
multiplication, and division. We&rsquo;ll go ahead and implement them all at the same
time.</p>
<aside name="ops">
<p>Lox has some other binary operators<span class="em">&mdash;</span>comparison and equality<span class="em">&mdash;</span>but those
don&rsquo;t produce numbers as a result, so we aren&rsquo;t ready for them yet.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_ADD</span>,
  <span class="a">OP_SUBTRACT</span>,
  <span class="a">OP_MULTIPLY</span>,
  <span class="a">OP_DIVIDE</span>,
</pre><pre class="insert-after">  OP_NEGATE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Back in the bytecode loop, they are executed like this:</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_ADD</span>:      <span class="a">BINARY_OP</span>(+); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_SUBTRACT</span>: <span class="a">BINARY_OP</span>(-); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_MULTIPLY</span>: <span class="a">BINARY_OP</span>(*); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_DIVIDE</span>:   <span class="a">BINARY_OP</span>(/); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_NEGATE:   push(-pop()); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>The only difference between these four instructions is which underlying C
operator they ultimately use to combine the two operands. Surrounding that core
arithmetic expression is some boilerplate code to pull values off the stack and
push the result. When we later add dynamic typing, that boilerplate will grow.
To avoid repeating that code four times, I wrapped it up in a macro.</p>
<div class="codehilite"><pre class="insert-before">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#define BINARY_OP(op) \</span>
<span class="a">    do { \</span>
<span class="a">      double b = pop(); \</span>
<span class="a">      double a = pop(); \</span>
<span class="a">      push(a op b); \</span>
<span class="a">    } while (false)</span>
</pre><pre class="insert-after">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>I admit this is a fairly <span name="operator">adventurous</span> use of the C
preprocessor. I hesitated to do this, but you&rsquo;ll be glad in later chapters when
we need to add the type checking for each operand and stuff. It would be a chore
to walk you through the same code four times.</p>
<aside name="operator">
<p>Did you even know you can pass an <em>operator</em> as an argument to a macro? Now you
do. The preprocessor doesn&rsquo;t care that operators aren&rsquo;t first class in C. As far
as it&rsquo;s concerned, it&rsquo;s all just text tokens.</p>
<p>I know, you can just <em>feel</em> the temptation to abuse this, can&rsquo;t you?</p>
</aside>
<p>If you aren&rsquo;t familiar with the trick already, that outer <code>do while</code> loop
probably looks really weird. This macro needs to expand to a series of
statements. To be careful macro authors, we want to ensure those statements all
end up in the same scope when the macro is expanded. Imagine if you defined:</p>
<div class="codehilite"><pre><span class="a">#define WAKE_UP() makeCoffee(); drinkCoffee();</span>
</pre></div>
<p>And then used it like:</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">morning</span>) <span class="a">WAKE_UP</span>();
</pre></div>
<p>The intent is to execute both statements of the macro body only if <code>morning</code> is
true. But it expands to:</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">morning</span>) <span class="i">makeCoffee</span>(); <span class="i">drinkCoffee</span>();;
</pre></div>
<p>Oops. The <code>if</code> attaches only to the <em>first</em> statement. You might think you could
fix this using a block.</p>
<div class="codehilite"><pre><span class="a">#define WAKE_UP() { makeCoffee(); drinkCoffee(); }</span>
</pre></div>
<p>That&rsquo;s better, but you still risk:</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">morning</span>)
  <span class="a">WAKE_UP</span>();
<span class="k">else</span>
  <span class="i">sleepIn</span>();
</pre></div>
<p>Now you get a compile error on the <code>else</code> because of that trailing <code>;</code> after the
macro&rsquo;s block. Using a <code>do while</code> loop in the macro looks funny, but it gives
you a way to contain multiple statements inside a block that <em>also</em> permits a
semicolon at the end.</p>
<p>Where were we? Right, so what the body of that macro does is straightforward. A
binary operator takes two operands, so it pops twice. It performs the operation
on those two values and then pushes the result.</p>
<p>Pay close attention to the <em>order</em> of the two pops. Note that we assign the
first popped operand to <code>b</code>, not <code>a</code>. It looks backwards. When the operands
themselves are calculated, the left is evaluated first, then the right. That
means the left operand gets pushed before the right operand. So the right
operand will be on top of the stack. Thus, the first value we pop is <code>b</code>.</p>
<p>For example, if we compile <code>3 - 1</code>, the data flow between the instructions looks
like so:</p>
<p><img src="image/a-virtual-machine/reverse.png" alt="A sequence of instructions
with the stack for each showing how pushing and then popping values reverses
their order." /></p>
<p>As we did with the other macros inside <code>run()</code>, we clean up after ourselves at
the end of the function.</p>
<div class="codehilite"><pre class="insert-before">#undef READ_CONSTANT
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#undef BINARY_OP</span>
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Last is disassembler support.</p>
<div class="codehilite"><pre class="insert-before">    case OP_CONSTANT:
      return constantInstruction(&quot;OP_CONSTANT&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_ADD</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_ADD&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SUBTRACT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_SUBTRACT&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_MULTIPLY</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_MULTIPLY&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_DIVIDE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_DIVIDE&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>The arithmetic instruction formats are simple, like <code>OP_RETURN</code>. Even though the
arithmetic <em>operators</em> take operands<span class="em">&mdash;</span>which are found on the stack<span class="em">&mdash;</span>the
arithmetic <em>bytecode instructions</em> do not.</p>
<p>Let&rsquo;s put some of our new instructions through their paces by evaluating a
larger expression:</p>
<p><img src="image/a-virtual-machine/chunk.png" alt="The expression being
evaluated: -((1.2 + 3.4) / 5.6)" /></p>
<p>Building on our existing example chunk, here&rsquo;s the additional instructions we
need to hand-compile that AST to bytecode.</p>
<div class="codehilite"><pre class="insert-before">  int constant = addConstant(&amp;chunk, 1.2);
  writeChunk(&amp;chunk, OP_CONSTANT, 123);
  writeChunk(&amp;chunk, constant, 123);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">

  <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">3.4</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_ADD</span>, <span class="n">123</span>);

  <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">5.6</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_DIVIDE</span>, <span class="n">123</span>);
</pre><pre class="insert-after">  writeChunk(&amp;chunk, OP_NEGATE, 123);

  writeChunk(&amp;chunk, OP_RETURN, 123);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>The addition goes first. The instruction for the left constant, 1.2, is already
there, so we add another for 3.4. Then we add those two using <code>OP_ADD</code>, leaving
it on the stack. That covers the left side of the division. Next we push the
5.6, and divide the result of the addition by it. Finally, we negate the result
of that.</p>
<p>Note how the output of the <code>OP_ADD</code> implicitly flows into being an operand of
<code>OP_DIVIDE</code> without either instruction being directly coupled to each other.
That&rsquo;s the magic of the stack. It lets us freely compose instructions without
them needing any complexity or awareness of the data flow. The stack acts like a
shared workspace that they all read from and write to.</p>
<p>In this tiny example chunk, the stack still only gets two values tall, but when
we start compiling Lox source to bytecode, we&rsquo;ll have chunks that use much more
of the stack. In the meantime, try playing around with this hand-authored chunk
to calculate different nested arithmetic expressions and see how values flow
through the instructions and stack.</p>
<p>You may as well get it out of your system now. This is the last chunk we&rsquo;ll
build by hand. When we next revisit bytecode, we will be writing a compiler to
generate it for us.</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>What bytecode instruction sequences would you generate for the following
expressions:</p>
<div class="codehilite"><pre><span class="n">1</span> * <span class="n">2</span> + <span class="n">3</span>
<span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span>
<span class="n">3</span> - <span class="n">2</span> - <span class="n">1</span>
<span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span> - <span class="n">4</span> / -<span class="n">5</span>
</pre></div>
<p>(Remember that Lox does not have a syntax for negative number literals, so
the <code>-5</code> is negating the number 5.)</p>
</li>
<li>
<p>If we really wanted a minimal instruction set, we could eliminate either
<code>OP_NEGATE</code> or <code>OP_SUBTRACT</code>. Show the bytecode instruction sequence you
would generate for:</p>
<div class="codehilite"><pre><span class="n">4</span> - <span class="n">3</span> * -<span class="n">2</span>
</pre></div>
<p>First, without using <code>OP_NEGATE</code>. Then, without using <code>OP_SUBTRACT</code>.</p>
<p>Given the above, do you think it makes sense to have both instructions? Why
or why not? Are there any other redundant instructions you would consider
including?</p>
</li>
<li>
<p>Our VM&rsquo;s stack has a fixed size, and we don&rsquo;t check if pushing a value
overflows it. This means the wrong series of instructions could cause our
interpreter to crash or go into undefined behavior. Avoid that by
dynamically growing the stack as needed.</p>
<p>What are the costs and benefits of doing so?</p>
</li>
<li>
<p>To interpret <code>OP_NEGATE</code>, we pop the operand, negate the value, and then
push the result. That&rsquo;s a simple implementation, but it increments and
decrements <code>stackTop</code> unnecessarily, since the stack ends up the same height
in the end. It might be faster to simply negate the value in place on the
stack and leave <code>stackTop</code> alone. Try that and see if you can measure a
performance difference.</p>
<p>Are there other instructions where you can do a similar optimization?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: Register-Based Bytecode</a></h2>
<p>For the remainder of this book, we&rsquo;ll meticulously implement an interpreter
around a stack-based bytecode instruction set. There&rsquo;s another family of
bytecode architectures out there<span class="em">&mdash;</span><em>register-based</em>. Despite the name, these
bytecode instructions aren&rsquo;t quite as difficult to work with as the registers in
an actual chip like <span name="x64">x64</span>. With real hardware registers,
you usually have only a handful for the entire program, so you spend a lot of
effort <a href="https://en.wikipedia.org/wiki/Register_allocation">trying to use them efficiently and shuttling stuff in and out of
them</a>.</p>
<aside name="x64">
<p>Register-based bytecode is a little closer to the <a href="https://en.wikipedia.org/wiki/Register_window"><em>register windows</em></a>
supported by SPARC chips.</p>
</aside>
<p>In a register-based VM, you still have a stack. Temporary values still get
pushed onto it and popped when no longer needed. The main difference is that
instructions can read their inputs from anywhere in the stack and can store
their outputs into specific stack slots.</p>
<p>Take this little Lox script:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
<span class="k">var</span> <span class="i">c</span> = <span class="i">a</span> + <span class="i">b</span>;
</pre></div>
<p>In our stack-based VM, the last statement will get compiled to something like:</p>
<div class="codehilite"><pre><span class="i">load</span> &lt;<span class="i">a</span>&gt;  <span class="c">// Read local variable a and push onto stack.</span>
<span class="i">load</span> &lt;<span class="i">b</span>&gt;  <span class="c">// Read local variable b and push onto stack.</span>
<span class="i">add</span>       <span class="c">// Pop two values, add, push result.</span>
<span class="i">store</span> &lt;<span class="i">c</span>&gt; <span class="c">// Pop value and store in local variable c.</span>
</pre></div>
<p>(Don&rsquo;t worry if you don&rsquo;t fully understand the load and store instructions yet.
We&rsquo;ll go over them in much greater detail <a href="global-variables.html">when we implement
variables</a>.) We have four separate instructions. That means four
times through the bytecode interpret loop, four instructions to decode and
dispatch. It&rsquo;s at least seven bytes of code<span class="em">&mdash;</span>four for the opcodes and another
three for the operands identifying which locals to load and store. Three pushes
and three pops. A lot of work!</p>
<p>In a register-based instruction set, instructions can read from and store
directly into local variables. The bytecode for the last statement above looks
like:</p>
<div class="codehilite"><pre><span class="i">add</span> &lt;<span class="i">a</span>&gt; &lt;<span class="i">b</span>&gt; &lt;<span class="i">c</span>&gt; <span class="c">// Read values from a and b, add, store in c.</span>
</pre></div>
<p>The add instruction is bigger<span class="em">&mdash;</span>it has three instruction operands that define
where in the stack it reads its inputs from and writes the result to. But since
local variables live on the stack, it can read directly from <code>a</code> and <code>b</code> and
then store the result right into <code>c</code>.</p>
<p>There&rsquo;s only a single instruction to decode and dispatch, and the whole thing
fits in four bytes. Decoding is more complex because of the additional operands,
but it&rsquo;s still a net win. There&rsquo;s no pushing and popping or other stack
manipulation.</p>
<p>The main implementation of Lua used to be stack-based. For <span name="lua">Lua
5.0</span>, the implementers switched to a register instruction set and noted a
speed improvement. The amount of improvement, naturally, depends heavily on the
details of the language semantics, specific instruction set, and compiler
sophistication, but that should get your attention.</p>
<aside name="lua">
<p>The Lua dev team<span class="em">&mdash;</span>Roberto Ierusalimschy, Waldemar Celes, and Luiz Henrique de
Figueiredo<span class="em">&mdash;</span>wrote a <em>fantastic</em> paper on this, one of my all time favorite
computer science papers, &ldquo;<a href="https://www.lua.org/doc/jucs05.pdf">The Implementation of Lua 5.0</a>&rdquo; (PDF).</p>
</aside>
<p>That raises the obvious question of why I&rsquo;m going to spend the rest of the book
doing a stack-based bytecode. Register VMs are neat, but they are quite a bit
harder to write a compiler for. For what is likely to be your very first
compiler, I wanted to stick with an instruction set that&rsquo;s easy to generate and
easy to execute. Stack-based bytecode is marvelously simple.</p>
<p>It&rsquo;s also <em>much</em> better known in the literature and the community. Even though
you may eventually move to something more advanced, it&rsquo;s a good common ground to
share with the rest of your language hacker peers.</p>
</div>

<footer>
<a href="scanning-on-demand.html" class="next">
  Next Chapter: &ldquo;Scanning on Demand&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Scanning on Demand &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Scanning on Demand<small>16</small></a></h3>

<ul>
    <li><a href="#spinning-up-the-interpreter"><small>16.1</small> Spinning Up the Interpreter</a></li>
    <li><a href="#a-token-at-a-time"><small>16.2</small> A Token at a Time</a></li>
    <li><a href="#a-lexical-grammar-for-lox"><small>16.3</small> A Lexical Grammar for Lox</a></li>
    <li><a href="#identifiers-and-keywords"><small>16.4</small> Identifiers and Keywords</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="a-virtual-machine.html" title="A Virtual Machine" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="compiling-expressions.html" title="Compiling Expressions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="a-virtual-machine.html" title="A Virtual Machine" class="prev">←</a>
<a href="compiling-expressions.html" title="Compiling Expressions" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Scanning on Demand<small>16</small></a></h3>

<ul>
    <li><a href="#spinning-up-the-interpreter"><small>16.1</small> Spinning Up the Interpreter</a></li>
    <li><a href="#a-token-at-a-time"><small>16.2</small> A Token at a Time</a></li>
    <li><a href="#a-lexical-grammar-for-lox"><small>16.3</small> A Lexical Grammar for Lox</a></li>
    <li><a href="#identifiers-and-keywords"><small>16.4</small> Identifiers and Keywords</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="a-virtual-machine.html" title="A Virtual Machine" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="compiling-expressions.html" title="Compiling Expressions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">16</div>
  <h1>Scanning on Demand</h1>

<blockquote>
<p>Literature is idiosyncratic arrangements in horizontal lines in only
twenty-six phonetic symbols, ten Arabic numbers, and about eight punctuation
marks.</p>
<p><cite>Kurt Vonnegut, <em>Like Shaking Hands With God: A Conversation about Writing</em></cite></p>
</blockquote>
<p>Our second interpreter, clox, has three phases<span class="em">&mdash;</span>scanner, compiler, and virtual
machine. A data structure joins each pair of phases. Tokens flow from scanner to
compiler, and chunks of bytecode from compiler to VM. We began our
implementation near the end with <a href="chunks-of-bytecode.html">chunks</a> and the <a href="a-virtual-machine.html">VM</a>. Now, we&rsquo;re going to
hop back to the beginning and build a scanner that makes tokens. In the
<a href="compiling-expressions.html">next chapter</a>, we&rsquo;ll tie the two ends together with our bytecode compiler.</p><img src="image/scanning-on-demand/pipeline.png" alt="Source code &rarr; scanner &rarr; tokens &rarr; compiler &rarr; bytecode chunk &rarr; VM." />
<p>I&rsquo;ll admit, this is not the most exciting chapter in the book. With two
implementations of the same language, there&rsquo;s bound to be some redundancy. I did
sneak in a few interesting differences compared to jlox&rsquo;s scanner. Read on to
see what they are.</p>
<h2><a href="#spinning-up-the-interpreter" id="spinning-up-the-interpreter"><small>16&#8202;.&#8202;1</small>Spinning Up the Interpreter</a></h2>
<p>Now that we&rsquo;re building the front end, we can get clox running like a real
interpreter. No more hand-authored chunks of bytecode. It&rsquo;s time for a REPL and
script loading. Tear out most of the code in <code>main()</code> and replace it with:</p>
<div class="codehilite"><pre class="insert-before">int main(int argc, const char* argv[]) {
  initVM();

</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()<br>
replace 26 lines</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">argc</span> == <span class="n">1</span>) {
    <span class="i">repl</span>();
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">argc</span> == <span class="n">2</span>) {
    <span class="i">runFile</span>(<span class="i">argv</span>[<span class="n">1</span>]);
  } <span class="k">else</span> {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;Usage: clox [path]</span><span class="e">\n</span><span class="s">&quot;</span>);
    <span class="i">exit</span>(<span class="n">64</span>);
  }

  <span class="i">freeVM</span>();
</pre><pre class="insert-after">  return 0;
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>(), replace 26 lines</div>

<p>If you pass <span name="args">no arguments</span> to the executable, you are
dropped into the REPL. A single command line argument is understood to be the
path to a script to run.</p>
<aside name="args">
<p>The code tests for one and two arguments, not zero and one, because the first
argument in <code>argv</code> is always the name of the executable being run.</p>
</aside>
<p>We&rsquo;ll need a few system headers, so let&rsquo;s get them all out of the way.</p>
<div class="codehilite"><div class="source-file"><em>main.c</em><br>
add to top of file</div>
<pre class="insert"><span class="a">#include &lt;stdio.h&gt;</span>
<span class="a">#include &lt;stdlib.h&gt;</span>
<span class="a">#include &lt;string.h&gt;</span>

</pre><pre class="insert-after">#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, add to top of file</div>

<p>Next, we get the REPL up and REPL-ing.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;vm.h&quot;
</pre><div class="source-file"><em>main.c</em></div>
<pre class="insert">

<span class="k">static</span> <span class="t">void</span> <span class="i">repl</span>() {
  <span class="t">char</span> <span class="i">line</span>[<span class="n">1024</span>];
  <span class="k">for</span> (;;) {
    <span class="i">printf</span>(<span class="s">&quot;&gt; &quot;</span>);

    <span class="k">if</span> (!<span class="i">fgets</span>(<span class="i">line</span>, <span class="k">sizeof</span>(<span class="i">line</span>), <span class="i">stdin</span>)) {
      <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
      <span class="k">break</span>;
    }

    <span class="i">interpret</span>(<span class="i">line</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>

<p>A quality REPL handles input that spans multiple lines gracefully and doesn&rsquo;t
have a hardcoded line length limit. This REPL here is a little more, ahem,
austere, but it&rsquo;s fine for our purposes.</p>
<p>The real work happens in <code>interpret()</code>. We&rsquo;ll get to that soon, but first let&rsquo;s
take care of loading scripts.</p>
<div class="codehilite"><div class="source-file"><em>main.c</em><br>
add after <em>repl</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">runFile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">path</span>) {
  <span class="t">char</span>* <span class="i">source</span> = <span class="i">readFile</span>(<span class="i">path</span>);
  <span class="t">InterpretResult</span> <span class="i">result</span> = <span class="i">interpret</span>(<span class="i">source</span>);
  <span class="i">free</span>(<span class="i">source</span>);<span name="owner"> </span>

  <span class="k">if</span> (<span class="i">result</span> == <span class="a">INTERPRET_COMPILE_ERROR</span>) <span class="i">exit</span>(<span class="n">65</span>);
  <span class="k">if</span> (<span class="i">result</span> == <span class="a">INTERPRET_RUNTIME_ERROR</span>) <span class="i">exit</span>(<span class="n">70</span>);
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, add after <em>repl</em>()</div>

<p>We read the file and execute the resulting string of Lox source code. Then,
based on the result of that, we set the exit code appropriately because we&rsquo;re
scrupulous tool builders and care about little details like that.</p>
<p>We also need to free the source code string because <code>readFile()</code> dynamically
allocates it and passes ownership to its caller. That function looks like this:</p>
<aside name="owner">
<p>C asks us not just to manage memory explicitly, but <em>mentally</em>. We programmers
have to remember the ownership rules and hand-implement them throughout the
program. Java just does it for us. C++ gives us tools to encode the policy
directly so that the compiler validates it for us.</p>
<p>I like C&rsquo;s simplicity, but we pay a real price for it<span class="em">&mdash;</span>the language requires
us to be more conscientious.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>main.c</em><br>
add after <em>repl</em>()</div>
<pre><span class="k">static</span> <span class="t">char</span>* <span class="i">readFile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">path</span>) {
  <span class="a">FILE</span>* <span class="i">file</span> = <span class="i">fopen</span>(<span class="i">path</span>, <span class="s">&quot;rb&quot;</span>);

  <span class="i">fseek</span>(<span class="i">file</span>, <span class="n">0L</span>, <span class="a">SEEK_END</span>);
  <span class="t">size_t</span> <span class="i">fileSize</span> = <span class="i">ftell</span>(<span class="i">file</span>);
  <span class="i">rewind</span>(<span class="i">file</span>);

  <span class="t">char</span>* <span class="i">buffer</span> = (<span class="t">char</span>*)<span class="i">malloc</span>(<span class="i">fileSize</span> + <span class="n">1</span>);
  <span class="t">size_t</span> <span class="i">bytesRead</span> = <span class="i">fread</span>(<span class="i">buffer</span>, <span class="k">sizeof</span>(<span class="t">char</span>), <span class="i">fileSize</span>, <span class="i">file</span>);
  <span class="i">buffer</span>[<span class="i">bytesRead</span>] = <span class="s">&#39;\0&#39;</span>;

  <span class="i">fclose</span>(<span class="i">file</span>);
  <span class="k">return</span> <span class="i">buffer</span>;
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, add after <em>repl</em>()</div>

<p>Like a lot of C code, it takes more effort than it seems like it should,
especially for a language expressly designed for operating systems. The
difficult part is that we want to allocate a big enough string to read the whole
file, but we don&rsquo;t know how big the file is until we&rsquo;ve read it.</p>
<p>The code here is the classic trick to solve that. We open the file, but before
reading it, we seek to the very end using <code>fseek()</code>. Then we call <code>ftell()</code>
which tells us how many bytes we are from the start of the file. Since we seeked
(sought?) to the end, that&rsquo;s the size. We rewind back to the beginning, allocate
a string of that <span name="one">size</span>, and read the whole file in a
single batch.</p>
<aside name="one">
<p>Well, that size <em>plus one</em>. Always gotta remember to make room for the null
byte.</p>
</aside>
<p>So we&rsquo;re done, right? Not quite. These function calls, like most calls in the C
standard library, can fail. If this were Java, the failures would be thrown as
exceptions and automatically unwind the stack so we wouldn&rsquo;t <em>really</em> need to
handle them. In C, if we don&rsquo;t check for them, they silently get ignored.</p>
<p>This isn&rsquo;t really a book on good C programming practice, but I hate to encourage
bad style, so let&rsquo;s go ahead and handle the errors. It&rsquo;s good for us, like
eating our vegetables or flossing.</p>
<p>Fortunately, we don&rsquo;t need to do anything particularly clever if a failure
occurs. If we can&rsquo;t correctly read the user&rsquo;s script, all we can really do is
tell the user and exit the interpreter gracefully. First of all, we might fail
to open the file.</p>
<div class="codehilite"><pre class="insert-before">  FILE* file = fopen(path, &quot;rb&quot;);
</pre><div class="source-file"><em>main.c</em><br>
in <em>readFile</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">file</span> == <span class="a">NULL</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;Could not open file </span><span class="e">\&quot;</span><span class="s">%s</span><span class="e">\&quot;</span><span class="s">.</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">path</span>);
    <span class="i">exit</span>(<span class="n">74</span>);
  }
</pre><pre class="insert-after">

  fseek(file, 0L, SEEK_END);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>readFile</em>()</div>

<p>This can happen if the file doesn&rsquo;t exist or the user doesn&rsquo;t have access to it.
It&rsquo;s pretty common<span class="em">&mdash;</span>people mistype paths all the time.</p>
<p>This failure is much rarer:</p>
<div class="codehilite"><pre class="insert-before">  char* buffer = (char*)malloc(fileSize + 1);
</pre><div class="source-file"><em>main.c</em><br>
in <em>readFile</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">buffer</span> == <span class="a">NULL</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;Not enough memory to read </span><span class="e">\&quot;</span><span class="s">%s</span><span class="e">\&quot;</span><span class="s">.</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">path</span>);
    <span class="i">exit</span>(<span class="n">74</span>);
  }

</pre><pre class="insert-after">  size_t bytesRead = fread(buffer, sizeof(char), fileSize, file);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>readFile</em>()</div>

<p>If we can&rsquo;t even allocate enough memory to read the Lox script, the user&rsquo;s
probably got bigger problems to worry about, but we should do our best to at
least let them know.</p>
<p>Finally, the read itself may fail.</p>
<div class="codehilite"><pre class="insert-before">  size_t bytesRead = fread(buffer, sizeof(char), fileSize, file);
</pre><div class="source-file"><em>main.c</em><br>
in <em>readFile</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">bytesRead</span> &lt; <span class="i">fileSize</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;Could not read file </span><span class="e">\&quot;</span><span class="s">%s</span><span class="e">\&quot;</span><span class="s">.</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">path</span>);
    <span class="i">exit</span>(<span class="n">74</span>);
  }

</pre><pre class="insert-after">  buffer[bytesRead] = '\0';
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>readFile</em>()</div>

<p>This is also unlikely. Actually, the <span name="printf"> calls</span> to
<code>fseek()</code>, <code>ftell()</code>, and <code>rewind()</code> could theoretically fail too, but let&rsquo;s not
go too far off in the weeds, shall we?</p>
<aside name="printf">
<p>Even good old <code>printf()</code> can fail. Yup. How many times have you handled <em>that</em>
error?</p>
</aside>
<h3><a href="#opening-the-compilation-pipeline" id="opening-the-compilation-pipeline"><small>16&#8202;.&#8202;1&#8202;.&#8202;1</small>Opening the compilation pipeline</a></h3>
<p>We&rsquo;ve got ourselves a string of Lox source code, so now we&rsquo;re ready to set up a
pipeline to scan, compile, and execute it. It&rsquo;s driven by <code>interpret()</code>. Right
now, that function runs our old hardcoded test chunk. Let&rsquo;s change it to
something closer to its final incarnation.</p>
<div class="codehilite"><pre class="insert-before">void freeVM();
</pre><div class="source-file"><em>vm.h</em><br>
function <em>interpret</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);
</pre><pre class="insert-after">void push(Value value);
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, function <em>interpret</em>(), replace 1 line</div>

<p>Where before we passed in a Chunk, now we pass in the string of source code.
Here&rsquo;s the new implementation:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
function <em>interpret</em>()<br>
replace 4 lines</div>
<pre class="insert"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
  <span class="i">compile</span>(<span class="i">source</span>);
  <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, function <em>interpret</em>(), replace 4 lines</div>

<p>We won&rsquo;t build the actual <em>compiler</em> yet in this chapter, but we can start
laying out its structure. It lives in a new module.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert"><span class="a">#include &quot;compiler.h&quot;</span>
</pre><pre class="insert-after">#include &quot;debug.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>

<p>For now, the one function in it is declared like so:</p>
<div class="codehilite"><div class="source-file"><em>compiler.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_compiler_h</span>
<span class="a">#define clox_compiler_h</span>

<span class="t">void</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, create new file</div>

<p>That signature will change, but it gets us going.</p>
<p>The first phase of compilation is scanning<span class="em">&mdash;</span>the thing we&rsquo;re doing in this
chapter<span class="em">&mdash;</span>so right now all the compiler does is set that up.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
create new file</div>
<pre><span class="a">#include &lt;stdio.h&gt;</span>

<span class="a">#include &quot;common.h&quot;</span>
<span class="a">#include &quot;compiler.h&quot;</span>
<span class="a">#include &quot;scanner.h&quot;</span>

<span class="t">void</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
  <span class="i">initScanner</span>(<span class="i">source</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, create new file</div>

<p>This will also grow in later chapters, naturally.</p>
<h3><a href="#the-scanner-scans" id="the-scanner-scans"><small>16&#8202;.&#8202;1&#8202;.&#8202;2</small>The scanner scans</a></h3>
<p>There are still a few more feet of scaffolding to stand up before we can start
writing useful code. First, a new header:</p>
<div class="codehilite"><div class="source-file"><em>scanner.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_scanner_h</span>
<span class="a">#define clox_scanner_h</span>

<span class="t">void</span> <span class="i">initScanner</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em>, create new file</div>

<p>And its corresponding implementation:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
create new file</div>
<pre><span class="a">#include &lt;stdio.h&gt;</span>
<span class="a">#include &lt;string.h&gt;</span>

<span class="a">#include &quot;common.h&quot;</span>
<span class="a">#include &quot;scanner.h&quot;</span>

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="k">const</span> <span class="t">char</span>* <span class="i">start</span>;
  <span class="k">const</span> <span class="t">char</span>* <span class="i">current</span>;
  <span class="t">int</span> <span class="i">line</span>;
} <span class="t">Scanner</span>;

<span class="t">Scanner</span> <span class="i">scanner</span>;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, create new file</div>

<p>As our scanner chews through the user&rsquo;s source code, it tracks how far it&rsquo;s
gone. Like we did with the VM, we wrap that state in a struct and then create a
single top-level module variable of that type so we don&rsquo;t have to pass it around
all of the various functions.</p>
<p>There are surprisingly few fields. The <code>start</code> pointer marks the beginning of
the current lexeme being scanned, and <code>current</code> points to the current character
being looked at.</p>
<p><span name="fields"></span></p><img src="image/scanning-on-demand/fields.png" alt="The start and current fields pointing at 'print bacon;'. Start points at 'b' and current points at 'o'." />
<aside name="fields">
<p>Here, we are in the middle of scanning the identifier <code>bacon</code>. The current
character is <code>o</code> and the character we most recently consumed is <code>c</code>.</p>
</aside>
<p>We have a <code>line</code> field to track what line the current lexeme is on for error
reporting. That&rsquo;s it! We don&rsquo;t even keep a pointer to the beginning of the
source code string. The scanner works its way through the code once and is done
after that.</p>
<p>Since we have some state, we should initialize it.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after variable <em>scanner</em></div>
<pre><span class="t">void</span> <span class="i">initScanner</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
  <span class="i">scanner</span>.<span class="i">start</span> = <span class="i">source</span>;
  <span class="i">scanner</span>.<span class="i">current</span> = <span class="i">source</span>;
  <span class="i">scanner</span>.<span class="i">line</span> = <span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after variable <em>scanner</em></div>

<p>We start at the very first character on the very first line, like a runner
crouched at the starting line.</p>
<h2><a href="#a-token-at-a-time" id="a-token-at-a-time"><small>16&#8202;.&#8202;2</small>A Token at a Time</a></h2>
<p>In jlox, when the starting gun went off, the scanner raced ahead and eagerly
scanned the whole program, returning a list of tokens. This would be a challenge
in clox. We&rsquo;d need some sort of growable array or list to store the tokens in.
We&rsquo;d need to manage allocating and freeing the tokens, and the collection
itself. That&rsquo;s a lot of code, and a lot of memory churn.</p>
<p>At any point in time, the compiler needs only one or two tokens<span class="em">&mdash;</span>remember our
grammar requires only a single token of lookahead<span class="em">&mdash;</span>so we don&rsquo;t need to keep
them <em>all</em> around at the same time. Instead, the simplest solution is to not
scan a token until the compiler needs one. When the scanner provides one, it
returns the token by value. It doesn&rsquo;t need to dynamically allocate anything<span class="em">&mdash;</span>it can just pass tokens around on the C stack.</p>
<p>Unfortunately, we don&rsquo;t have a compiler yet that can ask the scanner for tokens,
so the scanner will just sit there doing nothing. To kick it into action, we&rsquo;ll
write some temporary code to drive it.</p>
<div class="codehilite"><pre class="insert-before">  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="t">int</span> <span class="i">line</span> = -<span class="n">1</span>;
  <span class="k">for</span> (;;) {
    <span class="t">Token</span> <span class="i">token</span> = <span class="i">scanToken</span>();
    <span class="k">if</span> (<span class="i">token</span>.<span class="i">line</span> != <span class="i">line</span>) {
      <span class="i">printf</span>(<span class="s">&quot;%4d &quot;</span>, <span class="i">token</span>.<span class="i">line</span>);
      <span class="i">line</span> = <span class="i">token</span>.<span class="i">line</span>;
    } <span class="k">else</span> {
      <span class="i">printf</span>(<span class="s">&quot;   | &quot;</span>);
    }
    <span class="i">printf</span>(<span class="s">&quot;%2d &#39;%.*s&#39;</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">token</span>.<span class="i">type</span>, <span class="i">token</span>.<span class="i">length</span>, <span class="i">token</span>.<span class="i">start</span>);<span name="format"> </span>

    <span class="k">if</span> (<span class="i">token</span>.<span class="i">type</span> == <span class="a">TOKEN_EOF</span>) <span class="k">break</span>;
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<aside name="format">
<p>That <code>%.*s</code> in the format string is a neat feature. Usually, you set the output
precision<span class="em">&mdash;</span>the number of characters to show<span class="em">&mdash;</span>by placing a number inside the
format string. Using <code>*</code> instead lets you pass the precision as an argument. So
that <code>printf()</code> call prints the first <code>token.length</code> characters of the string at
<code>token.start</code>. We need to limit the length like that because the lexeme points
into the original source string and doesn&rsquo;t have a terminator at the end.</p>
</aside>
<p>This loops indefinitely. Each turn through the loop, it scans one token and
prints it. When it reaches a special &ldquo;end of file&rdquo; token or an error, it stops.
For example, if we run the interpreter on this program:</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="n">1</span> + <span class="n">2</span>;
</pre></div>
<p>It prints out:</p>
<div class="codehilite"><pre>   1 31 'print'
   | 21 '1'
   |  7 '+'
   | 21 '2'
   |  8 ';'
   2 39 ''
</pre></div>
<p>The first column is the line number, the second is the numeric value of the
token <span name="token">type</span>, and then finally the lexeme. That last
empty lexeme on line 2 is the EOF token.</p>
<aside name="token">
<p>Yeah, the raw index of the token type isn&rsquo;t exactly human readable, but it&rsquo;s all
C gives us.</p>
</aside>
<p>The goal for the rest of the chapter is to make that blob of code work by
implementing this key function:</p>
<div class="codehilite"><pre class="insert-before">void initScanner(const char* source);
</pre><div class="source-file"><em>scanner.h</em><br>
add after <em>initScanner</em>()</div>
<pre class="insert"><span class="t">Token</span> <span class="i">scanToken</span>();
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em>, add after <em>initScanner</em>()</div>

<p>Each call scans and returns the next token in the source code. A token looks
like this:</p>
<div class="codehilite"><pre class="insert-before">#define clox_scanner_h
</pre><div class="source-file"><em>scanner.h</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">TokenType</span> <span class="i">type</span>;
  <span class="k">const</span> <span class="t">char</span>* <span class="i">start</span>;
  <span class="t">int</span> <span class="i">length</span>;
  <span class="t">int</span> <span class="i">line</span>;
} <span class="t">Token</span>;
</pre><pre class="insert-after">

void initScanner(const char* source);
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em></div>

<p>It&rsquo;s pretty similar to jlox&rsquo;s Token class. We have an enum identifying what type
of token it is<span class="em">&mdash;</span>number, identifier, <code>+</code> operator, etc. The enum is virtually
identical to the one in jlox, so let&rsquo;s just hammer out the whole thing.</p>
<div class="codehilite"><pre class="insert-before">#ifndef clox_scanner_h
#define clox_scanner_h
</pre><div class="source-file"><em>scanner.h</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">enum</span> {
  <span class="c">// Single-character tokens.</span>
  <span class="a">TOKEN_LEFT_PAREN</span>, <span class="a">TOKEN_RIGHT_PAREN</span>,
  <span class="a">TOKEN_LEFT_BRACE</span>, <span class="a">TOKEN_RIGHT_BRACE</span>,
  <span class="a">TOKEN_COMMA</span>, <span class="a">TOKEN_DOT</span>, <span class="a">TOKEN_MINUS</span>, <span class="a">TOKEN_PLUS</span>,
  <span class="a">TOKEN_SEMICOLON</span>, <span class="a">TOKEN_SLASH</span>, <span class="a">TOKEN_STAR</span>,
  <span class="c">// One or two character tokens.</span>
  <span class="a">TOKEN_BANG</span>, <span class="a">TOKEN_BANG_EQUAL</span>,
  <span class="a">TOKEN_EQUAL</span>, <span class="a">TOKEN_EQUAL_EQUAL</span>,
  <span class="a">TOKEN_GREATER</span>, <span class="a">TOKEN_GREATER_EQUAL</span>,
  <span class="a">TOKEN_LESS</span>, <span class="a">TOKEN_LESS_EQUAL</span>,
  <span class="c">// Literals.</span>
  <span class="a">TOKEN_IDENTIFIER</span>, <span class="a">TOKEN_STRING</span>, <span class="a">TOKEN_NUMBER</span>,
  <span class="c">// Keywords.</span>
  <span class="a">TOKEN_AND</span>, <span class="a">TOKEN_CLASS</span>, <span class="a">TOKEN_ELSE</span>, <span class="a">TOKEN_FALSE</span>,
  <span class="a">TOKEN_FOR</span>, <span class="a">TOKEN_FUN</span>, <span class="a">TOKEN_IF</span>, <span class="a">TOKEN_NIL</span>, <span class="a">TOKEN_OR</span>,
  <span class="a">TOKEN_PRINT</span>, <span class="a">TOKEN_RETURN</span>, <span class="a">TOKEN_SUPER</span>, <span class="a">TOKEN_THIS</span>,
  <span class="a">TOKEN_TRUE</span>, <span class="a">TOKEN_VAR</span>, <span class="a">TOKEN_WHILE</span>,

  <span class="a">TOKEN_ERROR</span>, <span class="a">TOKEN_EOF</span>
} <span class="t">TokenType</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em></div>

<p>Aside from prefixing all the names with <code>TOKEN_</code> (since C tosses enum names in
the top-level namespace) the only difference is that extra <code>TOKEN_ERROR</code> type.
What&rsquo;s that about?</p>
<p>There are only a couple of errors that get detected during scanning:
unterminated strings and unrecognized characters. In jlox, the scanner reports
those itself. In clox, the scanner produces a synthetic &ldquo;error&rdquo; token for that
error and passes it over to the compiler. This way, the compiler knows an error
occurred and can kick off error recovery before reporting it.</p>
<p>The novel part in clox&rsquo;s Token type is how it represents the lexeme. In jlox,
each Token stored the lexeme as its own separate little Java string. If we did
that for clox, we&rsquo;d have to figure out how to manage the memory for those
strings. That&rsquo;s especially hard since we pass tokens by value<span class="em">&mdash;</span>multiple tokens could point to the same lexeme string. Ownership gets weird.</p>
<p>Instead, we use the original source string as our character store. We represent
a lexeme by a pointer to its first character and the number of characters it
contains. This means we don&rsquo;t need to worry about managing memory for lexemes at
all and we can freely copy tokens around. As long as the main source code string
<span name="outlive">outlives</span> all of the tokens, everything works fine.</p>
<aside name="outlive">
<p>I don&rsquo;t mean to sound flippant. We really do need to think about and ensure that
the source string, which is created far away over in the &ldquo;main&rdquo; module, has a
long enough lifetime. That&rsquo;s why <code>runFile()</code> doesn&rsquo;t free the string until
<code>interpret()</code> finishes executing the code and returns.</p>
</aside>
<h3><a href="#scanning-tokens" id="scanning-tokens"><small>16&#8202;.&#8202;2&#8202;.&#8202;1</small>Scanning tokens</a></h3>
<p>We&rsquo;re ready to scan some tokens. We&rsquo;ll work our way up to the complete
implementation, starting with this:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>initScanner</em>()</div>
<pre><span class="t">Token</span> <span class="i">scanToken</span>() {
  <span class="i">scanner</span>.<span class="i">start</span> = <span class="i">scanner</span>.<span class="i">current</span>;

  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_EOF</span>);

  <span class="k">return</span> <span class="i">errorToken</span>(<span class="s">&quot;Unexpected character.&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>

<p>Since each call to this function scans a complete token, we know we are at the
beginning of a new token when we enter the function. Thus, we set
<code>scanner.start</code> to point to the current character so we remember where the
lexeme we&rsquo;re about to scan starts.</p>
<p>Then we check to see if we&rsquo;ve reached the end of the source code. If so, we
return an EOF token and stop. This is a sentinel value that signals to the
compiler to stop asking for more tokens.</p>
<p>If we aren&rsquo;t at the end, we do some<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>stuff<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>to scan the next token. But we
haven&rsquo;t written that code yet. We&rsquo;ll get to that soon. If that code doesn&rsquo;t
successfully scan and return a token, then we reach the end of the function.
That must mean we&rsquo;re at a character that the scanner can&rsquo;t recognize, so we
return an error token for that.</p>
<p>This function relies on a couple of helpers, most of which are familiar from
jlox. First up:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>initScanner</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">isAtEnd</span>() {
  <span class="k">return</span> *<span class="i">scanner</span>.<span class="i">current</span> == <span class="s">&#39;\0&#39;</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>

<p>We require the source string to be a good null-terminated C string. If the
current character is the null byte, then we&rsquo;ve reached the end.</p>
<p>To create a token, we have this constructor-like function:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>isAtEnd</em>()</div>
<pre><span class="k">static</span> <span class="t">Token</span> <span class="i">makeToken</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="t">Token</span> <span class="i">token</span>;
  <span class="i">token</span>.<span class="i">type</span> = <span class="i">type</span>;
  <span class="i">token</span>.<span class="i">start</span> = <span class="i">scanner</span>.<span class="i">start</span>;
  <span class="i">token</span>.<span class="i">length</span> = (<span class="t">int</span>)(<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span>);
  <span class="i">token</span>.<span class="i">line</span> = <span class="i">scanner</span>.<span class="i">line</span>;
  <span class="k">return</span> <span class="i">token</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>isAtEnd</em>()</div>

<p>It uses the scanner&rsquo;s <code>start</code> and <code>current</code> pointers to capture the token&rsquo;s
lexeme. It sets a couple of other obvious fields then returns the token. It has
a sister function for returning error tokens.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>makeToken</em>()</div>
<pre><span class="k">static</span> <span class="t">Token</span> <span class="i">errorToken</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="t">Token</span> <span class="i">token</span>;
  <span class="i">token</span>.<span class="i">type</span> = <span class="a">TOKEN_ERROR</span>;
  <span class="i">token</span>.<span class="i">start</span> = <span class="i">message</span>;
  <span class="i">token</span>.<span class="i">length</span> = (<span class="t">int</span>)<span class="i">strlen</span>(<span class="i">message</span>);
  <span class="i">token</span>.<span class="i">line</span> = <span class="i">scanner</span>.<span class="i">line</span>;
  <span class="k">return</span> <span class="i">token</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>makeToken</em>()</div>

<p><span name="axolotl"></span></p>
<aside name="axolotl">
<p>This part of the chapter is pretty dry, so here&rsquo;s a picture of an axolotl.</p><img src="image/scanning-on-demand/axolotl.png" alt="A drawing of an axolotl." />
</aside>
<p>The only difference is that the &ldquo;lexeme&rdquo; points to the error message string
instead of pointing into the user&rsquo;s source code. Again, we need to ensure that
the error message sticks around long enough for the compiler to read it. In
practice, we only ever call this function with C string literals. Those are
constant and eternal, so we&rsquo;re fine.</p>
<p>What we have now is basically a working scanner for a language with an empty
lexical grammar. Since the grammar has no productions, every character is an
error. That&rsquo;s not exactly a fun language to program in, so let&rsquo;s fill in the
rules.</p>
<h2><a href="#a-lexical-grammar-for-lox" id="a-lexical-grammar-for-lox"><small>16&#8202;.&#8202;3</small>A Lexical Grammar for Lox</a></h2>
<p>The simplest tokens are only a single character. We recognize those like so:</p>
<div class="codehilite"><pre class="insert-before">  if (isAtEnd()) return makeToken(TOKEN_EOF);
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">

  <span class="t">char</span> <span class="i">c</span> = <span class="i">advance</span>();

  <span class="k">switch</span> (<span class="i">c</span>) {
    <span class="k">case</span> <span class="s">&#39;(&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_LEFT_PAREN</span>);
    <span class="k">case</span> <span class="s">&#39;)&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_RIGHT_PAREN</span>);
    <span class="k">case</span> <span class="s">&#39;{&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_LEFT_BRACE</span>);
    <span class="k">case</span> <span class="s">&#39;}&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_RIGHT_BRACE</span>);
    <span class="k">case</span> <span class="s">&#39;;&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_SEMICOLON</span>);
    <span class="k">case</span> <span class="s">&#39;,&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_COMMA</span>);
    <span class="k">case</span> <span class="s">&#39;.&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_DOT</span>);
    <span class="k">case</span> <span class="s">&#39;-&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_MINUS</span>);
    <span class="k">case</span> <span class="s">&#39;+&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_PLUS</span>);
    <span class="k">case</span> <span class="s">&#39;/&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_SLASH</span>);
    <span class="k">case</span> <span class="s">&#39;*&#39;</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_STAR</span>);
  }
</pre><pre class="insert-after">

  return errorToken(&quot;Unexpected character.&quot;);
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>

<p>We read the next character from the source code, and then do a straightforward
switch to see if it matches any of Lox&rsquo;s one-character lexemes. To read the next
character, we use a new helper which consumes the current character and returns
it.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>isAtEnd</em>()</div>
<pre><span class="k">static</span> <span class="t">char</span> <span class="i">advance</span>() {
  <span class="i">scanner</span>.<span class="i">current</span>++;
  <span class="k">return</span> <span class="i">scanner</span>.<span class="i">current</span>[-<span class="n">1</span>];
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>isAtEnd</em>()</div>

<p>Next up are the two-character punctuation tokens like <code>!=</code> and <code>&gt;=</code>. Each of
these also has a corresponding single-character token. That means that when we
see a character like <code>!</code>, we don&rsquo;t know if we&rsquo;re in a <code>!</code> token or a <code>!=</code> until
we look at the next character too. We handle those like so:</p>
<div class="codehilite"><pre class="insert-before">    case '*': return makeToken(TOKEN_STAR);
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="s">&#39;!&#39;</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">&#39;=&#39;</span>) ? <span class="a">TOKEN_BANG_EQUAL</span> : <span class="a">TOKEN_BANG</span>);
    <span class="k">case</span> <span class="s">&#39;=&#39;</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">&#39;=&#39;</span>) ? <span class="a">TOKEN_EQUAL_EQUAL</span> : <span class="a">TOKEN_EQUAL</span>);
    <span class="k">case</span> <span class="s">&#39;&lt;&#39;</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">&#39;=&#39;</span>) ? <span class="a">TOKEN_LESS_EQUAL</span> : <span class="a">TOKEN_LESS</span>);
    <span class="k">case</span> <span class="s">&#39;&gt;&#39;</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">&#39;=&#39;</span>) ? <span class="a">TOKEN_GREATER_EQUAL</span> : <span class="a">TOKEN_GREATER</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>

<p>After consuming the first character, we look for an <code>=</code>. If found, we consume it
and return the corresponding two-character token. Otherwise, we leave the
current character alone (so it can be part of the <em>next</em> token) and return the
appropriate one-character token.</p>
<p>That logic for conditionally consuming the second character lives here:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>advance</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">match</span>(<span class="t">char</span> <span class="i">expected</span>) {
  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">if</span> (*<span class="i">scanner</span>.<span class="i">current</span> != <span class="i">expected</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="i">scanner</span>.<span class="i">current</span>++;
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>advance</em>()</div>

<p>If the current character is the desired one, we advance and return <code>true</code>.
Otherwise, we return <code>false</code> to indicate it wasn&rsquo;t matched.</p>
<p>Now our scanner supports all of the punctuation-like tokens. Before we get to
the longer ones, let&rsquo;s take a little side trip to handle characters that aren&rsquo;t
part of a token at all.</p>
<h3><a href="#whitespace" id="whitespace"><small>16&#8202;.&#8202;3&#8202;.&#8202;1</small>Whitespace</a></h3>
<p>Our scanner needs to handle spaces, tabs, and newlines, but those characters
don&rsquo;t become part of any token&rsquo;s lexeme. We could check for those inside the
main character switch in <code>scanToken()</code> but it gets a little tricky to ensure
that the function still correctly finds the next token <em>after</em> the whitespace
when you call it. We&rsquo;d have to wrap the whole body of the function in a loop or
something.</p>
<p>Instead, before starting the token, we shunt off to a separate function.</p>
<div class="codehilite"><pre class="insert-before">Token scanToken() {
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">  <span class="i">skipWhitespace</span>();
</pre><pre class="insert-after">  scanner.start = scanner.current;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>

<p>This advances the scanner past any leading whitespace. After this call returns,
we know the very next character is a meaningful one (or we&rsquo;re at the end of the
source code).</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>errorToken</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">skipWhitespace</span>() {
  <span class="k">for</span> (;;) {
    <span class="t">char</span> <span class="i">c</span> = <span class="i">peek</span>();
    <span class="k">switch</span> (<span class="i">c</span>) {
      <span class="k">case</span> <span class="s">&#39; &#39;</span>:
      <span class="k">case</span> <span class="s">&#39;\r&#39;</span>:
      <span class="k">case</span> <span class="s">&#39;\t&#39;</span>:
        <span class="i">advance</span>();
        <span class="k">break</span>;
      <span class="k">default</span>:
        <span class="k">return</span>;
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>errorToken</em>()</div>

<p>It&rsquo;s sort of a separate mini-scanner. It loops, consuming every whitespace
character it encounters. We need to be careful that it does <em>not</em> consume any
<em>non</em>-whitespace characters. To support that, we use this:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>advance</em>()</div>
<pre><span class="k">static</span> <span class="t">char</span> <span class="i">peek</span>() {
  <span class="k">return</span> *<span class="i">scanner</span>.<span class="i">current</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>advance</em>()</div>

<p>This simply returns the current character, but doesn&rsquo;t consume it. The previous
code handles all the whitespace characters except for newlines.</p>
<div class="codehilite"><pre class="insert-before">        break;
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>skipWhitespace</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="s">&#39;\n&#39;</span>:
        <span class="i">scanner</span>.<span class="i">line</span>++;
        <span class="i">advance</span>();
        <span class="k">break</span>;
</pre><pre class="insert-after">      default:
        return;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>skipWhitespace</em>()</div>

<p>When we consume one of those, we also bump the current line number.</p>
<h3><a href="#comments" id="comments"><small>16&#8202;.&#8202;3&#8202;.&#8202;2</small>Comments</a></h3>
<p>Comments aren&rsquo;t technically &ldquo;whitespace&rdquo;, if you want to get all precise with
your terminology, but as far as Lox is concerned, they may as well be, so we
skip those too.</p>
<div class="codehilite"><pre class="insert-before">        break;
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>skipWhitespace</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="s">&#39;/&#39;</span>:
        <span class="k">if</span> (<span class="i">peekNext</span>() == <span class="s">&#39;/&#39;</span>) {
          <span class="c">// A comment goes until the end of the line.</span>
          <span class="k">while</span> (<span class="i">peek</span>() != <span class="s">&#39;\n&#39;</span> &amp;&amp; !<span class="i">isAtEnd</span>()) <span class="i">advance</span>();
        } <span class="k">else</span> {
          <span class="k">return</span>;
        }
        <span class="k">break</span>;
</pre><pre class="insert-after">      default:
        return;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>skipWhitespace</em>()</div>

<p>Comments start with <code>//</code> in Lox, so as with <code>!=</code> and friends, we need a second
character of lookahead. However, with <code>!=</code>, we still wanted to consume the <code>!</code>
even if the <code>=</code> wasn&rsquo;t found. Comments are different. If we don&rsquo;t find a second
<code>/</code>, then <code>skipWhitespace()</code> needs to not consume the <em>first</em> slash either.</p>
<p>To handle that, we add:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>peek</em>()</div>
<pre><span class="k">static</span> <span class="t">char</span> <span class="i">peekNext</span>() {
  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="s">&#39;\0&#39;</span>;
  <span class="k">return</span> <span class="i">scanner</span>.<span class="i">current</span>[<span class="n">1</span>];
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>peek</em>()</div>

<p>This is like <code>peek()</code> but for one character past the current one. If the current
character and the next one are both <code>/</code>, we consume them and then any other
characters until the next newline or the end of the source code.</p>
<p>We use <code>peek()</code> to check for the newline but not consume it. That way, the
newline will be the current character on the next turn of the outer loop in
<code>skipWhitespace()</code> and we&rsquo;ll recognize it and increment <code>scanner.line</code>.</p>
<h3><a href="#literal-tokens" id="literal-tokens"><small>16&#8202;.&#8202;3&#8202;.&#8202;3</small>Literal tokens</a></h3>
<p>Number and string tokens are special because they have a runtime value
associated with them. We&rsquo;ll start with strings because they are easy to
recognize<span class="em">&mdash;</span>they always begin with a double quote.</p>
<div class="codehilite"><pre class="insert-before">          match('=') ? TOKEN_GREATER_EQUAL : TOKEN_GREATER);
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="s">&#39;&quot;&#39;</span>: <span class="k">return</span> <span class="i">string</span>();
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>

<p>That calls a new function.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>skipWhitespace</em>()</div>
<pre><span class="k">static</span> <span class="t">Token</span> <span class="i">string</span>() {
  <span class="k">while</span> (<span class="i">peek</span>() != <span class="s">&#39;&quot;&#39;</span> &amp;&amp; !<span class="i">isAtEnd</span>()) {
    <span class="k">if</span> (<span class="i">peek</span>() == <span class="s">&#39;\n&#39;</span>) <span class="i">scanner</span>.<span class="i">line</span>++;
    <span class="i">advance</span>();
  }

  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="i">errorToken</span>(<span class="s">&quot;Unterminated string.&quot;</span>);

  <span class="c">// The closing quote.</span>
  <span class="i">advance</span>();
  <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_STRING</span>);
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>

<p>Similar to jlox, we consume characters until we reach the closing quote. We also
track newlines inside the string literal. (Lox supports multi-line strings.)
And, as ever, we gracefully handle running out of source code before we find the
end quote.</p>
<p>The main change here in clox is something that&rsquo;s <em>not</em> present. Again, it
relates to memory management. In jlox, the Token class had a field of type
Object to store the runtime value converted from the literal token&rsquo;s lexeme.</p>
<p>Implementing that in C would require a lot of work. We&rsquo;d need some sort of union
and type tag to tell whether the token contains a string or double value. If
it&rsquo;s a string, we&rsquo;d need to manage the memory for the string&rsquo;s character array
somehow.</p>
<p>Instead of adding that complexity to the scanner, we defer <span
name="convert">converting</span> the literal lexeme to a runtime value until
later. In clox, tokens only store the lexeme<span class="em">&mdash;</span>the character sequence exactly
as it appears in the user&rsquo;s source code. Later in the compiler, we&rsquo;ll convert
that lexeme to a runtime value right when we are ready to store it in the
chunk&rsquo;s constant table.</p>
<aside name="convert">
<p>Doing the lexeme-to-value conversion in the compiler does introduce some
redundancy. The work to scan a number literal is awfully similar to the work
required to convert a sequence of digit characters to a number value. But there
isn&rsquo;t <em>that</em> much redundancy, it isn&rsquo;t in anything performance critical, and it
keeps our scanner simpler.</p>
</aside>
<p>Next up, numbers. Instead of adding a switch case for each of the ten digits
that can start a number, we handle them here:</p>
<div class="codehilite"><pre class="insert-before">  char c = advance();
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">isDigit</span>(<span class="i">c</span>)) <span class="k">return</span> <span class="i">number</span>();
</pre><pre class="insert-after">

  switch (c) {
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>

<p>That uses this obvious utility function:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>initScanner</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">isDigit</span>(<span class="t">char</span> <span class="i">c</span>) {
  <span class="k">return</span> <span class="i">c</span> &gt;= <span class="s">&#39;0&#39;</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">&#39;9&#39;</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>

<p>We finish scanning the number using this:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>skipWhitespace</em>()</div>
<pre><span class="k">static</span> <span class="t">Token</span> <span class="i">number</span>() {
  <span class="k">while</span> (<span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();

  <span class="c">// Look for a fractional part.</span>
  <span class="k">if</span> (<span class="i">peek</span>() == <span class="s">&#39;.&#39;</span> &amp;&amp; <span class="i">isDigit</span>(<span class="i">peekNext</span>())) {
    <span class="c">// Consume the &quot;.&quot;.</span>
    <span class="i">advance</span>();

    <span class="k">while</span> (<span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();
  }

  <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_NUMBER</span>);
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>

<p>It&rsquo;s virtually identical to jlox&rsquo;s version except, again, we don&rsquo;t convert the
lexeme to a double yet.</p>
<h2><a href="#identifiers-and-keywords" id="identifiers-and-keywords"><small>16&#8202;.&#8202;4</small>Identifiers and Keywords</a></h2>
<p>The last batch of tokens are identifiers, both user-defined and reserved. This
section should be fun<span class="em">&mdash;</span>the way we recognize keywords in clox is quite
different from how we did it in jlox, and touches on some important data
structures.</p>
<p>First, though, we have to scan the lexeme. Names start with a letter or
underscore.</p>
<div class="codehilite"><pre class="insert-before">  char c = advance();
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">isAlpha</span>(<span class="i">c</span>)) <span class="k">return</span> <span class="i">identifier</span>();
</pre><pre class="insert-after">  if (isDigit(c)) return number();
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>

<p>We recognize those using this:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>initScanner</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">isAlpha</span>(<span class="t">char</span> <span class="i">c</span>) {
  <span class="k">return</span> (<span class="i">c</span> &gt;= <span class="s">&#39;a&#39;</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">&#39;z&#39;</span>) ||
         (<span class="i">c</span> &gt;= <span class="s">&#39;A&#39;</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">&#39;Z&#39;</span>) ||
          <span class="i">c</span> == <span class="s">&#39;_&#39;</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>

<p>Once we&rsquo;ve found an identifier, we scan the rest of it here:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>skipWhitespace</em>()</div>
<pre><span class="k">static</span> <span class="t">Token</span> <span class="i">identifier</span>() {
  <span class="k">while</span> (<span class="i">isAlpha</span>(<span class="i">peek</span>()) || <span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();
  <span class="k">return</span> <span class="i">makeToken</span>(<span class="i">identifierType</span>());
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>

<p>After the first letter, we allow digits too, and we keep consuming alphanumerics
until we run out of them. Then we produce a token with the proper type.
Determining that &ldquo;proper&rdquo; type is the unique part of this chapter.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>skipWhitespace</em>()</div>
<pre><span class="k">static</span> <span class="t">TokenType</span> <span class="i">identifierType</span>() {
  <span class="k">return</span> <span class="a">TOKEN_IDENTIFIER</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>

<p>Okay, I guess that&rsquo;s not very exciting yet. That&rsquo;s what it looks like if we
have no reserved words at all. How should we go about recognizing keywords? In
jlox, we stuffed them all in a Java Map and looked them up by name. We don&rsquo;t
have any sort of hash table structure in clox, at least not yet.</p>
<p>A hash table would be overkill anyway. To look up a string in a hash <span
name="hash">table</span>, we need to walk the string to calculate its hash code,
find the corresponding bucket in the hash table, and then do a
character-by-character equality comparison on any string it happens to find
there.</p>
<aside name="hash">
<p>Don&rsquo;t worry if this is unfamiliar to you. When we get to <a href="hash-tables.html">building our own hash
table from scratch</a>, we&rsquo;ll learn all about it in exquisite detail.</p>
</aside>
<p>Let&rsquo;s say we&rsquo;ve scanned the identifier &ldquo;gorgonzola&rdquo;. How much work <em>should</em> we
need to do to tell if that&rsquo;s a reserved word? Well, no Lox keyword starts with
&ldquo;g&rdquo;, so looking at the first character is enough to definitively answer no.
That&rsquo;s a lot simpler than a hash table lookup.</p>
<p>What about &ldquo;cardigan&rdquo;? We do have a keyword in Lox that starts with &ldquo;c&rdquo;:
&ldquo;class&rdquo;. But the second character in &ldquo;cardigan&rdquo;, &ldquo;a&rdquo;, rules that out. What about
&ldquo;forest&rdquo;? Since &ldquo;for&rdquo; is a keyword, we have to go farther in the string before
we can establish that we don&rsquo;t have a reserved word. But, in most cases, only a
character or two is enough to tell we&rsquo;ve got a user-defined name on our hands.
We should be able to recognize that and fail fast.</p>
<p>Here&rsquo;s a visual representation of that branching character-inspection logic:</p>
<p><span name="down"></span></p><img src="image/scanning-on-demand/keywords.png" alt="A trie that contains all of Lox's keywords." />
<aside name="down">
<p>Read down each chain of nodes and you&rsquo;ll see Lox&rsquo;s keywords emerge.</p>
</aside>
<p>We start at the root node. If there is a child node whose letter matches the
first character in the lexeme, we move to that node. Then repeat for the next
letter in the lexeme and so on. If at any point the next letter in the lexeme
doesn&rsquo;t match a child node, then the identifier must not be a keyword and we
stop. If we reach a double-lined box, and we&rsquo;re at the last character of the
lexeme, then we found a keyword.</p>
<h3><a href="#tries-and-state-machines" id="tries-and-state-machines"><small>16&#8202;.&#8202;4&#8202;.&#8202;1</small>Tries and state machines</a></h3>
<p>This tree diagram is an example of a thing called a <span
name="trie"><a href="https://en.wikipedia.org/wiki/Trie"><strong>trie</strong></a></span>. A trie stores a set of strings. Most other
data structures for storing strings contain the raw character arrays and then
wrap them inside some larger construct that helps you search faster. A trie is
different. Nowhere in the trie will you find a whole string.</p>
<aside name="trie">
<p>&ldquo;Trie&rdquo; is one of the most confusing names in CS. Edward Fredkin yanked it out of
the middle of the word &ldquo;retrieval&rdquo;, which means it should be pronounced like
&ldquo;tree&rdquo;. But, uh, there is already a pretty important data structure pronounced
&ldquo;tree&rdquo; <em>which tries are a special case of</em>, so unless you never speak of these
things out loud, no one can tell which one you&rsquo;re talking about. Thus, people
these days often pronounce it like &ldquo;try&rdquo; to avoid the headache.</p>
</aside>
<p>Instead, each string the trie &ldquo;contains&rdquo; is represented as a <em>path</em> through the
tree of character nodes, as in our traversal above. Nodes that match the last
character in a string have a special marker<span class="em">&mdash;</span>the double lined boxes in the
illustration. That way, if your trie contains, say, &ldquo;banquet&rdquo; and &ldquo;ban&rdquo;, you are
able to tell that it does <em>not</em> contain &ldquo;banque&rdquo;<span class="em">&mdash;</span>the &ldquo;e&rdquo; node won&rsquo;t have that
marker, while the &ldquo;n&rdquo; and &ldquo;t&rdquo; nodes will.</p>
<p>Tries are a special case of an even more fundamental data structure: a
<a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton"><strong>deterministic finite automaton</strong></a> (<strong>DFA</strong>). You might also know these
by other names: <strong>finite state machine</strong>, or just <strong>state machine</strong>. State
machines are rad. They end up useful in everything from <a href="http://gameprogrammingpatterns.com/state.html">game
programming</a> to implementing networking protocols.</p>
<p>In a DFA, you have a set of <em>states</em> with <em>transitions</em> between them, forming a
graph. At any point in time, the machine is &ldquo;in&rdquo; exactly one state. It gets to
other states by following transitions. When you use a DFA for lexical analysis,
each transition is a character that gets matched from the string. Each state
represents a set of allowed characters.</p>
<p>Our keyword tree is exactly a DFA that recognizes Lox keywords. But DFAs are
more powerful than simple trees because they can be arbitrary <em>graphs</em>.
Transitions can form cycles between states. That lets you recognize arbitrarily
long strings. For example, here&rsquo;s a DFA that recognizes number literals:</p>
<p><span name="railroad"></span></p><img src="image/scanning-on-demand/numbers.png" alt="A syntax diagram that recognizes integer and floating point literals." />
<aside name="railroad">
<p>This style of diagram is called a <a href="https://en.wikipedia.org/wiki/Syntax_diagram"><strong>syntax diagram</strong></a> or the
more charming <strong>railroad diagram</strong>. The latter name is because it looks
something like a switching yard for trains.</p>
<p>Back before Backus-Naur Form was a thing, this was one of the predominant ways
of documenting a language&rsquo;s grammar. These days, we mostly use text, but there&rsquo;s
something delightful about the official specification for a <em>textual language</em>
relying on an <em>image</em>.</p>
</aside>
<p>I&rsquo;ve collapsed the nodes for the ten digits together to keep it more readable,
but the basic process works the same<span class="em">&mdash;</span>you work through the path, entering
nodes whenever you consume a corresponding character in the lexeme. If we were
so inclined, we could construct one big giant DFA that does <em>all</em> of the lexical
analysis for Lox, a single state machine that recognizes and spits out all of
the tokens we need.</p>
<p>However, crafting that mega-DFA by <span name="regex">hand</span> would be
challenging. That&rsquo;s why <a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a> was created. You give it a simple textual
description of your lexical grammar<span class="em">&mdash;</span>a bunch of regular expressions<span class="em">&mdash;</span>and it
automatically generates a DFA for you and produces a pile of C code that
implements it.</p>
<aside name="regex">
<p>This is also how most regular expression engines in programming languages and
text editors work under the hood. They take your regex string and convert it to
a DFA, which they then use to match strings.</p>
<p>If you want to learn the algorithm to convert a regular expression into a DFA,
<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">the dragon book</a> has you covered.</p>
</aside>
<p>We won&rsquo;t go down that road. We already have a perfectly serviceable hand-rolled
scanner. We just need a tiny trie for recognizing keywords. How should we map
that to code?</p>
<p>The absolute simplest <span name="v8">solution</span> is to use a switch
statement for each node with cases for each branch. We&rsquo;ll start with the root
node and handle the easy keywords.</p>
<aside name="v8">
<p>Simple doesn&rsquo;t mean dumb. The same approach is <a href="https://github.com/v8/v8/blob/e77eebfe3b747fb315bd3baad09bec0953e53e68/src/parsing/scanner.cc#L1643">essentially what V8 does</a>,
and that&rsquo;s currently one of the world&rsquo;s most sophisticated, fastest language
implementations.</p>
</aside>
<div class="codehilite"><pre class="insert-before">static TokenType identifierType() {
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>identifierType</em>()</div>
<pre class="insert">  <span class="k">switch</span> (<span class="i">scanner</span>.<span class="i">start</span>[<span class="n">0</span>]) {
    <span class="k">case</span> <span class="s">&#39;a&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="s">&quot;nd&quot;</span>, <span class="a">TOKEN_AND</span>);
    <span class="k">case</span> <span class="s">&#39;c&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">&quot;lass&quot;</span>, <span class="a">TOKEN_CLASS</span>);
    <span class="k">case</span> <span class="s">&#39;e&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">3</span>, <span class="s">&quot;lse&quot;</span>, <span class="a">TOKEN_ELSE</span>);
    <span class="k">case</span> <span class="s">&#39;i&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">1</span>, <span class="s">&quot;f&quot;</span>, <span class="a">TOKEN_IF</span>);
    <span class="k">case</span> <span class="s">&#39;n&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="s">&quot;il&quot;</span>, <span class="a">TOKEN_NIL</span>);
    <span class="k">case</span> <span class="s">&#39;o&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">1</span>, <span class="s">&quot;r&quot;</span>, <span class="a">TOKEN_OR</span>);
    <span class="k">case</span> <span class="s">&#39;p&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">&quot;rint&quot;</span>, <span class="a">TOKEN_PRINT</span>);
    <span class="k">case</span> <span class="s">&#39;r&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">5</span>, <span class="s">&quot;eturn&quot;</span>, <span class="a">TOKEN_RETURN</span>);
    <span class="k">case</span> <span class="s">&#39;s&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">&quot;uper&quot;</span>, <span class="a">TOKEN_SUPER</span>);
    <span class="k">case</span> <span class="s">&#39;v&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="s">&quot;ar&quot;</span>, <span class="a">TOKEN_VAR</span>);
    <span class="k">case</span> <span class="s">&#39;w&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">&quot;hile&quot;</span>, <span class="a">TOKEN_WHILE</span>);
  }

</pre><pre class="insert-after">  return TOKEN_IDENTIFIER;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>identifierType</em>()</div>

<p>These are the initial letters that correspond to a single keyword. If we see an
&ldquo;s&rdquo;, the only keyword the identifier could possibly be is <code>super</code>. It might not
be, though, so we still need to check the rest of the letters too. In the tree
diagram, this is basically that straight path hanging off the &ldquo;s&rdquo;.</p>
<p>We won&rsquo;t roll a switch for each of those nodes. Instead, we have a utility
function that tests the rest of a potential keyword&rsquo;s lexeme.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br>
add after <em>skipWhitespace</em>()</div>
<pre><span class="k">static</span> <span class="t">TokenType</span> <span class="i">checkKeyword</span>(<span class="t">int</span> <span class="i">start</span>, <span class="t">int</span> <span class="i">length</span>,
    <span class="k">const</span> <span class="t">char</span>* <span class="i">rest</span>, <span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">if</span> (<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span> == <span class="i">start</span> + <span class="i">length</span> &amp;&amp;
      <span class="i">memcmp</span>(<span class="i">scanner</span>.<span class="i">start</span> + <span class="i">start</span>, <span class="i">rest</span>, <span class="i">length</span>) == <span class="n">0</span>) {
    <span class="k">return</span> <span class="i">type</span>;
  }

  <span class="k">return</span> <span class="a">TOKEN_IDENTIFIER</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>

<p>We use this for all of the unbranching paths in the tree. Once we&rsquo;ve found a
prefix that could only be one possible reserved word, we need to verify two
things. The lexeme must be exactly as long as the keyword. If the first letter
is &ldquo;s&rdquo;, the lexeme could still be &ldquo;sup&rdquo; or &ldquo;superb&rdquo;. And the remaining
characters must match exactly<span class="em">&mdash;</span>&ldquo;supar&rdquo; isn&rsquo;t good enough.</p>
<p>If we do have the right number of characters, and they&rsquo;re the ones we want, then
it&rsquo;s a keyword, and we return the associated token type. Otherwise, it must be a
normal identifier.</p>
<p>We have a couple of keywords where the tree branches again after the first
letter. If the lexeme starts with &ldquo;f&rdquo;, it could be <code>false</code>, <code>for</code>, or <code>fun</code>. So
we add another switch for the branches coming off the &ldquo;f&rdquo; node.</p>
<div class="codehilite"><pre class="insert-before">    case 'e': return checkKeyword(1, 3, &quot;lse&quot;, TOKEN_ELSE);
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>identifierType</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="s">&#39;f&#39;</span>:
      <span class="k">if</span> (<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span> &gt; <span class="n">1</span>) {
        <span class="k">switch</span> (<span class="i">scanner</span>.<span class="i">start</span>[<span class="n">1</span>]) {
          <span class="k">case</span> <span class="s">&#39;a&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">3</span>, <span class="s">&quot;lse&quot;</span>, <span class="a">TOKEN_FALSE</span>);
          <span class="k">case</span> <span class="s">&#39;o&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">1</span>, <span class="s">&quot;r&quot;</span>, <span class="a">TOKEN_FOR</span>);
          <span class="k">case</span> <span class="s">&#39;u&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">1</span>, <span class="s">&quot;n&quot;</span>, <span class="a">TOKEN_FUN</span>);
        }
      }
      <span class="k">break</span>;
</pre><pre class="insert-after">    case 'i': return checkKeyword(1, 1, &quot;f&quot;, TOKEN_IF);
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>identifierType</em>()</div>

<p>Before we switch, we need to check that there even <em>is</em> a second letter. &ldquo;f&rdquo; by
itself is a valid identifier too, after all. The other letter that branches is
&ldquo;t&rdquo;.</p>
<div class="codehilite"><pre class="insert-before">    case 's': return checkKeyword(1, 4, &quot;uper&quot;, TOKEN_SUPER);
</pre><div class="source-file"><em>scanner.c</em><br>
in <em>identifierType</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="s">&#39;t&#39;</span>:
      <span class="k">if</span> (<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span> &gt; <span class="n">1</span>) {
        <span class="k">switch</span> (<span class="i">scanner</span>.<span class="i">start</span>[<span class="n">1</span>]) {
          <span class="k">case</span> <span class="s">&#39;h&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">2</span>, <span class="s">&quot;is&quot;</span>, <span class="a">TOKEN_THIS</span>);
          <span class="k">case</span> <span class="s">&#39;r&#39;</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">2</span>, <span class="s">&quot;ue&quot;</span>, <span class="a">TOKEN_TRUE</span>);
        }
      }
      <span class="k">break</span>;
</pre><pre class="insert-after">    case 'v': return checkKeyword(1, 2, &quot;ar&quot;, TOKEN_VAR);
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>identifierType</em>()</div>

<p>That&rsquo;s it. A couple of nested <code>switch</code> statements. Not only is this code <span
name="short">short</span>, but it&rsquo;s very, very fast. It does the minimum amount
of work required to detect a keyword, and bails out as soon as it can tell the
identifier will not be a reserved one.</p>
<p>And with that, our scanner is complete.</p>
<aside name="short">
<p>We sometimes fall into the trap of thinking that performance comes from
complicated data structures, layers of caching, and other fancy optimizations.
But, many times, all that&rsquo;s required is to do less work, and I often find that
writing the simplest code I can is sufficient to accomplish that.</p>
</aside>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Many newer languages support <a href="https://en.wikipedia.org/wiki/String_interpolation"><strong>string interpolation</strong></a>. Inside a
string literal, you have some sort of special delimiters<span class="em">&mdash;</span>most commonly
<code>${</code> at the beginning and <code>}</code> at the end. Between those delimiters, any
expression can appear. When the string literal is executed, the inner
expression is evaluated, converted to a string, and then merged with the
surrounding string literal.</p>
<p>For example, if Lox supported string interpolation, then this<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">drink</span> = <span class="s">&quot;Tea&quot;</span>;
<span class="k">var</span> <span class="i">steep</span> = <span class="n">4</span>;
<span class="k">var</span> <span class="i">cool</span> = <span class="n">2</span>;
<span class="k">print</span> <span class="s">&quot;${drink} will be ready in ${steep + cool} minutes.&quot;</span>;
</pre></div>
<p><span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>would print:</p>
<div class="codehilite"><pre>Tea will be ready in 6 minutes.
</pre></div>
<p>What token types would you define to implement a scanner for string
interpolation? What sequence of tokens would you emit for the above string
literal?</p>
<p>What tokens would you emit for:</p>
<div class="codehilite"><pre>&quot;Nested ${&quot;interpolation?! Are you ${&quot;mad?!&quot;}&quot;}&quot;
</pre></div>
<p>Consider looking at other language implementations that support
interpolation to see how they handle it.</p>
</li>
<li>
<p>Several languages use angle brackets for generics and also have a <code>&gt;&gt;</code> right
shift operator. This led to a classic problem in early versions of C++:</p>
<div class="codehilite"><pre><span class="t">vector</span>&lt;<span class="t">vector</span>&lt;<span class="t">string</span>&gt;&gt; <span class="i">nestedVectors</span>;
</pre></div>
<p>This would produce a compile error because the <code>&gt;&gt;</code> was lexed to a single
right shift token, not two <code>&gt;</code> tokens. Users were forced to avoid this by
putting a space between the closing angle brackets.</p>
<p>Later versions of C++ are smarter and can handle the above code. Java and C#
never had the problem. How do those languages specify and implement this?</p>
</li>
<li>
<p>Many languages, especially later in their evolution, define &ldquo;contextual
keywords&rdquo;. These are identifiers that act like reserved words in some
contexts but can be normal user-defined identifiers in others.</p>
<p>For example, <code>await</code> is a keyword inside an <code>async</code> method in C#, but
in other methods, you can use <code>await</code> as your own identifier.</p>
<p>Name a few contextual keywords from other languages, and the context where
they are meaningful. What are the pros and cons of having contextual
keywords? How would you implement them in your language&rsquo;s front end if you
needed to?</p>
</li>
</ol>
</div>

<footer>
<a href="compiling-expressions.html" class="next">
  Next Chapter: &ldquo;Compiling Expressions&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Compiling Expressions &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Compiling Expressions<small>17</small></a></h3>

<ul>
    <li><a href="#single-pass-compilation"><small>17.1</small> Single-Pass Compilation</a></li>
    <li><a href="#parsing-tokens"><small>17.2</small> Parsing Tokens</a></li>
    <li><a href="#emitting-bytecode"><small>17.3</small> Emitting Bytecode</a></li>
    <li><a href="#parsing-prefix-expressions"><small>17.4</small> Parsing Prefix Expressions</a></li>
    <li><a href="#parsing-infix-expressions"><small>17.5</small> Parsing Infix Expressions</a></li>
    <li><a href="#a-pratt-parser"><small>17.6</small> A Pratt Parser</a></li>
    <li><a href="#dumping-chunks"><small>17.7</small> Dumping Chunks</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>It&#x27;s Just Parsing</a></li>
</ul>


<div class="prev-next">
    <a href="scanning-on-demand.html" title="Scanning on Demand" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="types-of-values.html" title="Types of Values" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="scanning-on-demand.html" title="Scanning on Demand" class="prev">←</a>
<a href="types-of-values.html" title="Types of Values" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Compiling Expressions<small>17</small></a></h3>

<ul>
    <li><a href="#single-pass-compilation"><small>17.1</small> Single-Pass Compilation</a></li>
    <li><a href="#parsing-tokens"><small>17.2</small> Parsing Tokens</a></li>
    <li><a href="#emitting-bytecode"><small>17.3</small> Emitting Bytecode</a></li>
    <li><a href="#parsing-prefix-expressions"><small>17.4</small> Parsing Prefix Expressions</a></li>
    <li><a href="#parsing-infix-expressions"><small>17.5</small> Parsing Infix Expressions</a></li>
    <li><a href="#a-pratt-parser"><small>17.6</small> A Pratt Parser</a></li>
    <li><a href="#dumping-chunks"><small>17.7</small> Dumping Chunks</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>It&#x27;s Just Parsing</a></li>
</ul>


<div class="prev-next">
    <a href="scanning-on-demand.html" title="Scanning on Demand" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="types-of-values.html" title="Types of Values" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">17</div>
  <h1>Compiling Expressions</h1>

<blockquote>
<p>In the middle of the journey of our life I found myself within a dark woods
where the straight way was lost.</p>
<p><cite>Dante Alighieri, <em>Inferno</em></cite></p>
</blockquote>
<p>This chapter is exciting for not one, not two, but <em>three</em> reasons. First, it
provides the final segment of our VM&rsquo;s execution pipeline. Once in place, we can
plumb the user&rsquo;s source code from scanning all the way through to executing it.</p><img src="image/compiling-expressions/pipeline.png" alt="Lowering the 'compiler' section of pipe between 'scanner' and 'VM'." />
<p>Second, we get to write an actual, honest-to-God <em>compiler</em>. It parses source
code and outputs a low-level series of binary instructions. Sure, it&rsquo;s <span
name="wirth">bytecode</span> and not some chip&rsquo;s native instruction set, but
it&rsquo;s way closer to the metal than jlox was. We&rsquo;re about to be real language
hackers.</p>
<aside name="wirth">
<p>Bytecode was good enough for Niklaus Wirth, and no one questions his street
cred.</p>
</aside>
<p><span name="pratt">Third</span> and finally, I get to show you one of my
absolute favorite algorithms: Vaughan Pratt&rsquo;s &ldquo;top-down operator precedence
parsing&rdquo;. It&rsquo;s the most elegant way I know to parse expressions. It gracefully
handles prefix operators, postfix, infix, <em>mixfix</em>, any kind of <em>-fix</em> you got.
It deals with precedence and associativity without breaking a sweat. I love it.</p>
<aside name="pratt">
<p>Pratt parsers are a sort of oral tradition in industry. No compiler or language
book I&rsquo;ve read teaches them. Academia is very focused on generated parsers, and
Pratt&rsquo;s technique is for handwritten ones, so it gets overlooked.</p>
<p>But in production compilers, where hand-rolled parsers are common, you&rsquo;d be
surprised how many people know it. Ask where they learned it, and it&rsquo;s always,
&ldquo;Oh, I worked on this compiler years ago and my coworker said they took it from
this old front end<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>&rdquo;</p>
</aside>
<p>As usual, before we get to the fun stuff, we&rsquo;ve got some preliminaries to work
through. You have to eat your vegetables before you get dessert. First, let&rsquo;s
ditch that temporary scaffolding we wrote for testing the scanner and replace it
with something more useful.</p>
<div class="codehilite"><pre class="insert-before">InterpretResult interpret(const char* source) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>interpret</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="t">Chunk</span> <span class="i">chunk</span>;
  <span class="i">initChunk</span>(&amp;<span class="i">chunk</span>);

  <span class="k">if</span> (!<span class="i">compile</span>(<span class="i">source</span>, &amp;<span class="i">chunk</span>)) {
    <span class="i">freeChunk</span>(&amp;<span class="i">chunk</span>);
    <span class="k">return</span> <span class="a">INTERPRET_COMPILE_ERROR</span>;
  }

  <span class="i">vm</span>.<span class="i">chunk</span> = &amp;<span class="i">chunk</span>;
  <span class="i">vm</span>.<span class="i">ip</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>;

  <span class="t">InterpretResult</span> <span class="i">result</span> = <span class="i">run</span>();

  <span class="i">freeChunk</span>(&amp;<span class="i">chunk</span>);
  <span class="k">return</span> <span class="i">result</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 2 lines</div>

<p>We create a new empty chunk and pass it over to the compiler. The compiler will
take the user&rsquo;s program and fill up the chunk with bytecode. At least, that&rsquo;s
what it will do if the program doesn&rsquo;t have any compile errors. If it does
encounter an error, <code>compile()</code> returns <code>false</code> and we discard the unusable
chunk.</p>
<p>Otherwise, we send the completed chunk over to the VM to be executed. When the
VM finishes, we free the chunk and we&rsquo;re done. As you can see, the signature to
<code>compile()</code> is different now.</p>
<div class="codehilite"><pre class="insert-before">#define clox_compiler_h

</pre><div class="source-file"><em>compiler.h</em><br>
replace 1 line</div>
<pre class="insert"><span class="a">#include &quot;vm.h&quot;</span>

<span class="t">bool</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, replace 1 line</div>

<p>We pass in the chunk where the compiler will write the code, and then
<code>compile()</code> returns whether or not compilation succeeded. We make the same
change to the signature in the implementation.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;scanner.h&quot;

</pre><div class="source-file"><em>compiler.c</em><br>
function <em>compile</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="t">bool</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>) {
</pre><pre class="insert-after">  initScanner(source);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>compile</em>(), replace 1 line</div>

<p>That call to <code>initScanner()</code> is the only line that survives this chapter. Rip
out the temporary code we wrote to test the scanner and replace it with these
three lines:</p>
<div class="codehilite"><pre class="insert-before">  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()<br>
replace 13 lines</div>
<pre class="insert">  <span class="i">advance</span>();
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_EOF</span>, <span class="s">&quot;Expect end of expression.&quot;</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 13 lines</div>

<p>The call to <code>advance()</code> &ldquo;primes the pump&rdquo; on the scanner. We&rsquo;ll see what it does
soon. Then we parse a single expression. We aren&rsquo;t going to do statements yet,
so that&rsquo;s the only subset of the grammar we support. We&rsquo;ll revisit this when we
<a href="global-variables.html">add statements in a few chapters</a>. After we compile the expression, we
should be at the end of the source code, so we check for the sentinel EOF token.</p>
<p>We&rsquo;re going to spend the rest of the chapter making this function work,
especially that little <code>expression()</code> call. Normally, we&rsquo;d dive right into that
function definition and work our way through the implementation from top to
bottom.</p>
<p>This chapter is <span name="blog">different</span>. Pratt&rsquo;s parsing technique is
remarkably simple once you have it all loaded in your head, but it&rsquo;s a little
tricky to break into bite-sized pieces. It&rsquo;s recursive, of course, which is part
of the problem. But it also relies on a big table of data. As we build up the
algorithm, that table grows additional columns.</p>
<aside name="blog">
<p>If this chapter isn&rsquo;t clicking with you and you&rsquo;d like another take on the
concepts, I wrote an article that teaches the same algorithm but using Java and
an object-oriented style: <a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">&ldquo;Pratt Parsing: Expression Parsing Made Easy&rdquo;</a>.</p>
</aside>
<p>I don&rsquo;t want to revisit 40-something lines of code each time we extend the
table. So we&rsquo;re going to work our way into the core of the parser from the
outside and cover all of the surrounding bits before we get to the juicy center.
This will require a little more patience and mental scratch space than most
chapters, but it&rsquo;s the best I could do.</p>
<h2><a href="#single-pass-compilation" id="single-pass-compilation"><small>17&#8202;.&#8202;1</small>Single-Pass Compilation</a></h2>
<p>A compiler has roughly two jobs. It parses the user&rsquo;s source code to understand
what it means. Then it takes that knowledge and outputs low-level instructions
that produce the same semantics. Many languages split those two roles into two
separate <span name="passes">passes</span> in the implementation. A parser
produces an AST<span class="em">&mdash;</span>just like jlox does<span class="em">&mdash;</span>and then a code generator traverses
the AST and outputs target code.</p>
<aside name="passes">
<p>In fact, most sophisticated optimizing compilers have a heck of a lot more than
two passes. Determining not just <em>what</em> optimization passes to have, but how to
order them to squeeze the most performance out of the compiler<span class="em">&mdash;</span>since the
optimizations often interact in complex ways<span class="em">&mdash;</span>is somewhere between an &ldquo;open
area of research&rdquo; and a &ldquo;dark art&rdquo;.</p>
</aside>
<p>In clox, we&rsquo;re taking an old-school approach and merging these two passes into
one. Back in the day, language hackers did this because computers literally
didn&rsquo;t have enough memory to store an entire source file&rsquo;s AST. We&rsquo;re doing it
because it keeps our compiler simpler, which is a real asset when programming in
C.</p>
<p>Single-pass compilers like we&rsquo;re going to build don&rsquo;t work well for all
languages. Since the compiler has only a peephole view into the user&rsquo;s program
while generating code, the language must be designed such that you don&rsquo;t need
much surrounding context to understand a piece of syntax. Fortunately, tiny,
dynamically typed Lox is <span name="lox">well-suited</span> to that.</p>
<aside name="lox">
<p>Not that this should come as much of a surprise. I did design the language
specifically for this book after all.</p><img src="image/compiling-expressions/keyhole.png" alt="Peering through a keyhole at 'var x;'" />
</aside>
<p>What this means in practical terms is that our &ldquo;compiler&rdquo; C module has
functionality you&rsquo;ll recognize from jlox for parsing<span class="em">&mdash;</span>consuming tokens,
matching expected token types, etc. And it also has functions for code gen<span class="em">&mdash;</span>emitting bytecode and adding constants to the destination chunk. (And it means
I&rsquo;ll use &ldquo;parsing&rdquo; and &ldquo;compiling&rdquo; interchangeably throughout this and later
chapters.)</p>
<p>We&rsquo;ll build the parsing and code generation halves first. Then we&rsquo;ll stitch them
together with the code in the middle that uses Pratt&rsquo;s technique to parse Lox&rsquo;s
particular grammar and output the right bytecode.</p>
<h2><a href="#parsing-tokens" id="parsing-tokens"><small>17&#8202;.&#8202;2</small>Parsing Tokens</a></h2>
<p>First up, the front half of the compiler. This function&rsquo;s name should sound
familiar.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;scanner.h&quot;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert">

<span class="k">static</span> <span class="t">void</span> <span class="i">advance</span>() {
  <span class="i">parser</span>.<span class="i">previous</span> = <span class="i">parser</span>.<span class="i">current</span>;

  <span class="k">for</span> (;;) {
    <span class="i">parser</span>.<span class="i">current</span> = <span class="i">scanToken</span>();
    <span class="k">if</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> != <span class="a">TOKEN_ERROR</span>) <span class="k">break</span>;

    <span class="i">errorAtCurrent</span>(<span class="i">parser</span>.<span class="i">current</span>.<span class="i">start</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>Just like in jlox, it steps forward through the token stream. It asks the
scanner for the next token and stores it for later use. Before doing that, it
takes the old <code>current</code> token and stashes that in a <code>previous</code> field. That will
come in handy later so that we can get at the lexeme after we match a token.</p>
<p>The code to read the next token is wrapped in a loop. Remember, clox&rsquo;s scanner
doesn&rsquo;t report lexical errors. Instead, it creates special <em>error tokens</em> and
leaves it up to the parser to report them. We do that here.</p>
<p>We keep looping, reading tokens and reporting the errors, until we hit a
non-error one or reach the end. That way, the rest of the parser sees only valid
tokens. The current and previous token are stored in this struct:</p>
<div class="codehilite"><pre class="insert-before">#include &quot;scanner.h&quot;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Token</span> <span class="i">current</span>;
  <span class="t">Token</span> <span class="i">previous</span>;
} <span class="t">Parser</span>;

<span class="t">Parser</span> <span class="i">parser</span>;
</pre><pre class="insert-after">

static void advance() {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>Like we did in other modules, we have a single global variable of this struct
type so we don&rsquo;t need to pass the state around from function to function in the
compiler.</p>
<h3><a href="#handling-syntax-errors" id="handling-syntax-errors"><small>17&#8202;.&#8202;2&#8202;.&#8202;1</small>Handling syntax errors</a></h3>
<p>If the scanner hands us an error token, we need to actually tell the user. That
happens using this:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">errorAtCurrent</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="i">errorAt</span>(&amp;<span class="i">parser</span>.<span class="i">current</span>, <span class="i">message</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>We pull the location out of the current token in order to tell the user where
the error occurred and forward it to <code>errorAt()</code>. More often, we&rsquo;ll report an
error at the location of the token we just consumed, so we give the shorter name
to this other function:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">error</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="i">errorAt</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>, <span class="i">message</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>The actual work happens here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">errorAt</span>(<span class="t">Token</span>* <span class="i">token</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;[line %d] Error&quot;</span>, <span class="i">token</span>-&gt;<span class="i">line</span>);

  <span class="k">if</span> (<span class="i">token</span>-&gt;<span class="i">type</span> == <span class="a">TOKEN_EOF</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot; at end&quot;</span>);
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">token</span>-&gt;<span class="i">type</span> == <span class="a">TOKEN_ERROR</span>) {
    <span class="c">// Nothing.</span>
  } <span class="k">else</span> {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot; at &#39;%.*s&#39;&quot;</span>, <span class="i">token</span>-&gt;<span class="i">length</span>, <span class="i">token</span>-&gt;<span class="i">start</span>);
  }

  <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;: %s</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">message</span>);
  <span class="i">parser</span>.<span class="i">hadError</span> = <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>First, we print where the error occurred. We try to show the lexeme if it&rsquo;s
human-readable. Then we print the error message itself. After that, we set this
<code>hadError</code> flag. That records whether any errors occurred during compilation.
This field also lives in the parser struct.</p>
<div class="codehilite"><pre class="insert-before">  Token previous;
</pre><div class="source-file"><em>compiler.c</em><br>
in struct <em>Parser</em></div>
<pre class="insert">  <span class="t">bool</span> <span class="i">hadError</span>;
</pre><pre class="insert-after">} Parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Parser</em></div>

<p>Earlier I said that <code>compile()</code> should return <code>false</code> if an error occurred. Now
we can make it do that.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_EOF, &quot;Expect end of expression.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="k">return</span> !<span class="i">parser</span>.<span class="i">hadError</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>I&rsquo;ve got another flag to introduce for error handling. We want to avoid error
cascades. If the user has a mistake in their code and the parser gets confused
about where it is in the grammar, we don&rsquo;t want it to spew out a whole pile of
meaningless knock-on errors after the first one.</p>
<p>We fixed that in jlox using panic mode error recovery. In the Java interpreter,
we threw an exception to unwind out of all of the parser code to a point where
we could skip tokens and resynchronize. We don&rsquo;t have <span
name="setjmp">exceptions</span> in C. Instead, we&rsquo;ll do a little smoke and
mirrors. We add a flag to track whether we&rsquo;re currently in panic mode.</p>
<aside name="setjmp">
<p>There is <code>setjmp()</code> and <code>longjmp()</code>, but I&rsquo;d rather not go there. Those make it
too easy to leak memory, forget to maintain invariants, or otherwise have a Very
Bad Day.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  bool hadError;
</pre><div class="source-file"><em>compiler.c</em><br>
in struct <em>Parser</em></div>
<pre class="insert">  <span class="t">bool</span> <span class="i">panicMode</span>;
</pre><pre class="insert-after">} Parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Parser</em></div>

<p>When an error occurs, we set it.</p>
<div class="codehilite"><pre class="insert-before">static void errorAt(Token* token, const char* message) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>errorAt</em>()</div>
<pre class="insert">  <span class="i">parser</span>.<span class="i">panicMode</span> = <span class="k">true</span>;
</pre><pre class="insert-after">  fprintf(stderr, &quot;[line %d] Error&quot;, token-&gt;line);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>errorAt</em>()</div>

<p>After that, we go ahead and keep compiling as normal as if the error never
occurred. The bytecode will never get executed, so it&rsquo;s harmless to keep on
trucking. The trick is that while the panic mode flag is set, we simply suppress
any other errors that get detected.</p>
<div class="codehilite"><pre class="insert-before">static void errorAt(Token* token, const char* message) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>errorAt</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">panicMode</span>) <span class="k">return</span>;
</pre><pre class="insert-after">  parser.panicMode = true;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>errorAt</em>()</div>

<p>There&rsquo;s a good chance the parser will go off in the weeds, but the user won&rsquo;t
know because the errors all get swallowed. Panic mode ends when the parser
reaches a synchronization point. For Lox, we chose statement boundaries, so when
we later add those to our compiler, we&rsquo;ll clear the flag there.</p>
<p>These new fields need to be initialized.</p>
<div class="codehilite"><pre class="insert-before">  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">

  <span class="i">parser</span>.<span class="i">hadError</span> = <span class="k">false</span>;
  <span class="i">parser</span>.<span class="i">panicMode</span> = <span class="k">false</span>;

</pre><pre class="insert-after">  advance();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>And to display the errors, we need a standard header.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdio.h&gt;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert"><span class="a">#include &lt;stdlib.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>There&rsquo;s one last parsing function, another old friend from jlox.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>advance</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">consume</span>(<span class="t">TokenType</span> <span class="i">type</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> == <span class="i">type</span>) {
    <span class="i">advance</span>();
    <span class="k">return</span>;
  }

  <span class="i">errorAtCurrent</span>(<span class="i">message</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>advance</em>()</div>

<p>It&rsquo;s similar to <code>advance()</code> in that it reads the next token. But it also
validates that the token has an expected type. If not, it reports an error. This
function is the foundation of most syntax errors in the compiler.</p>
<p>OK, that&rsquo;s enough on the front end for now.</p>
<h2><a href="#emitting-bytecode" id="emitting-bytecode"><small>17&#8202;.&#8202;3</small>Emitting Bytecode</a></h2>
<p>After we parse and understand a piece of the user&rsquo;s program, the next step is to
translate that to a series of bytecode instructions. It starts with the easiest
possible step: appending a single byte to the chunk.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>consume</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">emitByte</span>(<span class="t">uint8_t</span> <span class="i">byte</span>) {
  <span class="i">writeChunk</span>(<span class="i">currentChunk</span>(), <span class="i">byte</span>, <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">line</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>consume</em>()</div>

<p>It&rsquo;s hard to believe great things will flow through such a simple function. It
writes the given byte, which may be an opcode or an operand to an instruction.
It sends in the previous token&rsquo;s line information so that runtime errors are
associated with that line.</p>
<p>The chunk that we&rsquo;re writing gets passed into <code>compile()</code>, but it needs to make
its way to <code>emitByte()</code>. To do that, we rely on this intermediary function:</p>
<div class="codehilite"><pre class="insert-before">Parser parser;
</pre><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre class="insert"><span class="t">Chunk</span>* <span class="i">compilingChunk</span>;

<span class="k">static</span> <span class="t">Chunk</span>* <span class="i">currentChunk</span>() {
  <span class="k">return</span> <span class="i">compilingChunk</span>;
}

</pre><pre class="insert-after">static void errorAt(Token* token, const char* message) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>Right now, the chunk pointer is stored in a module-level variable like we store
other global state. Later, when we start compiling user-defined functions, the
notion of &ldquo;current chunk&rdquo; gets more complicated. To avoid having to go back and
change a lot of code, I encapsulate that logic in the <code>currentChunk()</code> function.</p>
<p>We initialize this new module variable before we write any bytecode:</p>
<div class="codehilite"><pre class="insert-before">bool compile(const char* source, Chunk* chunk) {
  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="i">compilingChunk</span> = <span class="i">chunk</span>;
</pre><pre class="insert-after">

  parser.hadError = false;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>Then, at the very end, when we&rsquo;re done compiling the chunk, we wrap things up.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_EOF, &quot;Expect end of expression.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="i">endCompiler</span>();
</pre><pre class="insert-after">  return !parser.hadError;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>That calls this:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitByte</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">endCompiler</span>() {
  <span class="i">emitReturn</span>();
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitByte</em>()</div>

<p>In this chapter, our VM deals only with expressions. When you run clox, it will
parse, compile, and execute a single expression, then print the result. To print
that value, we are temporarily using the <code>OP_RETURN</code> instruction. So we have the
compiler add one of those to the end of the chunk.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitByte</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">emitReturn</span>() {
  <span class="i">emitByte</span>(<span class="a">OP_RETURN</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitByte</em>()</div>

<p>While we&rsquo;re here in the back end we may as well make our lives easier.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitByte</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">emitBytes</span>(<span class="t">uint8_t</span> <span class="i">byte1</span>, <span class="t">uint8_t</span> <span class="i">byte2</span>) {
  <span class="i">emitByte</span>(<span class="i">byte1</span>);
  <span class="i">emitByte</span>(<span class="i">byte2</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitByte</em>()</div>

<p>Over time, we&rsquo;ll have enough cases where we need to write an opcode followed by
a one-byte operand that it&rsquo;s worth defining this convenience function.</p>
<h2><a href="#parsing-prefix-expressions" id="parsing-prefix-expressions"><small>17&#8202;.&#8202;4</small>Parsing Prefix Expressions</a></h2>
<p>We&rsquo;ve assembled our parsing and code generation utility functions. The missing
piece is the code in the middle that connects those together.</p><img src="image/compiling-expressions/mystery.png" alt="Parsing functions on the left, bytecode emitting functions on the right. What goes in the middle?" />
<p>The only step in <code>compile()</code> that we have left to implement is this function:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">expression</span>() {
  <span class="c">// What goes here?</span>
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>We aren&rsquo;t ready to implement every kind of expression in Lox yet. Heck, we don&rsquo;t
even have Booleans. For this chapter, we&rsquo;re only going to worry about four:</p>
<ul>
<li>Number literals: <code>123</code></li>
<li>Parentheses for grouping: <code>(123)</code></li>
<li>Unary negation: <code>-123</code></li>
<li>The Four Horsemen of the Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
</ul>
<p>As we work through the functions to compile each of those kinds of expressions,
we&rsquo;ll also assemble the requirements for the table-driven parser that calls
them.</p>
<h3><a href="#parsers-for-tokens" id="parsers-for-tokens"><small>17&#8202;.&#8202;4&#8202;.&#8202;1</small>Parsers for tokens</a></h3>
<p>For now, let&rsquo;s focus on the Lox expressions that are each only a single token.
In this chapter, that&rsquo;s just number literals, but there will be more later. Here&rsquo;s
how we can compile them:</p>
<p>We map each token type to a different kind of expression. We define a function
for each expression that outputs the appropriate bytecode. Then we build an
array of function pointers. The indexes in the array correspond to the
<code>TokenType</code> enum values, and the function at each index is the code to compile
an expression of that token type.</p>
<p>To compile number literals, we store a pointer to the following function at the
<code>TOKEN_NUMBER</code> index in the array.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">number</span>() {
  <span class="t">double</span> <span class="i">value</span> = <span class="i">strtod</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">start</span>, <span class="a">NULL</span>);
  <span class="i">emitConstant</span>(<span class="i">value</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>We assume the token for the number literal has already been consumed and is
stored in <code>previous</code>. We take that lexeme and use the C standard library to
convert it to a double value. Then we generate the code to load that value using
this function:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitReturn</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">emitConstant</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="i">emitBytes</span>(<span class="a">OP_CONSTANT</span>, <span class="i">makeConstant</span>(<span class="i">value</span>));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitReturn</em>()</div>

<p>First, we add the value to the constant table, then we emit an <code>OP_CONSTANT</code>
instruction that pushes it onto the stack at runtime. To insert an entry in the
constant table, we rely on:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitReturn</em>()</div>
<pre><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">makeConstant</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="t">int</span> <span class="i">constant</span> = <span class="i">addConstant</span>(<span class="i">currentChunk</span>(), <span class="i">value</span>);
  <span class="k">if</span> (<span class="i">constant</span> &gt; <span class="a">UINT8_MAX</span>) {
    <span class="i">error</span>(<span class="s">&quot;Too many constants in one chunk.&quot;</span>);
    <span class="k">return</span> <span class="n">0</span>;
  }

  <span class="k">return</span> (<span class="t">uint8_t</span>)<span class="i">constant</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitReturn</em>()</div>

<p>Most of the work happens in <code>addConstant()</code>, which we defined back in an
<a href="chunks-of-bytecode.html">earlier chapter</a>. That adds the given value to the end of the chunk&rsquo;s
constant table and returns its index. The new function&rsquo;s job is mostly to make
sure we don&rsquo;t have too many constants. Since the <code>OP_CONSTANT</code> instruction uses
a single byte for the index operand, we can store and load only up to <span
name="256">256</span> constants in a chunk.</p>
<aside name="256">
<p>Yes, that limit is pretty low. If this were a full-sized language
implementation, we&rsquo;d want to add another instruction like <code>OP_CONSTANT_16</code> that
stores the index as a two-byte operand so we could handle more constants when
needed.</p>
<p>The code to support that isn&rsquo;t particularly illuminating, so I omitted it from
clox, but you&rsquo;ll want your VMs to scale to larger programs.</p>
</aside>
<p>That&rsquo;s basically all it takes. Provided there is some suitable code that
consumes a <code>TOKEN_NUMBER</code> token, looks up <code>number()</code> in the function pointer
array, and then calls it, we can now compile number literals to bytecode.</p>
<h3><a href="#parentheses-for-grouping" id="parentheses-for-grouping"><small>17&#8202;.&#8202;4&#8202;.&#8202;2</small>Parentheses for grouping</a></h3>
<p>Our as-yet-imaginary array of parsing function pointers would be great if every
expression was only a single token long. Alas, most are longer. However, many
expressions <em>start</em> with a particular token. We call these <em>prefix</em> expressions.
For example, when we&rsquo;re parsing an expression and the current token is <code>(</code>, we
know we must be looking at a parenthesized grouping expression.</p>
<p>It turns out our function pointer array handles those too. The parsing function
for an expression type can consume any additional tokens that it wants to, just
like in a regular recursive descent parser. Here&rsquo;s how parentheses work:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">grouping</span>() {
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after expression.&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>Again, we assume the initial <code>(</code> has already been consumed. We <span
name="recursive">recursively</span> call back into <code>expression()</code> to compile the
expression between the parentheses, then parse the closing <code>)</code> at the end.</p>
<aside name="recursive">
<p>A Pratt parser isn&rsquo;t a recursive <em>descent</em> parser, but it&rsquo;s still recursive.
That&rsquo;s to be expected since the grammar itself is recursive.</p>
</aside>
<p>As far as the back end is concerned, there&rsquo;s literally nothing to a grouping
expression. Its sole function is syntactic<span class="em">&mdash;</span>it lets you insert a
lower-precedence expression where a higher precedence is expected. Thus, it has
no runtime semantics on its own and therefore doesn&rsquo;t emit any bytecode. The
inner call to <code>expression()</code> takes care of generating bytecode for the
expression inside the parentheses.</p>
<h3><a href="#unary-negation" id="unary-negation"><small>17&#8202;.&#8202;4&#8202;.&#8202;3</small>Unary negation</a></h3>
<p>Unary minus is also a prefix expression, so it works with our model too.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>number</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">unary</span>() {
  <span class="t">TokenType</span> <span class="i">operatorType</span> = <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>;

  <span class="c">// Compile the operand.</span>
  <span class="i">expression</span>();

  <span class="c">// Emit the operator instruction.</span>
  <span class="k">switch</span> (<span class="i">operatorType</span>) {
    <span class="k">case</span> <span class="a">TOKEN_MINUS</span>: <span class="i">emitByte</span>(<span class="a">OP_NEGATE</span>); <span class="k">break</span>;
    <span class="k">default</span>: <span class="k">return</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>number</em>()</div>

<p>The leading <code>-</code> token has been consumed and is sitting in <code>parser.previous</code>. We
grab the token type from that to note which unary operator we&rsquo;re dealing with.
It&rsquo;s unnecessary right now, but this will make more sense when we use this same
function to compile the <code>!</code> operator in <a href="types-of-values.html">the next chapter</a>.</p>
<p>As in <code>grouping()</code>, we recursively call <code>expression()</code> to compile the operand.
After that, we emit the bytecode to perform the negation. It might seem a little
weird to write the negate instruction <em>after</em> its operand&rsquo;s bytecode since the
<code>-</code> appears on the left, but think about it in terms of order of execution:</p>
<ol>
<li>
<p>We evaluate the operand first which leaves its value on the stack.</p>
</li>
<li>
<p>Then we pop that value, negate it, and push the result.</p>
</li>
</ol>
<p>So the <code>OP_NEGATE</code> instruction should be emitted <span name="line">last</span>.
This is part of the compiler&rsquo;s job<span class="em">&mdash;</span>parsing the program in the order it
appears in the source code and rearranging it into the order that execution
happens.</p>
<aside name="line">
<p>Emitting the <code>OP_NEGATE</code> instruction after the operands does mean that the
current token when the bytecode is written is <em>not</em> the <code>-</code> token. That mostly
doesn&rsquo;t matter, except that we use that token for the line number to associate
with that instruction.</p>
<p>This means if you have a multi-line negation expression, like:</p>
<div class="codehilite"><pre><span class="k">print</span> -
  <span class="k">true</span>;
</pre></div>
<p>Then the runtime error will be reported on the wrong line. Here, it would show
the error on line 2, even though the <code>-</code> is on line 1. A more robust approach
would be to store the token&rsquo;s line before compiling the operand and then pass
that into <code>emitByte()</code>, but I wanted to keep things simple for the book.</p>
</aside>
<p>There is one problem with this code, though. The <code>expression()</code> function it
calls will parse any expression for the operand, regardless of precedence. Once
we add binary operators and other syntax, that will do the wrong thing.
Consider:</p>
<div class="codehilite"><pre>-<span class="i">a</span>.<span class="i">b</span> + <span class="i">c</span>;
</pre></div>
<p>Here, the operand to <code>-</code> should be just the <code>a.b</code> expression, not the entire
<code>a.b + c</code>. But if <code>unary()</code> calls <code>expression()</code>, the latter will happily chew
through all of the remaining code including the <code>+</code>. It will erroneously treat
the <code>-</code> as lower precedence than the <code>+</code>.</p>
<p>When parsing the operand to unary <code>-</code>, we need to compile only expressions at a
certain precedence level or higher. In jlox&rsquo;s recursive descent parser we
accomplished that by calling into the parsing method for the lowest-precedence
expression we wanted to allow (in this case, <code>call()</code>). Each method for parsing
a specific expression also parsed any expressions of higher precedence too, so
that included the rest of the precedence table.</p>
<p>The parsing functions like <code>number()</code> and <code>unary()</code> here in clox are different.
Each only parses exactly one type of expression. They don&rsquo;t cascade to include
higher-precedence expression types too. We need a different solution, and it
looks like this:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>unary</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">parsePrecedence</span>(<span class="t">Precedence</span> <span class="i">precedence</span>) {
  <span class="c">// What goes here?</span>
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>unary</em>()</div>

<p>This function<span class="em">&mdash;</span>once we implement it<span class="em">&mdash;</span>starts at the current token and parses
any expression at the given precedence level or higher. We have some other setup
to get through before we can write the body of this function, but you can
probably guess that it will use that table of parsing function pointers I&rsquo;ve
been talking about. For now, don&rsquo;t worry too much about how it works. In order
to take the &ldquo;precedence&rdquo; as a parameter, we define it numerically.</p>
<div class="codehilite"><pre class="insert-before">} Parser;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>Parser</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">PREC_NONE</span>,
  <span class="a">PREC_ASSIGNMENT</span>,  <span class="c">// =</span>
  <span class="a">PREC_OR</span>,          <span class="c">// or</span>
  <span class="a">PREC_AND</span>,         <span class="c">// and</span>
  <span class="a">PREC_EQUALITY</span>,    <span class="c">// == !=</span>
  <span class="a">PREC_COMPARISON</span>,  <span class="c">// &lt; &gt; &lt;= &gt;=</span>
  <span class="a">PREC_TERM</span>,        <span class="c">// + -</span>
  <span class="a">PREC_FACTOR</span>,      <span class="c">// * /</span>
  <span class="a">PREC_UNARY</span>,       <span class="c">// ! -</span>
  <span class="a">PREC_CALL</span>,        <span class="c">// . ()</span>
  <span class="a">PREC_PRIMARY</span>
} <span class="t">Precedence</span>;
</pre><pre class="insert-after">

Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>Parser</em></div>

<p>These are all of Lox&rsquo;s precedence levels in order from lowest to highest. Since
C implicitly gives successively larger numbers for enums, this means that
<code>PREC_CALL</code> is numerically larger than <code>PREC_UNARY</code>. For example, say the
compiler is sitting on a chunk of code like:</p>
<div class="codehilite"><pre>-<span class="i">a</span>.<span class="i">b</span> + <span class="i">c</span>
</pre></div>
<p>If we call <code>parsePrecedence(PREC_ASSIGNMENT)</code>, then it will parse the entire
expression because <code>+</code> has higher precedence than assignment. If instead we
call <code>parsePrecedence(PREC_UNARY)</code>, it will compile the <code>-a.b</code> and stop there.
It doesn&rsquo;t keep going through the <code>+</code> because the addition has lower precedence
than unary operators.</p>
<p>With this function in hand, it&rsquo;s a snap to fill in the missing body for
<code>expression()</code>.</p>
<div class="codehilite"><pre class="insert-before">static void expression() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>expression</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">parsePrecedence</span>(<span class="a">PREC_ASSIGNMENT</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>expression</em>(), replace 1 line</div>

<p>We simply parse the lowest precedence level, which subsumes all of the
higher-precedence expressions too. Now, to compile the operand for a unary
expression, we call this new function and limit it to the appropriate level:</p>
<div class="codehilite"><pre class="insert-before">  // Compile the operand.
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>unary</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">parsePrecedence</span>(<span class="a">PREC_UNARY</span>);
</pre><pre class="insert-after">

  // Emit the operator instruction.
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>unary</em>(), replace 1 line</div>

<p>We use the unary operator&rsquo;s own <code>PREC_UNARY</code> precedence to permit <span
name="useful">nested</span> unary expressions like <code>!!doubleNegative</code>. Since
unary operators have pretty high precedence, that correctly excludes things like
binary operators. Speaking of which<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<aside name="useful">
<p>Not that nesting unary expressions is particularly useful in Lox. But other
languages let you do it, so we do too.</p>
</aside>
<h2><a href="#parsing-infix-expressions" id="parsing-infix-expressions"><small>17&#8202;.&#8202;5</small>Parsing Infix Expressions</a></h2>
<p>Binary operators are different from the previous expressions because they are
<em>infix</em>. With the other expressions, we know what we are parsing from the very
first token. With infix expressions, we don&rsquo;t know we&rsquo;re in the middle of a
binary operator until <em>after</em> we&rsquo;ve parsed its left operand and then stumbled
onto the operator token in the middle.</p>
<p>Here&rsquo;s an example:</p>
<div class="codehilite"><pre><span class="n">1</span> + <span class="n">2</span>
</pre></div>
<p>Let&rsquo;s walk through trying to compile it with what we know so far:</p>
<ol>
<li>
<p>We call <code>expression()</code>. That in turn calls
<code>parsePrecedence(PREC_ASSIGNMENT)</code>.</p>
</li>
<li>
<p>That function (once we implement it) sees the leading number token and
recognizes it is parsing a number literal. It hands off control to
<code>number()</code>.</p>
</li>
<li>
<p><code>number()</code> creates a constant, emits an <code>OP_CONSTANT</code>, and returns back to
<code>parsePrecedence()</code>.</p>
</li>
</ol>
<p>Now what? The call to <code>parsePrecedence()</code> should consume the entire addition
expression, so it needs to keep going somehow. Fortunately, the parser is right
where we need it to be. Now that we&rsquo;ve compiled the leading number expression,
the next token is <code>+</code>. That&rsquo;s the exact token that <code>parsePrecedence()</code> needs to
detect that we&rsquo;re in the middle of an infix expression and to realize that the
expression we already compiled is actually an operand to that.</p>
<p>So this hypothetical array of function pointers doesn&rsquo;t just list functions to
parse expressions that start with a given token. Instead, it&rsquo;s a <em>table</em> of
function pointers. One column associates prefix parser functions with token
types. The second column associates infix parser functions with token types.</p>
<p>The function we will use as the infix parser for <code>TOKEN_PLUS</code>, <code>TOKEN_MINUS</code>,
<code>TOKEN_STAR</code>, and <code>TOKEN_SLASH</code> is this:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">binary</span>() {
  <span class="t">TokenType</span> <span class="i">operatorType</span> = <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>;
  <span class="t">ParseRule</span>* <span class="i">rule</span> = <span class="i">getRule</span>(<span class="i">operatorType</span>);
  <span class="i">parsePrecedence</span>((<span class="t">Precedence</span>)(<span class="i">rule</span>-&gt;<span class="i">precedence</span> + <span class="n">1</span>));

  <span class="k">switch</span> (<span class="i">operatorType</span>) {
    <span class="k">case</span> <span class="a">TOKEN_PLUS</span>:          <span class="i">emitByte</span>(<span class="a">OP_ADD</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_MINUS</span>:         <span class="i">emitByte</span>(<span class="a">OP_SUBTRACT</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_STAR</span>:          <span class="i">emitByte</span>(<span class="a">OP_MULTIPLY</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_SLASH</span>:         <span class="i">emitByte</span>(<span class="a">OP_DIVIDE</span>); <span class="k">break</span>;
    <span class="k">default</span>: <span class="k">return</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>When a prefix parser function is called, the leading token has already been
consumed. An infix parser function is even more <em>in medias res</em><span class="em">&mdash;</span>the entire
left-hand operand expression has already been compiled and the subsequent infix
operator consumed.</p>
<p>The fact that the left operand gets compiled first works out fine. It means at
runtime, that code gets executed first. When it runs, the value it produces will
end up on the stack. That&rsquo;s right where the infix operator is going to need it.</p>
<p>Then we come here to <code>binary()</code> to handle the rest of the arithmetic operators.
This function compiles the right operand, much like how <code>unary()</code> compiles its
own trailing operand. Finally, it emits the bytecode instruction that performs
the binary operation.</p>
<p>When run, the VM will execute the left and right operand code, in that order,
leaving their values on the stack. Then it executes the instruction for the
operator. That pops the two values, computes the operation, and pushes the
result.</p>
<p>The code that probably caught your eye here is that <code>getRule()</code> line. When we
parse the right-hand operand, we again need to worry about precedence. Take an
expression like:</p>
<div class="codehilite"><pre><span class="n">2</span> * <span class="n">3</span> + <span class="n">4</span>
</pre></div>
<p>When we parse the right operand of the <code>*</code> expression, we need to just capture
<code>3</code>, and not <code>3 + 4</code>, because <code>+</code> is lower precedence than <code>*</code>. We could define
a separate function for each binary operator. Each would call
<code>parsePrecedence()</code> and pass in the correct precedence level for its operand.</p>
<p>But that&rsquo;s kind of tedious. Each binary operator&rsquo;s right-hand operand precedence
is one level <span name="higher">higher</span> than its own. We can look that up
dynamically with this <code>getRule()</code> thing we&rsquo;ll get to soon. Using that, we call
<code>parsePrecedence()</code> with one level higher than this operator&rsquo;s level.</p>
<aside name="higher">
<p>We use one <em>higher</em> level of precedence for the right operand because the binary
operators are left-associative. Given a series of the <em>same</em> operator, like:</p>
<div class="codehilite"><pre><span class="n">1</span> + <span class="n">2</span> + <span class="n">3</span> + <span class="n">4</span>
</pre></div>
<p>We want to parse it like:</p>
<div class="codehilite"><pre>((<span class="n">1</span> + <span class="n">2</span>) + <span class="n">3</span>) + <span class="n">4</span>
</pre></div>
<p>Thus, when parsing the right-hand operand to the first <code>+</code>, we want to consume
the <code>2</code>, but not the rest, so we use one level above <code>+</code>&rsquo;s precedence. But if
our operator was <em>right</em>-associative, this would be wrong. Given:</p>
<div class="codehilite"><pre><span class="i">a</span> = <span class="i">b</span> = <span class="i">c</span> = <span class="i">d</span>
</pre></div>
<p>Since assignment is right-associative, we want to parse it as:</p>
<div class="codehilite"><pre><span class="i">a</span> = (<span class="i">b</span> = (<span class="i">c</span> = <span class="i">d</span>))
</pre></div>
<p>To enable that, we would call <code>parsePrecedence()</code> with the <em>same</em> precedence as
the current operator.</p>
</aside>
<p>This way, we can use a single <code>binary()</code> function for all binary operators even
though they have different precedences.</p>
<h2><a href="#a-pratt-parser" id="a-pratt-parser"><small>17&#8202;.&#8202;6</small>A Pratt Parser</a></h2>
<p>We now have all of the pieces and parts of the compiler laid out. We have a
function for each grammar production: <code>number()</code>, <code>grouping()</code>, <code>unary()</code>, and
<code>binary()</code>. We still need to implement <code>parsePrecedence()</code>, and <code>getRule()</code>. We
also know we need a table that, given a token type, lets us find</p>
<ul>
<li>
<p>the function to compile a prefix expression starting with a token of that
type,</p>
</li>
<li>
<p>the function to compile an infix expression whose left operand is followed
by a token of that type, and</p>
</li>
<li>
<p>the precedence of an <span name="prefix">infix</span> expression that uses
that token as an operator.</p>
</li>
</ul>
<aside name="prefix">
<p>We don&rsquo;t need to track the precedence of the <em>prefix</em> expression starting with a
given token because all prefix operators in Lox have the same precedence.</p>
</aside>
<p>We wrap these three properties in a little struct which represents a single row
in the parser table.</p>
<div class="codehilite"><pre class="insert-before">} Precedence;
</pre><div class="source-file"><em>compiler.c</em><br>
add after enum <em>Precedence</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">ParseFn</span> <span class="i">prefix</span>;
  <span class="t">ParseFn</span> <span class="i">infix</span>;
  <span class="t">Precedence</span> <span class="i">precedence</span>;
} <span class="t">ParseRule</span>;
</pre><pre class="insert-after">

Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>Precedence</em></div>

<p>That ParseFn type is a simple <span name="typedef">typedef</span> for a function
type that takes no arguments and returns nothing.</p>
<aside name="typedef" class="bottom">
<p>C&rsquo;s syntax for function pointer types is so bad that I always hide it behind a
typedef. I understand the intent behind the syntax<span class="em">&mdash;</span>the whole &ldquo;declaration
reflects use&rdquo; thing<span class="em">&mdash;</span>but I think it was a failed syntactic experiment.</p>
</aside>
<div class="codehilite"><pre class="insert-before">} Precedence;
</pre><div class="source-file"><em>compiler.c</em><br>
add after enum <em>Precedence</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="t">void</span> (*<span class="t">ParseFn</span>)();
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>Precedence</em></div>

<p>The table that drives our whole parser is an array of ParseRules. We&rsquo;ve been
talking about it forever, and finally you get to see it.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>unary</em>()</div>
<pre><span class="t">ParseRule</span> <span class="i">rules</span>[] = {
  [<span class="a">TOKEN_LEFT_PAREN</span>]    = {<span class="i">grouping</span>, <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_RIGHT_PAREN</span>]   = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_LEFT_BRACE</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},<span name="big"> </span>
  [<span class="a">TOKEN_RIGHT_BRACE</span>]   = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_COMMA</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_DOT</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_MINUS</span>]         = {<span class="i">unary</span>,    <span class="i">binary</span>, <span class="a">PREC_TERM</span>},
  [<span class="a">TOKEN_PLUS</span>]          = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_TERM</span>},
  [<span class="a">TOKEN_SEMICOLON</span>]     = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_SLASH</span>]         = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_FACTOR</span>},
  [<span class="a">TOKEN_STAR</span>]          = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_FACTOR</span>},
  [<span class="a">TOKEN_BANG</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_BANG_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_EQUAL</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_EQUAL_EQUAL</span>]   = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_GREATER</span>]       = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_GREATER_EQUAL</span>] = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_LESS</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_LESS_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_IDENTIFIER</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_STRING</span>]        = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_NUMBER</span>]        = {<span class="i">number</span>,   <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_AND</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_CLASS</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_ELSE</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_FALSE</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_FOR</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_FUN</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_IF</span>]            = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_NIL</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_OR</span>]            = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_PRINT</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_RETURN</span>]        = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_SUPER</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_THIS</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_TRUE</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_VAR</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_WHILE</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_ERROR</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_EOF</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
};
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>unary</em>()</div>

<aside name="big">
<p>See what I mean about not wanting to revisit the table each time we needed a new
column? It&rsquo;s a beast.</p>
<p>If you haven&rsquo;t seen the <code>[TOKEN_DOT] =</code> syntax in a C array literal, that is
C99&rsquo;s designated initializer syntax. It&rsquo;s clearer than having to count array
indexes by hand.</p>
</aside>
<p>You can see how <code>grouping</code> and <code>unary</code> are slotted into the prefix parser column
for their respective token types. In the next column, <code>binary</code> is wired up to
the four arithmetic infix operators. Those infix operators also have their
precedences set in the last column.</p>
<p>Aside from those, the rest of the table is full of <code>NULL</code> and <code>PREC_NONE</code>. Most
of those empty cells are because there is no expression associated with those
tokens. You can&rsquo;t start an expression with, say, <code>else</code>, and <code>}</code> would make for
a pretty confusing infix operator.</p>
<p>But, also, we haven&rsquo;t filled in the entire grammar yet. In later chapters, as we
add new expression types, some of these slots will get functions in them. One of
the things I like about this approach to parsing is that it makes it very easy
to see which tokens are in use by the grammar and which are available.</p>
<p>Now that we have the table, we are finally ready to write the code that uses it.
This is where our Pratt parser comes to life. The easiest function to define is
<code>getRule()</code>.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>parsePrecedence</em>()</div>
<pre><span class="k">static</span> <span class="t">ParseRule</span>* <span class="i">getRule</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">return</span> &amp;<span class="i">rules</span>[<span class="i">type</span>];
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parsePrecedence</em>()</div>

<p>It simply returns the rule at the given index. It&rsquo;s called by <code>binary()</code> to look
up the precedence of the current operator. This function exists solely to handle
a declaration cycle in the C code. <code>binary()</code> is defined <em>before</em> the rules
table so that the table can store a pointer to it. That means the body of
<code>binary()</code> cannot access the table directly.</p>
<p>Instead, we wrap the lookup in a function. That lets us forward declare
<code>getRule()</code> before the definition of <code>binary()</code>, and <span
name="forward">then</span> <em>define</em> <code>getRule()</code> after the table. We&rsquo;ll need a
couple of other forward declarations to handle the fact that our grammar is
recursive, so let&rsquo;s get them all out of the way.</p>
<aside name="forward">
<p>This is what happens when you write your VM in a language that was designed to
be compiled on a PDP-11.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  emitReturn();
}
</pre><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre class="insert">

<span class="k">static</span> <span class="t">void</span> <span class="i">expression</span>();
<span class="k">static</span> <span class="t">ParseRule</span>* <span class="i">getRule</span>(<span class="t">TokenType</span> <span class="i">type</span>);
<span class="k">static</span> <span class="t">void</span> <span class="i">parsePrecedence</span>(<span class="t">Precedence</span> <span class="i">precedence</span>);

</pre><pre class="insert-after">static void binary() {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>If you&rsquo;re following along and implementing clox yourself, pay close attention to
the little annotations that tell you where to put these code snippets. Don&rsquo;t
worry, though, if you get it wrong, the C compiler will be happy to tell you.</p>
<h3><a href="#parsing-with-precedence" id="parsing-with-precedence"><small>17&#8202;.&#8202;6&#8202;.&#8202;1</small>Parsing with precedence</a></h3>
<p>Now we&rsquo;re getting to the fun stuff. The maestro that orchestrates all of the
parsing functions we&rsquo;ve defined is <code>parsePrecedence()</code>. Let&rsquo;s start with parsing
prefix expressions.</p>
<div class="codehilite"><pre class="insert-before">static void parsePrecedence(Precedence precedence) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parsePrecedence</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">advance</span>();
  <span class="t">ParseFn</span> <span class="i">prefixRule</span> = <span class="i">getRule</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>)-&gt;<span class="i">prefix</span>;
  <span class="k">if</span> (<span class="i">prefixRule</span> == <span class="a">NULL</span>) {
    <span class="i">error</span>(<span class="s">&quot;Expect expression.&quot;</span>);
    <span class="k">return</span>;
  }

  <span class="i">prefixRule</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>(), replace 1 line</div>

<p>We read the next token and look up the corresponding ParseRule. If there is no
prefix parser, then the token must be a syntax error. We report that and return
to the caller.</p>
<p>Otherwise, we call that prefix parse function and let it do its thing. That
prefix parser compiles the rest of the prefix expression, consuming any other
tokens it needs, and returns back here. Infix expressions are where it gets
interesting since precedence comes into play. The implementation is remarkably
simple.</p>
<div class="codehilite"><pre class="insert-before">  prefixRule();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parsePrecedence</em>()</div>
<pre class="insert">

  <span class="k">while</span> (<span class="i">precedence</span> &lt;= <span class="i">getRule</span>(<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span>)-&gt;<span class="i">precedence</span>) {
    <span class="i">advance</span>();
    <span class="t">ParseFn</span> <span class="i">infixRule</span> = <span class="i">getRule</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>)-&gt;<span class="i">infix</span>;
    <span class="i">infixRule</span>();
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>()</div>

<p>That&rsquo;s the whole thing. Really. Here&rsquo;s how the entire function works: At the
beginning of <code>parsePrecedence()</code>, we look up a prefix parser for the current
token. The first token is <em>always</em> going to belong to some kind of prefix
expression, by definition. It may turn out to be nested as an operand inside one
or more infix expressions, but as you read the code from left to right, the
first token you hit always belongs to a prefix expression.</p>
<p>After parsing that, which may consume more tokens, the prefix expression is
done. Now we look for an infix parser for the next token. If we find one, it
means the prefix expression we already compiled might be an operand for it. But
only if the call to <code>parsePrecedence()</code> has a <code>precedence</code> that is low enough to
permit that infix operator.</p>
<p>If the next token is too low precedence, or isn&rsquo;t an infix operator at all,
we&rsquo;re done. We&rsquo;ve parsed as much expression as we can. Otherwise, we consume the
operator and hand off control to the infix parser we found. It consumes whatever
other tokens it needs (usually the right operand) and returns back to
<code>parsePrecedence()</code>. Then we loop back around and see if the <em>next</em> token is
also a valid infix operator that can take the entire preceding expression as its
operand. We keep looping like that, crunching through infix operators and their
operands until we hit a token that isn&rsquo;t an infix operator or is too low
precedence and stop.</p>
<p>That&rsquo;s a lot of prose, but if you really want to mind meld with Vaughan Pratt
and fully understand the algorithm, step through the parser in your debugger as
it works through some expressions. Maybe a picture will help. There&rsquo;s only a
handful of functions, but they are marvelously intertwined:</p>
<p><span name="connections"></span></p>
<p><img src="image/compiling-expressions/connections.png" alt="The various parsing
functions and how they call each other." /></p>
<aside name="connections">
<p>The <img src="image/compiling-expressions/calls.png" alt="A solid arrow."
class="arrow" /> arrow connects a function to another function it directly
calls. The <img src="image/compiling-expressions/points-to.png" alt="An open
arrow." class="arrow" /> arrow shows the table&rsquo;s pointers to the parsing
functions.</p>
</aside>
<p>Later, we&rsquo;ll need to tweak the code in this chapter to handle assignment. But,
otherwise, what we wrote covers all of our expression compiling needs for the
rest of the book. We&rsquo;ll plug additional parsing functions into the table when we
add new kinds of expressions, but <code>parsePrecedence()</code> is complete.</p>
<h2><a href="#dumping-chunks" id="dumping-chunks"><small>17&#8202;.&#8202;7</small>Dumping Chunks</a></h2>
<p>While we&rsquo;re here in the core of our compiler, we should put in some
instrumentation. To help debug the generated bytecode, we&rsquo;ll add support for
dumping the chunk once the compiler finishes. We had some temporary logging
earlier when we hand-authored the chunk. Now we&rsquo;ll put in some real code so that
we can enable it whenever we want.</p>
<p>Since this isn&rsquo;t for end users, we hide it behind a flag.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdint.h&gt;

</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert"><span class="a">#define DEBUG_PRINT_CODE</span>
</pre><pre class="insert-after">#define DEBUG_TRACE_EXECUTION
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>When that flag is defined, we use our existing &ldquo;debug&rdquo; module to print out the
chunk&rsquo;s bytecode.</p>
<div class="codehilite"><pre class="insert-before">  emitReturn();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endCompiler</em>()</div>
<pre class="insert"><span class="a">#ifdef DEBUG_PRINT_CODE</span>
  <span class="k">if</span> (!<span class="i">parser</span>.<span class="i">hadError</span>) {
    <span class="i">disassembleChunk</span>(<span class="i">currentChunk</span>(), <span class="s">&quot;code&quot;</span>);
  }
<span class="a">#endif</span>
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>

<p>We do this only if the code was free of errors. After a syntax error, the
compiler keeps on going but it&rsquo;s in kind of a weird state and might produce
broken code. That&rsquo;s harmless because it won&rsquo;t get executed, but we&rsquo;ll just
confuse ourselves if we try to read it.</p>
<p>Finally, to access <code>disassembleChunk()</code>, we need to include its header.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;scanner.h&quot;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert">

<span class="a">#ifdef DEBUG_PRINT_CODE</span>
<span class="a">#include &quot;debug.h&quot;</span>
<span class="a">#endif</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>We made it! This was the last major section to install in our VM&rsquo;s compilation
and execution pipeline. Our interpreter doesn&rsquo;t <em>look</em> like much, but inside it
is scanning, parsing, compiling to bytecode, and executing.</p>
<p>Fire up the VM and type in an expression. If we did everything right, it should
calculate and print the result. We now have a very over-engineered arithmetic
calculator. We have a lot of language features to add in the coming chapters,
but the foundation is in place.</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>To really understand the parser, you need to see how execution threads
through the interesting parsing functions<span class="em">&mdash;</span><code>parsePrecedence()</code> and the
parser functions stored in the table. Take this (strange) expression:</p>
<div class="codehilite"><pre>(-<span class="n">1</span> + <span class="n">2</span>) * <span class="n">3</span> - -<span class="n">4</span>
</pre></div>
<p>Write a trace of how those functions are called. Show the order they are
called, which calls which, and the arguments passed to them.</p>
</li>
<li>
<p>The ParseRule row for <code>TOKEN_MINUS</code> has both prefix and infix function
pointers. That&rsquo;s because <code>-</code> is both a prefix operator (unary negation) and
an infix one (subtraction).</p>
<p>In the full Lox language, what other tokens can be used in both prefix and
infix positions? What about in C or in another language of your choice?</p>
</li>
<li>
<p>You might be wondering about complex &ldquo;mixfix&rdquo; expressions that have more
than two operands separated by tokens. C&rsquo;s conditional or &ldquo;ternary&rdquo;
operator, <code>?:</code>, is a widely known one.</p>
<p>Add support for that operator to the compiler. You don&rsquo;t have to generate
any bytecode, just show how you would hook it up to the parser and handle
the operands.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: It&rsquo;s Just Parsing</a></h2>
<p>I&rsquo;m going to make a claim here that will be unpopular with some compiler and
language people. It&rsquo;s OK if you don&rsquo;t agree. Personally, I learn more from
strongly stated opinions that I disagree with than I do from several pages of
qualifiers and equivocation. My claim is that <em>parsing doesn&rsquo;t matter</em>.</p>
<p>Over the years, many programming language people, especially in academia, have
gotten <em>really</em> into parsers and taken them very seriously. Initially, it was
the compiler folks who got into <span name="yacc">compiler-compilers</span>,
LALR, and other stuff like that. The first half of the dragon book is a long
love letter to the wonders of parser generators.</p>
<aside name="yacc">
<p>All of us suffer from the vice of &ldquo;when all you have is a hammer, everything
looks like a nail&rdquo;, but perhaps none so visibly as compiler people. You wouldn&rsquo;t
believe the breadth of software problems that miraculously seem to require a new
little language in their solution as soon as you ask a compiler hacker for help.</p>
<p>Yacc and other compiler-compilers are the most delightfully recursive example.
&ldquo;Wow, writing compilers is a chore. I know, let&rsquo;s write a compiler to write our
compiler for us.&rdquo;</p>
<p>For the record, I don&rsquo;t claim immunity to this affliction.</p>
</aside>
<p>Later, the functional programming folks got into parser combinators, packrat
parsers, and other sorts of things. Because, obviously, if you give a functional
programmer a problem, the first thing they&rsquo;ll do is whip out a pocketful of
higher-order functions.</p>
<p>Over in math and algorithm analysis land, there is a long legacy of research
into proving time and memory usage for various parsing techniques, transforming
parsing problems into other problems and back, and assigning complexity classes
to different grammars.</p>
<p>At one level, this stuff is important. If you&rsquo;re implementing a language, you
want some assurance that your parser won&rsquo;t go exponential and take 7,000 years
to parse a weird edge case in the grammar. Parser theory gives you that bound.
As an intellectual exercise, learning about parsing techniques is also fun and
rewarding.</p>
<p>But if your goal is just to implement a language and get it in front of users,
almost all of that stuff doesn&rsquo;t matter. It&rsquo;s really easy to get worked up by
the enthusiasm of the people who <em>are</em> into it and think that your front end
<em>needs</em> some whiz-bang generated combinator-parser-factory thing. I&rsquo;ve seen
people burn tons of time writing and rewriting their parser using whatever
today&rsquo;s hot library or technique is.</p>
<p>That&rsquo;s time that doesn&rsquo;t add any value to your user&rsquo;s life. If you&rsquo;re just
trying to get your parser done, pick one of the bog-standard techniques, use it,
and move on. Recursive descent, Pratt parsing, and the popular parser generators
like ANTLR or Bison are all fine.</p>
<p>Take the extra time you saved not rewriting your parsing code and spend it
improving the compile error messages your compiler shows users. Good error
handling and reporting is more valuable to users than almost anything else you
can put time into in the front end.</p>
</div>

<footer>
<a href="types-of-values.html" class="next">
  Next Chapter: &ldquo;Types of Values&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Types of Values &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Types of Values<small>18</small></a></h3>

<ul>
    <li><a href="#tagged-unions"><small>18.1</small> Tagged Unions</a></li>
    <li><a href="#lox-values-and-c-values"><small>18.2</small> Lox Values and C Values</a></li>
    <li><a href="#dynamically-typed-numbers"><small>18.3</small> Dynamically Typed Numbers</a></li>
    <li><a href="#two-new-types"><small>18.4</small> Two New Types</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="compiling-expressions.html" title="Compiling Expressions" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="strings.html" title="Strings" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="compiling-expressions.html" title="Compiling Expressions" class="prev">←</a>
<a href="strings.html" title="Strings" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Types of Values<small>18</small></a></h3>

<ul>
    <li><a href="#tagged-unions"><small>18.1</small> Tagged Unions</a></li>
    <li><a href="#lox-values-and-c-values"><small>18.2</small> Lox Values and C Values</a></li>
    <li><a href="#dynamically-typed-numbers"><small>18.3</small> Dynamically Typed Numbers</a></li>
    <li><a href="#two-new-types"><small>18.4</small> Two New Types</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="compiling-expressions.html" title="Compiling Expressions" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="strings.html" title="Strings" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">18</div>
  <h1>Types of Values</h1>

<blockquote>
<p>When you are a Bear of Very Little Brain, and you Think of Things, you find
sometimes that a Thing which seemed very Thingish inside you is quite
different when it gets out into the open and has other people looking at it.</p>
<p><cite>A. A. Milne, <em>Winnie-the-Pooh</em></cite></p>
</blockquote>
<p>The past few chapters were huge, packed full of complex techniques and pages of
code. In this chapter, there&rsquo;s only one new concept to learn and a scattering of
straightforward code. You&rsquo;ve earned a respite.</p>
<p>Lox is <span name="unityped">dynamically</span> typed. A single variable can
hold a Boolean, number, or string at different points in time. At least, that&rsquo;s
the idea. Right now, in clox, all values are numbers. By the end of the chapter,
it will also support Booleans and <code>nil</code>. While those aren&rsquo;t super interesting,
they force us to figure out how our value representation can dynamically handle
different types.</p>
<aside name="unityped">
<p>There is a third category next to statically typed and dynamically typed:
<strong>unityped</strong>. In that paradigm, all variables have a single type, usually a
machine register integer. Unityped languages aren&rsquo;t common today, but some
Forths and BCPL, the language that inspired C, worked like this.</p>
<p>As of this moment, clox is unityped.</p>
</aside>
<h2><a href="#tagged-unions" id="tagged-unions"><small>18&#8202;.&#8202;1</small>Tagged Unions</a></h2>
<p>The nice thing about working in C is that we can build our data structures from
the raw bits up. The bad thing is that we <em>have</em> to do that. C doesn&rsquo;t give you
much for free at compile time and even less at runtime. As far as C is
concerned, the universe is an undifferentiated array of bytes. It&rsquo;s up to us to
decide how many of those bytes to use and what they mean.</p>
<p>In order to choose a value representation, we need to answer two key questions:</p>
<ol>
<li>
<p><strong>How do we represent the type of a value?</strong> If you try to, say, multiply a
number by <code>true</code>, we need to detect that error at runtime and report it. In
order to do that, we need to be able to tell what a value&rsquo;s type is.</p>
</li>
<li>
<p><strong>How do we store the value itself?</strong> We need to not only be able to tell
that three is a number, but that it&rsquo;s different from the number four. I
know, seems obvious, right? But we&rsquo;re operating at a level where it&rsquo;s good
to spell these things out.</p>
</li>
</ol>
<p>Since we&rsquo;re not just designing this language but building it ourselves, when
answering these two questions we also have to keep in mind the implementer&rsquo;s
eternal quest: to do it <em>efficiently</em>.</p>
<p>Language hackers over the years have come up with a variety of clever ways to
pack the above information into as few bits as possible. For now, we&rsquo;ll start
with the simplest, classic solution: a <strong>tagged union</strong>. A value contains two
parts: a type &ldquo;tag&rdquo;, and a payload for the actual value. To store the value&rsquo;s
type, we define an enum for each kind of value the VM supports.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;

</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">VAL_BOOL</span>,
  <span class="a">VAL_NIL</span>,<span name="user-types"> </span>
  <span class="a">VAL_NUMBER</span>,
} <span class="t">ValueType</span>;

</pre><pre class="insert-after">typedef double Value;
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<aside name="user-types">
<p>The cases here cover each kind of value that has <em>built-in support in the VM</em>.
When we get to adding classes to the language, each class the user defines
doesn&rsquo;t need its own entry in this enum. As far as the VM is concerned, every
instance of a class is the same type: &ldquo;instance&rdquo;.</p>
<p>In other words, this is the VM&rsquo;s notion of &ldquo;type&rdquo;, not the user&rsquo;s.</p>
</aside>
<p>For now, we have only a couple of cases, but this will grow as we add strings,
functions, and classes to clox. In addition to the type, we also need to store
the data for the value<span class="em">&mdash;</span>the <code>double</code> for a number, <code>true</code> or <code>false</code> for a
Boolean. We could define a struct with fields for each possible type.</p><img src="image/types-of-values/struct.png" alt="A struct with two fields laid next to each other in memory." />
<p>But this is a waste of memory. A value can&rsquo;t simultaneously be both a number and
a Boolean. So at any point in time, only one of those fields will be used. C
lets you optimize this by defining a <span name="sum">union</span>. A union
looks like a struct except that all of its fields overlap in memory.</p>
<aside name="sum">
<p>If you&rsquo;re familiar with a language in the ML family, structs and unions in C
roughly mirror the difference between product and sum types, between tuples
and algebraic data types.</p>
</aside><img src="image/types-of-values/union.png" alt="A union with two fields overlapping in memory." />
<p>The size of a union is the size of its largest field. Since the fields all reuse
the same bits, you have to be very careful when working with them. If you store
data using one field and then access it using <span
name="reinterpret">another</span>, you will reinterpret what the underlying bits
mean.</p>
<aside name="reinterpret">
<p>Using a union to interpret bits as different types is the quintessence of C. It
opens up a number of clever optimizations and lets you slice and dice each byte
of memory in ways that memory-safe languages disallow. But it is also wildly
unsafe and will happily saw your fingers off if you don&rsquo;t watch out.</p>
</aside>
<p>As the name &ldquo;tagged union&rdquo; implies, our new value representation combines these
two parts into a single struct.</p>
<div class="codehilite"><pre class="insert-before">} ValueType;

</pre><div class="source-file"><em>value.h</em><br>
add after enum <em>ValueType</em><br>
replace 1 line</div>
<pre class="insert"><span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">ValueType</span> <span class="i">type</span>;
  <span class="k">union</span> {
    <span class="t">bool</span> <span class="i">boolean</span>;
    <span class="t">double</span> <span class="i">number</span>;
  } <span class="i">as</span>;<span name="as"> </span>
} <span class="t">Value</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after enum <em>ValueType</em>, replace 1 line</div>

<p>There&rsquo;s a field for the type tag, and then a second field containing the union
of all of the underlying values. On a 64-bit machine with a typical C compiler,
the layout looks like this:</p>
<aside name="as">
<p>A smart language hacker gave me the idea to use &ldquo;as&rdquo; for the name of the union
field because it reads nicely, almost like a cast, when you pull the various
values out.</p>
</aside><img src="image/types-of-values/value.png" alt="The full value struct, with the type and as fields next to each other in memory." />
<p>The four-byte type tag comes first, then the union. Most architectures prefer
values be aligned to their size. Since the union field contains an eight-byte
double, the compiler adds four bytes of <span name="pad">padding</span> after
the type field to keep that double on the nearest eight-byte boundary. That
means we&rsquo;re effectively spending eight bytes on the type tag, which only needs
to represent a number between zero and three. We could stuff the enum in a
smaller size, but all that would do is increase the padding.</p>
<aside name="pad">
<p>We could move the tag field <em>after</em> the union, but that doesn&rsquo;t help much
either. Whenever we create an array of Values<span class="em">&mdash;</span>which is where most of our
memory usage for Values will be<span class="em">&mdash;</span>the C compiler will insert that same padding
<em>between</em> each Value to keep the doubles aligned.</p>
</aside>
<p>So our Values are 16 bytes, which seems a little large. We&rsquo;ll improve it
<a href="optimization.html">later</a>. In the meantime, they&rsquo;re still small enough to store on
the C stack and pass around by value. Lox&rsquo;s semantics allow that because the
only types we support so far are <strong>immutable</strong>. If we pass a copy of a Value
containing the number three to some function, we don&rsquo;t need to worry about the
caller seeing modifications to the value. You can&rsquo;t &ldquo;modify&rdquo; three. It&rsquo;s three
forever.</p>
<h2><a href="#lox-values-and-c-values" id="lox-values-and-c-values"><small>18&#8202;.&#8202;2</small>Lox Values and C Values</a></h2>
<p>That&rsquo;s our new value representation, but we aren&rsquo;t done. Right now, the rest of
clox assumes Value is an alias for <code>double</code>. We have code that does a straight C
cast from one to the other. That code is all broken now. So sad.</p>
<p>With our new representation, a Value can <em>contain</em> a double, but it&rsquo;s not
<em>equivalent</em> to it. There is a mandatory conversion step to get from one to the
other. We need to go through the code and insert those conversions to get clox
working again.</p>
<p>We&rsquo;ll implement these conversions as a handful of macros, one for each type and
operation. First, to promote a native C value to a clox Value:</p>
<div class="codehilite"><pre class="insert-before">} Value;
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert">

<span class="a">#define BOOL_VAL(value)   ((Value){VAL_BOOL, {.boolean = value}})</span>
<span class="a">#define NIL_VAL           ((Value){VAL_NIL, {.number = 0}})</span>
<span class="a">#define NUMBER_VAL(value) ((Value){VAL_NUMBER, {.number = value}})</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<p>Each one of these takes a C value of the appropriate type and produces a Value
that has the correct type tag and contains the underlying value. This hoists
statically typed values up into clox&rsquo;s dynamically typed universe. In order to
<em>do</em> anything with a Value, though, we need to unpack it and get the C value
back out.</p>
<div class="codehilite"><pre class="insert-before">} Value;
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert">

<span class="a">#define AS_BOOL(value)    ((value).as.boolean)</span>
<span class="a">#define AS_NUMBER(value)  ((value).as.number)</span>
</pre><pre class="insert-after">

#define BOOL_VAL(value)   ((Value){VAL_BOOL, {.boolean = value}})
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<aside name="as-null">
<p>There&rsquo;s no <code>AS_NIL</code> macro because there is only one <code>nil</code> value, so a Value with
type <code>VAL_NIL</code> doesn&rsquo;t carry any extra data.</p>
</aside>
<p><span name="as-null">These</span> macros go in the opposite direction. Given a
Value of the right type, they unwrap it and return the corresponding raw C
value. The &ldquo;right type&rdquo; part is important! These macros directly access the
union fields. If we were to do something like:</p>
<div class="codehilite"><pre><span class="t">Value</span> <span class="i">value</span> = <span class="a">BOOL_VAL</span>(<span class="k">true</span>);
<span class="t">double</span> <span class="i">number</span> = <span class="a">AS_NUMBER</span>(<span class="i">value</span>);
</pre></div>
<p>Then we may open a smoldering portal to the Shadow Realm. It&rsquo;s not safe to use
any of the <code>AS_</code> macros unless we know the Value contains the appropriate type.
To that end, we define a last few macros to check a Value&rsquo;s type.</p>
<div class="codehilite"><pre class="insert-before">} Value;
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert">

<span class="a">#define IS_BOOL(value)    ((value).type == VAL_BOOL)</span>
<span class="a">#define IS_NIL(value)     ((value).type == VAL_NIL)</span>
<span class="a">#define IS_NUMBER(value)  ((value).type == VAL_NUMBER)</span>
</pre><pre class="insert-after">

#define AS_BOOL(value)    ((value).as.boolean)
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<p><span name="universe">These</span> macros return <code>true</code> if the Value has that
type. Any time we call one of the <code>AS_</code> macros, we need to guard it behind a
call to one of these first. With these eight macros, we can now safely shuttle
data between Lox&rsquo;s dynamic world and C&rsquo;s static one.</p>
<aside name="universe"><img src="image/types-of-values/universe.png" alt="The earthly C firmament with the Lox heavens above." />
<p>The <code>_VAL</code> macros lift a C value into the heavens. The <code>AS_</code> macros bring it
back down.</p>
</aside>
<h2><a href="#dynamically-typed-numbers" id="dynamically-typed-numbers"><small>18&#8202;.&#8202;3</small>Dynamically Typed Numbers</a></h2>
<p>We&rsquo;ve got our value representation and the tools to convert to and from it. All
that&rsquo;s left to get clox running again is to grind through the code and fix every
place where data moves across that boundary. This is one of those sections of
the book that isn&rsquo;t exactly mind-blowing, but I promised I&rsquo;d show you every
single line of code, so here we are.</p>
<p>The first values we create are the constants generated when we compile number
literals. After we convert the lexeme to a C double, we simply wrap it in a
Value before storing it in the constant table.</p>
<div class="codehilite"><pre class="insert-before">  double value = strtod(parser.previous.start, NULL);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>number</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">emitConstant</span>(<span class="a">NUMBER_VAL</span>(<span class="i">value</span>));
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>number</em>(), replace 1 line</div>

<p>Over in the runtime, we have a function to print values.</p>
<div class="codehilite"><pre class="insert-before">void printValue(Value value) {
</pre><div class="source-file"><em>value.c</em><br>
in <em>printValue</em>()<br>
replace 1 line</div>
<pre class="insert"> <span class="i">printf</span>(<span class="s">&quot;%g&quot;</span>, <span class="a">AS_NUMBER</span>(<span class="i">value</span>));
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>printValue</em>(), replace 1 line</div>

<p>Right before we send the Value to <code>printf()</code>, we unwrap it and extract the
double value. We&rsquo;ll revisit this function shortly to add the other types, but
let&rsquo;s get our existing code working first.</p>
<h3><a href="#unary-negation-and-runtime-errors" id="unary-negation-and-runtime-errors"><small>18&#8202;.&#8202;3&#8202;.&#8202;1</small>Unary negation and runtime errors</a></h3>
<p>The next simplest operation is unary negation. It pops a value off the stack,
negates it, and pushes the result. Now that we have other types of values, we
can&rsquo;t assume the operand is a number anymore. The user could just as well do:</p>
<div class="codehilite"><pre><span class="k">print</span> -<span class="k">false</span>; <span class="c">// Uh...</span>
</pre></div>
<p>We need to handle that gracefully, which means it&rsquo;s time for <em>runtime errors</em>.
Before performing an operation that requires a certain type, we need to make
sure the Value <em>is</em> that type.</p>
<p>For unary negation, the check looks like this:</p>
<div class="codehilite"><pre class="insert-before">      case OP_DIVIDE:   BINARY_OP(/); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NEGATE</span>:
        <span class="k">if</span> (!<span class="a">IS_NUMBER</span>(<span class="i">peek</span>(<span class="n">0</span>))) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Operand must be a number.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="i">push</span>(<span class="a">NUMBER_VAL</span>(-<span class="a">AS_NUMBER</span>(<span class="i">pop</span>())));
        <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>First, we check to see if the Value on top of the stack is a number. If it&rsquo;s
not, we report the runtime error and <span name="halt">stop</span> the
interpreter. Otherwise, we keep going. Only after this validation do we unwrap
the operand, negate it, wrap the result and push it.</p>
<aside name="halt">
<p>Lox&rsquo;s approach to error-handling is rather<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span><em>spare</em>. All errors are fatal and
immediately halt the interpreter. There&rsquo;s no way for user code to recover from
an error. If Lox were a real language, this is one of the first things I would
remedy.</p>
</aside>
<p>To access the Value, we use a new little function.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>pop</em>()</div>
<pre><span class="k">static</span> <span class="t">Value</span> <span class="i">peek</span>(<span class="t">int</span> <span class="i">distance</span>) {
  <span class="k">return</span> <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="n">1</span> - <span class="i">distance</span>];
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>pop</em>()</div>

<p>It returns a Value from the stack but doesn&rsquo;t <span name="peek">pop</span> it.
The <code>distance</code> argument is how far down from the top of the stack to look: zero
is the top, one is one slot down, etc.</p>
<aside name="peek">
<p>Why not just pop the operand and then validate it? We could do that. In later
chapters, it will be important to leave operands on the stack to ensure the
garbage collector can find them if a collection is triggered in the middle of
the operation. I do the same thing here mostly out of habit.</p>
</aside>
<p>We report the runtime error using a new function that we&rsquo;ll get a lot of mileage
out of over the remainder of the book.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>resetStack</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">runtimeError</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">format</span>, ...) {
  <span class="t">va_list</span> <span class="i">args</span>;
  <span class="i">va_start</span>(<span class="i">args</span>, <span class="i">format</span>);
  <span class="i">vfprintf</span>(<span class="i">stderr</span>, <span class="i">format</span>, <span class="i">args</span>);
  <span class="i">va_end</span>(<span class="i">args</span>);
  <span class="i">fputs</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">stderr</span>);

  <span class="t">size_t</span> <span class="i">instruction</span> = <span class="i">vm</span>.<span class="i">ip</span> - <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span> - <span class="n">1</span>;
  <span class="t">int</span> <span class="i">line</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">instruction</span>];
  <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;[line %d] in script</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">line</span>);
  <span class="i">resetStack</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>resetStack</em>()</div>

<p>You&rsquo;ve certainly <em>called</em> variadic functions<span class="em">&mdash;</span>ones that take a varying number
of arguments<span class="em">&mdash;</span>in C before: <code>printf()</code> is one. But you may not have <em>defined</em>
your own. This book isn&rsquo;t a C <span name="tutorial">tutorial</span>, so I&rsquo;ll
skim over it here, but basically the <code>...</code> and <code>va_list</code> stuff let us pass an
arbitrary number of arguments to <code>runtimeError()</code>. It forwards those on to
<code>vfprintf()</code>, which is the flavor of <code>printf()</code> that takes an explicit
<code>va_list</code>.</p>
<aside name="tutorial">
<p>If you are looking for a C tutorial, I love <em><a href="https://www.cs.princeton.edu/~bwk/cbook.html">The C Programming Language</a></em>,
usually called &ldquo;K&amp;R&rdquo; in honor of its authors. It&rsquo;s not entirely up to date, but
the quality of the writing more than makes up for it.</p>
</aside>
<p>Callers can pass a format string to <code>runtimeError()</code> followed by a number of
arguments, just like they can when calling <code>printf()</code> directly. <code>runtimeError()</code>
then formats and prints those arguments. We won&rsquo;t take advantage of that in this
chapter, but later chapters will produce formatted runtime error messages that
contain other data.</p>
<p>After we show the hopefully helpful error message, we tell the user which <span
name="stack">line</span> of their code was being executed when the error
occurred. Since we left the tokens behind in the compiler, we look up the line
in the debug information compiled into the chunk. If our compiler did its job
right, that corresponds to the line of source code that the bytecode was
compiled from.</p>
<p>We look into the chunk&rsquo;s debug line array using the current bytecode instruction
index <em>minus one</em>. That&rsquo;s because the interpreter advances past each instruction
before executing it. So, at the point that we call <code>runtimeError()</code>, the failed
instruction is the previous one.</p>
<aside name="stack">
<p>Just showing the immediate line where the error occurred doesn&rsquo;t provide much
context. Better would be a full stack trace. But we don&rsquo;t even have functions to
call yet, so there is no call stack to trace.</p>
</aside>
<p>In order to use <code>va_list</code> and the macros for working with it, we need to bring
in a standard header.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add to top of file</div>
<pre class="insert"><span class="a">#include &lt;stdarg.h&gt;</span>
</pre><pre class="insert-after">#include &lt;stdio.h&gt;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add to top of file</div>

<p>With this, our VM can not only do the right thing when we negate numbers (like
it used to before we broke it), but it also gracefully handles erroneous
attempts to negate other types (which we don&rsquo;t have yet, but still).</p>
<h3><a href="#binary-arithmetic-operators" id="binary-arithmetic-operators"><small>18&#8202;.&#8202;3&#8202;.&#8202;2</small>Binary arithmetic operators</a></h3>
<p>We have our runtime error machinery in place now, so fixing the binary operators
is easier even though they&rsquo;re more complex. We support four binary operators
today: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. The only difference between them is which
underlying C operator they use. To minimize redundant code between the four
operators, we wrapped up the commonality in a big preprocessor macro that takes
the operator token as a parameter.</p>
<p>That macro seemed like overkill a <a href="a-virtual-machine.html#binary-operators">few chapters ago</a>, but we get the benefit
from it today. It lets us add the necessary type checking and conversions in one
place.</p>
<div class="codehilite"><pre class="insert-before">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 6 lines</div>
<pre class="insert"><span class="a">#define BINARY_OP(valueType, op) \</span>
<span class="a">    do { \</span>
<span class="a">      if (!IS_NUMBER(peek(0)) || !IS_NUMBER(peek(1))) { \</span>
<span class="a">        runtimeError(&quot;Operands must be numbers.&quot;); \</span>
<span class="a">        return INTERPRET_RUNTIME_ERROR; \</span>
<span class="a">      } \</span>
<span class="a">      double b = AS_NUMBER(pop()); \</span>
<span class="a">      double a = AS_NUMBER(pop()); \</span>
<span class="a">      push(valueType(a op b)); \</span>
<span class="a">    } while (false)</span>
</pre><pre class="insert-after">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 6 lines</div>

<p>Yeah, I realize that&rsquo;s a monster of a macro. It&rsquo;s not what I&rsquo;d normally consider
good C practice, but let&rsquo;s roll with it. The changes are similar to what we did
for unary negate. First, we check that the two operands are both numbers. If
either isn&rsquo;t, we report a runtime error and yank the ejection seat lever.</p>
<p>If the operands are fine, we pop them both and unwrap them. Then we apply the
given operator, wrap the result, and push it back on the stack. Note that we
don&rsquo;t wrap the result by directly using <code>NUMBER_VAL()</code>. Instead, the wrapper to
use is passed in as a macro <span name="macro">parameter</span>. For our
existing arithmetic operators, the result is a number, so we pass in the
<code>NUMBER_VAL</code> macro.</p>
<aside name="macro">
<p>Did you know you can pass macros as parameters to macros? Now you do!</p>
</aside>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 4 lines</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_ADD</span>:      <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, +); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_SUBTRACT</span>: <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, -); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_MULTIPLY</span>: <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, *); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_DIVIDE</span>:   <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, /); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 4 lines</div>

<p>Soon, I&rsquo;ll show you why we made the wrapping macro an argument.</p>
<h2><a href="#two-new-types" id="two-new-types"><small>18&#8202;.&#8202;4</small>Two New Types</a></h2>
<p>All of our existing clox code is back in working order. Finally, it&rsquo;s time to
add some new types. We&rsquo;ve got a running numeric calculator that now does a
number of pointless paranoid runtime type checks. We can represent other types
internally, but there&rsquo;s no way for a user&rsquo;s program to ever create a Value of
one of those types.</p>
<p>Not until now, that is. We&rsquo;ll start by adding compiler support for the three new
literals: <code>true</code>, <code>false</code>, and <code>nil</code>. They&rsquo;re all pretty simple, so we&rsquo;ll do all
three in a single batch.</p>
<p>With number literals, we had to deal with the fact that there are billions of
possible numeric values. We attended to that by storing the literal&rsquo;s value in
the chunk&rsquo;s constant table and emitting a bytecode instruction that simply
loaded that constant. We could do the same thing for the new types. We&rsquo;d store,
say, <code>true</code>, in the constant table, and use an <code>OP_CONSTANT</code> to read it out.</p>
<p>But given that there are literally (heh) only three possible values we need to
worry about with these new types, it&rsquo;s gratuitous<span class="em">&mdash;</span>and <span
name="small">slow!</span><span class="em">&mdash;</span>to waste a two-byte instruction and a constant
table entry on them. Instead, we&rsquo;ll define three dedicated instructions to push
each of these literals on the stack.</p>
<aside name="small" class="bottom">
<p>I&rsquo;m not kidding about dedicated operations for certain constant values being
faster. A bytecode VM spends much of its execution time reading and decoding
instructions. The fewer, simpler instructions you need for a given piece of
behavior, the faster it goes. Short instructions dedicated to common operations
are a classic optimization.</p>
<p>For example, the Java bytecode instruction set has dedicated instructions for
loading 0.0, 1.0, 2.0, and the integer values from -1 through 5. (This ends up
being a vestigial optimization given that most mature JVMs now JIT-compile the
bytecode to machine code before execution anyway.)</p>
</aside>
<div class="codehilite"><pre class="insert-before">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_NIL</span>,
  <span class="a">OP_TRUE</span>,
  <span class="a">OP_FALSE</span>,
</pre><pre class="insert-after">  OP_ADD,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Our scanner already treats <code>true</code>, <code>false</code>, and <code>nil</code> as keywords, so we can
skip right to the parser. With our table-based Pratt parser, we just need to
slot parser functions into the rows associated with those keyword token types.
We&rsquo;ll use the same function in all three slots. Here:</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_ELSE]          = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_FALSE</span>]         = {<span class="i">literal</span>,  <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_FOR]           = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Here:</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_THIS]          = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_TRUE</span>]          = {<span class="i">literal</span>,  <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_VAR]           = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>And here:</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_IF]            = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_NIL</span>]           = {<span class="i">literal</span>,  <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_OR]            = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>When the parser encounters <code>false</code>, <code>nil</code>, or <code>true</code>, in prefix position, it
calls this new parser function:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>binary</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">literal</span>() {
  <span class="k">switch</span> (<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">TOKEN_FALSE</span>: <span class="i">emitByte</span>(<span class="a">OP_FALSE</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_NIL</span>: <span class="i">emitByte</span>(<span class="a">OP_NIL</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_TRUE</span>: <span class="i">emitByte</span>(<span class="a">OP_TRUE</span>); <span class="k">break</span>;
    <span class="k">default</span>: <span class="k">return</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>binary</em>()</div>

<p>Since <code>parsePrecedence()</code> has already consumed the keyword token, all we need to
do is output the proper instruction. We <span name="switch">figure</span> that
out based on the type of token we parsed. Our front end can now compile Boolean
and nil literals to bytecode. Moving down the execution pipeline, we reach the
interpreter.</p>
<aside name="switch">
<p>We could have used separate parser functions for each literal and saved
ourselves a switch but that felt needlessly verbose to me. I think it&rsquo;s mostly a
matter of taste.</p>
</aside>
<div class="codehilite"><pre class="insert-before">      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
        push(constant);
        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NIL</span>: <span class="i">push</span>(<span class="a">NIL_VAL</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_TRUE</span>: <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="k">true</span>)); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_FALSE</span>: <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="k">false</span>)); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_ADD:      BINARY_OP(NUMBER_VAL, +); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>This is pretty self-explanatory. Each instruction summons the appropriate value
and pushes it onto the stack. We shouldn&rsquo;t forget our disassembler either.</p>
<div class="codehilite"><pre class="insert-before">    case OP_CONSTANT:
      return constantInstruction(&quot;OP_CONSTANT&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_NIL</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_NIL&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_TRUE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_TRUE&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_FALSE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_FALSE&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_ADD:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>With this in place, we can run this Earth-shattering program:</p>
<div class="codehilite"><pre><span class="k">true</span>
</pre></div>
<p>Except that when the interpreter tries to print the result, it blows up. We need
to extend <code>printValue()</code> to handle the new types too:</p>
<div class="codehilite"><pre class="insert-before">void printValue(Value value) {
</pre><div class="source-file"><em>value.c</em><br>
in <em>printValue</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">switch</span> (<span class="i">value</span>.<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">VAL_BOOL</span>:
      <span class="i">printf</span>(<span class="a">AS_BOOL</span>(<span class="i">value</span>) ? <span class="s">&quot;true&quot;</span> : <span class="s">&quot;false&quot;</span>);
      <span class="k">break</span>;
    <span class="k">case</span> <span class="a">VAL_NIL</span>: <span class="i">printf</span>(<span class="s">&quot;nil&quot;</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">VAL_NUMBER</span>: <span class="i">printf</span>(<span class="s">&quot;%g&quot;</span>, <span class="a">AS_NUMBER</span>(<span class="i">value</span>)); <span class="k">break</span>;
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>printValue</em>(), replace 1 line</div>

<p>There we go! Now we have some new types. They just aren&rsquo;t very useful yet. Aside
from the literals, you can&rsquo;t really <em>do</em> anything with them. It will be a while
before <code>nil</code> comes into play, but we can start putting Booleans to work in the
logical operators.</p>
<h3><a href="#logical-not-and-falsiness" id="logical-not-and-falsiness"><small>18&#8202;.&#8202;4&#8202;.&#8202;1</small>Logical not and falsiness</a></h3>
<p>The simplest logical operator is our old exclamatory friend unary not.</p>
<div class="codehilite"><pre><span class="k">print</span> !<span class="k">true</span>; <span class="c">// &quot;false&quot;</span>
</pre></div>
<p>This new operation gets a new instruction.</p>
<div class="codehilite"><pre class="insert-before">  OP_DIVIDE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_NOT</span>,
</pre><pre class="insert-after">  OP_NEGATE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>We can reuse the <code>unary()</code> parser function we wrote for unary negation to
compile a not expression. We just need to slot it into the parsing table.</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_STAR]          = {NULL,     binary, PREC_FACTOR},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_BANG</span>]          = {<span class="i">unary</span>,    <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_BANG_EQUAL]    = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Because I knew we were going to do this, the <code>unary()</code> function already has a
switch on the token type to figure out which bytecode instruction to output. We
merely add another case.</p>
<div class="codehilite"><pre class="insert-before">  switch (operatorType) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>unary</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">TOKEN_BANG</span>: <span class="i">emitByte</span>(<span class="a">OP_NOT</span>); <span class="k">break</span>;
</pre><pre class="insert-after">    case TOKEN_MINUS: emitByte(OP_NEGATE); break;
    default: return; // Unreachable.
  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>unary</em>()</div>

<p>That&rsquo;s it for the front end. Let&rsquo;s head over to the VM and conjure this
instruction into life.</p>
<div class="codehilite"><pre class="insert-before">      case OP_DIVIDE:   BINARY_OP(NUMBER_VAL, /); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NOT</span>:
        <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="i">isFalsey</span>(<span class="i">pop</span>())));
        <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Like our previous unary operator, it pops the one operand, performs the
operation, and pushes the result. And, as we did there, we have to worry about
dynamic typing. Taking the logical not of <code>true</code> is easy, but there&rsquo;s nothing
preventing an unruly programmer from writing something like this:</p>
<div class="codehilite"><pre><span class="k">print</span> !<span class="k">nil</span>;
</pre></div>
<p>For unary minus, we made it an error to negate anything that isn&rsquo;t a <span
name="negate">number</span>. But Lox, like most scripting languages, is more
permissive when it comes to <code>!</code> and other contexts where a Boolean is expected.
The rule for how other types are handled is called &ldquo;falsiness&rdquo;, and we implement
it here:</p>
<aside name="negate">
<p>Now I can&rsquo;t help but try to figure out what it would mean to negate other types
of values. <code>nil</code> is probably its own negation, sort of like a weird pseudo-zero.
Negating a string could, uh, reverse it?</p>
</aside>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>peek</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">isFalsey</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="k">return</span> <span class="a">IS_NIL</span>(<span class="i">value</span>) || (<span class="a">IS_BOOL</span>(<span class="i">value</span>) &amp;&amp; !<span class="a">AS_BOOL</span>(<span class="i">value</span>));
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>peek</em>()</div>

<p>Lox follows Ruby in that <code>nil</code> and <code>false</code> are falsey and every other value
behaves like <code>true</code>. We&rsquo;ve got a new instruction we can generate, so we also
need to be able to <em>un</em>generate it in the disassembler.</p>
<div class="codehilite"><pre class="insert-before">    case OP_DIVIDE:
      return simpleInstruction(&quot;OP_DIVIDE&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_NOT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_NOT&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<h3><a href="#equality-and-comparison-operators" id="equality-and-comparison-operators"><small>18&#8202;.&#8202;4&#8202;.&#8202;2</small>Equality and comparison operators</a></h3>
<p>That wasn&rsquo;t too bad. Let&rsquo;s keep the momentum going and knock out the equality
and comparison operators too: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>. That covers
all of the operators that return Boolean results except the logical operators
<code>and</code> and <code>or</code>. Since those need to short-circuit (basically do a little
control flow) we aren&rsquo;t ready for them yet.</p>
<p>Here are the new instructions for those operators:</p>
<div class="codehilite"><pre class="insert-before">  OP_FALSE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_EQUAL</span>,
  <span class="a">OP_GREATER</span>,
  <span class="a">OP_LESS</span>,
</pre><pre class="insert-after">  OP_ADD,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Wait, only three? What about <code>!=</code>, <code>&lt;=</code>, and <code>&gt;=</code>? We could create instructions
for those too. Honestly, the VM would execute faster if we did, so we <em>should</em>
do that if the goal is performance.</p>
<p>But my main goal is to teach you about bytecode compilers. I want you to start
internalizing the idea that the bytecode instructions don&rsquo;t need to closely
follow the user&rsquo;s source code. The VM has total freedom to use whatever
instruction set and code sequences it wants as long as they have the right
user-visible behavior.</p>
<p>The expression <code>a != b</code> has the same semantics as <code>!(a == b)</code>, so the compiler
is free to compile the former as if it were the latter. Instead of a dedicated
<code>OP_NOT_EQUAL</code> instruction, it can output an <code>OP_EQUAL</code> followed by an <code>OP_NOT</code>.
Likewise, <code>a &lt;= b</code> is the <span name="same">same</span> as <code>!(a &gt; b)</code> and <code>a &gt;= b</code> is <code>!(a &lt; b)</code>. Thus, we only need three new instructions.</p>
<aside name="same" class="bottom">
<p><em>Is</em> <code>a &lt;= b</code> always the same as <code>!(a &gt; b)</code>? According to <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a>, all
comparison operators return false when an operand is NaN. That means <code>NaN &lt;= 1</code>
is false and <code>NaN &gt; 1</code> is also false. But our desugaring assumes the latter is
always the negation of the former.</p>
<p>For the book, we won&rsquo;t get hung up on this, but these kinds of details will
matter in your real language implementations.</p>
</aside>
<p>Over in the parser, though, we do have six new operators to slot into the parse
table. We use the same <code>binary()</code> parser function from before. Here&rsquo;s the row
for <code>!=</code>:</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_BANG]          = {unary,    NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_BANG_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_EQUALITY</span>},
</pre><pre class="insert-after">  [TOKEN_EQUAL]         = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>The remaining five operators are a little farther down in the table.</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_EQUAL]         = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 5 lines</div>
<pre class="insert">  [<span class="a">TOKEN_EQUAL_EQUAL</span>]   = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_EQUALITY</span>},
  [<span class="a">TOKEN_GREATER</span>]       = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
  [<span class="a">TOKEN_GREATER_EQUAL</span>] = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
  [<span class="a">TOKEN_LESS</span>]          = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
  [<span class="a">TOKEN_LESS_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
</pre><pre class="insert-after">  [TOKEN_IDENTIFIER]    = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 5 lines</div>

<p>Inside <code>binary()</code> we already have a switch to generate the right bytecode for
each token type. We add cases for the six new operators.</p>
<div class="codehilite"><pre class="insert-before">  switch (operatorType) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>binary</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">TOKEN_BANG_EQUAL</span>:    <span class="i">emitBytes</span>(<span class="a">OP_EQUAL</span>, <span class="a">OP_NOT</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_EQUAL_EQUAL</span>:   <span class="i">emitByte</span>(<span class="a">OP_EQUAL</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_GREATER</span>:       <span class="i">emitByte</span>(<span class="a">OP_GREATER</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_GREATER_EQUAL</span>: <span class="i">emitBytes</span>(<span class="a">OP_LESS</span>, <span class="a">OP_NOT</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_LESS</span>:          <span class="i">emitByte</span>(<span class="a">OP_LESS</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_LESS_EQUAL</span>:    <span class="i">emitBytes</span>(<span class="a">OP_GREATER</span>, <span class="a">OP_NOT</span>); <span class="k">break</span>;
</pre><pre class="insert-after">    case TOKEN_PLUS:          emitByte(OP_ADD); break;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>binary</em>()</div>

<p>The <code>==</code>, <code>&lt;</code>, and <code>&gt;</code> operators output a single instruction. The others output
a pair of instructions, one to evalute the inverse operation, and then an
<code>OP_NOT</code> to flip the result. Six operators for the price of three instructions!</p>
<p>That means over in the VM, our job is simpler. Equality is the most general
operation.</p>
<div class="codehilite"><pre class="insert-before">      case OP_FALSE: push(BOOL_VAL(false)); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_EQUAL</span>: {
        <span class="t">Value</span> <span class="i">b</span> = <span class="i">pop</span>();
        <span class="t">Value</span> <span class="i">a</span> = <span class="i">pop</span>();
        <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="i">valuesEqual</span>(<span class="i">a</span>, <span class="i">b</span>)));
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_ADD:      BINARY_OP(NUMBER_VAL, +); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>You can evaluate <code>==</code> on any pair of objects, even objects of different types.
There&rsquo;s enough complexity that it makes sense to shunt that logic over to a
separate function. That function always returns a C <code>bool</code>, so we can safely
wrap the result in a <code>BOOL_VAL</code>. The function relates to Values, so it lives
over in the &ldquo;value&rdquo; module.</p>
<div class="codehilite"><pre class="insert-before">} ValueArray;

</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>ValueArray</em></div>
<pre class="insert"><span class="t">bool</span> <span class="i">valuesEqual</span>(<span class="t">Value</span> <span class="i">a</span>, <span class="t">Value</span> <span class="i">b</span>);
</pre><pre class="insert-after">void initValueArray(ValueArray* array);
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>ValueArray</em></div>

<p>And here&rsquo;s the implementation:</p>
<div class="codehilite"><div class="source-file"><em>value.c</em><br>
add after <em>printValue</em>()</div>
<pre><span class="t">bool</span> <span class="i">valuesEqual</span>(<span class="t">Value</span> <span class="i">a</span>, <span class="t">Value</span> <span class="i">b</span>) {
  <span class="k">if</span> (<span class="i">a</span>.<span class="i">type</span> != <span class="i">b</span>.<span class="i">type</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">switch</span> (<span class="i">a</span>.<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">VAL_BOOL</span>:   <span class="k">return</span> <span class="a">AS_BOOL</span>(<span class="i">a</span>) == <span class="a">AS_BOOL</span>(<span class="i">b</span>);
    <span class="k">case</span> <span class="a">VAL_NIL</span>:    <span class="k">return</span> <span class="k">true</span>;
    <span class="k">case</span> <span class="a">VAL_NUMBER</span>: <span class="k">return</span> <span class="a">AS_NUMBER</span>(<span class="i">a</span>) == <span class="a">AS_NUMBER</span>(<span class="i">b</span>);
    <span class="k">default</span>:         <span class="k">return</span> <span class="k">false</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, add after <em>printValue</em>()</div>

<p>First, we check the types. If the Values have <span
name="equal">different</span> types, they are definitely not equal. Otherwise,
we unwrap the two Values and compare them directly.</p>
<aside name="equal">
<p>Some languages have &ldquo;implicit conversions&rdquo; where values of different types may
be considered equal if one can be converted to the other&rsquo;s type. For example,
the number 0 is equivalent to the string &ldquo;0&rdquo; in JavaScript. This looseness was a
large enough source of pain that JS added a separate &ldquo;strict equality&rdquo; operator,
<code>===</code>.</p>
<p>PHP considers the strings &ldquo;1&rdquo; and &ldquo;01&rdquo; to be equivalent because both can be
converted to equivalent numbers, though the ultimate reason is because PHP was
designed by a Lovecraftian eldritch god to destroy the mind.</p>
<p>Most dynamically typed languages that have separate integer and floating-point
number types consider values of different number types equal if the numeric
values are the same (so, say, 1.0 is equal to 1), though even that seemingly
innocuous convenience can bite the unwary.</p>
</aside>
<p>For each value type, we have a separate case that handles comparing the value
itself. Given how similar the cases are, you might wonder why we can&rsquo;t simply
<code>memcmp()</code> the two Value structs and be done with it. The problem is that
because of padding and different-sized union fields, a Value contains unused
bits. C gives no guarantee about what is in those, so it&rsquo;s possible that two
equal Values actually differ in memory that isn&rsquo;t used.</p><img src="image/types-of-values/memcmp.png" alt="The memory respresentations of two equal values that differ in unused bytes." />
<p>(You wouldn&rsquo;t believe how much pain I went through before learning this fact.)</p>
<p>Anyway, as we add more types to clox, this function will grow new cases. For
now, these three are sufficient. The other comparison operators are easier since
they work only on numbers.</p>
<div class="codehilite"><pre class="insert-before">        push(BOOL_VAL(valuesEqual(a, b)));
        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GREATER</span>:  <span class="a">BINARY_OP</span>(<span class="a">BOOL_VAL</span>, &gt;); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_LESS</span>:     <span class="a">BINARY_OP</span>(<span class="a">BOOL_VAL</span>, &lt;); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_ADD:      BINARY_OP(NUMBER_VAL, +); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We already extended the <code>BINARY_OP</code> macro to handle operators that return
non-numeric types. Now we get to use that. We pass in <code>BOOL_VAL</code> since the
result value type is Boolean. Otherwise, it&rsquo;s no different from plus or minus.</p>
<p>As always, the coda to today&rsquo;s aria is disassembling the new instructions.</p>
<div class="codehilite"><pre class="insert-before">    case OP_FALSE:
      return simpleInstruction(&quot;OP_FALSE&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_EQUAL</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_EQUAL&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_GREATER</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_GREATER&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_LESS</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_LESS&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_ADD:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>With that, our numeric calculator has become something closer to a general
expression evaluator. Fire up clox and type in:</p>
<div class="codehilite"><pre>!(<span class="n">5</span> - <span class="n">4</span> &gt; <span class="n">3</span> * <span class="n">2</span> == !<span class="k">nil</span>)
</pre></div>
<p>OK, I&rsquo;ll admit that&rsquo;s maybe not the most <em>useful</em> expression, but we&rsquo;re making
progress. We have one missing built-in type with its own literal form: strings.
Those are much more complex because strings can vary in size. That tiny
difference turns out to have implications so large that we give strings <a href="strings.html">their
very own chapter</a>.</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>We could reduce our binary operators even further than we did here. Which
other instructions can you eliminate, and how would the compiler cope with
their absence?</p>
</li>
<li>
<p>Conversely, we can improve the speed of our bytecode VM by adding more
specific instructions that correspond to higher-level operations. What
instructions would you define to speed up the kind of user code we added
support for in this chapter?</p>
</li>
</ol>
</div>

<footer>
<a href="strings.html" class="next">
  Next Chapter: &ldquo;Strings&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Strings &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Strings<small>19</small></a></h3>

<ul>
    <li><a href="#values-and-objects"><small>19.1</small> Values and Objects</a></li>
    <li><a href="#struct-inheritance"><small>19.2</small> Struct Inheritance</a></li>
    <li><a href="#strings"><small>19.3</small> Strings</a></li>
    <li><a href="#operations-on-strings"><small>19.4</small> Operations on Strings</a></li>
    <li><a href="#freeing-objects"><small>19.5</small> Freeing Objects</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>String Encoding</a></li>
</ul>


<div class="prev-next">
    <a href="types-of-values.html" title="Types of Values" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="hash-tables.html" title="Hash Tables" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="types-of-values.html" title="Types of Values" class="prev">←</a>
<a href="hash-tables.html" title="Hash Tables" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Strings<small>19</small></a></h3>

<ul>
    <li><a href="#values-and-objects"><small>19.1</small> Values and Objects</a></li>
    <li><a href="#struct-inheritance"><small>19.2</small> Struct Inheritance</a></li>
    <li><a href="#strings"><small>19.3</small> Strings</a></li>
    <li><a href="#operations-on-strings"><small>19.4</small> Operations on Strings</a></li>
    <li><a href="#freeing-objects"><small>19.5</small> Freeing Objects</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>String Encoding</a></li>
</ul>


<div class="prev-next">
    <a href="types-of-values.html" title="Types of Values" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="hash-tables.html" title="Hash Tables" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">19</div>
  <h1>Strings</h1>

<blockquote>
<p>&ldquo;Ah? A small aversion to menial labor?&rdquo; The doctor cocked an eyebrow.
&ldquo;Understandable, but misplaced. One should treasure those hum-drum
tasks that keep the body occupied but leave the mind and heart unfettered.&rdquo;</p>
<p><cite>Tad Williams, <em>The Dragonbone Chair</em></cite></p>
</blockquote>
<p>Our little VM can represent three types of values right now: numbers, Booleans,
and <code>nil</code>. Those types have two important things in common: they&rsquo;re immutable
and they&rsquo;re small. Numbers are the largest, and they still fit into two 64-bit
words. That&rsquo;s a small enough price that we can afford to pay it for all values,
even Booleans and nils which don&rsquo;t need that much space.</p>
<p>Strings, unfortunately, are not so petite. There&rsquo;s no maximum length for a
string. Even if we were to artificially cap it at some contrived limit like
<span name="pascal">255</span> characters, that&rsquo;s still too much memory to spend
on every single value.</p>
<aside name="pascal">
<p>UCSD Pascal, one of the first implementations of Pascal, had this exact limit.
Instead of using a terminating null byte to indicate the end of the string like
C, Pascal strings started with a length value. Since UCSD used only a single
byte to store the length, strings couldn&rsquo;t be any longer than 255 characters.</p><img src="image/strings/pstring.png" alt="The Pascal string 'hello' with a length byte of 5 preceding it." />
</aside>
<p>We need a way to support values whose sizes vary, sometimes greatly. This is
exactly what dynamic allocation on the heap is designed for. We can allocate as
many bytes as we need. We get back a pointer that we&rsquo;ll use to keep track of the
value as it flows through the VM.</p>
<h2><a href="#values-and-objects" id="values-and-objects"><small>19&#8202;.&#8202;1</small>Values and Objects</a></h2>
<p>Using the heap for larger, variable-sized values and the stack for smaller,
atomic ones leads to a two-level representation. Every Lox value that you can
store in a variable or return from an expression will be a Value. For small,
fixed-size types like numbers, the payload is stored directly inside the Value
struct itself.</p>
<p>If the object is larger, its data lives on the heap. Then the Value&rsquo;s payload is
a <em>pointer</em> to that blob of memory. We&rsquo;ll eventually have a handful of
heap-allocated types in clox: strings, instances, functions, you get the idea.
Each type has its own unique data, but there is also state they all share that
<a href="garbage-collection.html">our future garbage collector</a> will use to manage their memory.</p><img src="image/strings/value.png" class="wide" alt="Field layout of number and obj values." />
<p>We&rsquo;ll call this common representation <span name="short">&ldquo;Obj&rdquo;</span>. Each Lox
value whose state lives on the heap is an Obj. We can thus use a single new
ValueType case to refer to all heap-allocated types.</p>
<aside name="short">
<p>&ldquo;Obj&rdquo; is short for &ldquo;object&rdquo;, natch.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  VAL_NUMBER,
</pre><div class="source-file"><em>value.h</em><br>
in enum <em>ValueType</em></div>
<pre class="insert">  <span class="a">VAL_OBJ</span>
</pre><pre class="insert-after">} ValueType;
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, in enum <em>ValueType</em></div>

<p>When a Value&rsquo;s type is <code>VAL_OBJ</code>, the payload is a pointer to the heap memory,
so we add another case to the union for that.</p>
<div class="codehilite"><pre class="insert-before">    double number;
</pre><div class="source-file"><em>value.h</em><br>
in struct <em>Value</em></div>
<pre class="insert">    <span class="t">Obj</span>* <span class="i">obj</span>;
</pre><pre class="insert-after">  } as;<span name="as"> </span>
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, in struct <em>Value</em></div>

<p>As we did with the other value types, we crank out a couple of helpful macros
for working with Obj values.</p>
<div class="codehilite"><pre class="insert-before">#define IS_NUMBER(value)  ((value).type == VAL_NUMBER)
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert"><span class="a">#define IS_OBJ(value)     ((value).type == VAL_OBJ)</span>
</pre><pre class="insert-after">

#define AS_BOOL(value)    ((value).as.boolean)
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<p>This evaluates to <code>true</code> if the given Value is an Obj. If so, we can use this:</p>
<div class="codehilite"><pre class="insert-before">#define IS_OBJ(value)     ((value).type == VAL_OBJ)

</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="a">#define AS_OBJ(value)     ((value).as.obj)</span>
</pre><pre class="insert-after">#define AS_BOOL(value)    ((value).as.boolean)
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<p>It extracts the Obj pointer from the value. We can also go the other way.</p>
<div class="codehilite"><pre class="insert-before">#define NUMBER_VAL(value) ((Value){VAL_NUMBER, {.number = value}})
</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="a">#define OBJ_VAL(object)   ((Value){VAL_OBJ, {.obj = (Obj*)object}})</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<p>This takes a bare Obj pointer and wraps it in a full Value.</p>
<h2><a href="#struct-inheritance" id="struct-inheritance"><small>19&#8202;.&#8202;2</small>Struct Inheritance</a></h2>
<p>Every heap-allocated value is an Obj, but <span name="objs">Objs</span> are
not all the same. For strings, we need the array of characters. When we get to
instances, they will need their data fields. A function object will need its
chunk of bytecode. How do we handle different payloads and sizes? We can&rsquo;t use
another union like we did for Value since the sizes are all over the place.</p>
<aside name="objs">
<p>No, I don&rsquo;t know how to pronounce &ldquo;objs&rdquo; either. Feels like there should be a
vowel in there somewhere.</p>
</aside>
<p>Instead, we&rsquo;ll use another technique. It&rsquo;s been around for ages, to the point
that the C specification carves out specific support for it, but I don&rsquo;t know
that it has a canonical name. It&rsquo;s an example of <a href="https://en.wikipedia.org/wiki/Type_punning"><em>type punning</em></a>, but that
term is too broad. In the absence of any better ideas, I&rsquo;ll call it <strong>struct
inheritance</strong>, because it relies on structs and roughly follows how
single-inheritance of state works in object-oriented languages.</p>
<p>Like a tagged union, each Obj starts with a tag field that identifies what kind
of object it is<span class="em">&mdash;</span>string, instance, etc. Following that are the payload fields.
Instead of a union with cases for each type, each type is its own separate
struct. The tricky part is how to treat these structs uniformly since C has no
concept of inheritance or polymorphism. I&rsquo;ll explain that soon, but first lets
get the preliminary stuff out of the way.</p>
<p>The name &ldquo;Obj&rdquo; itself refers to a struct that contains the state shared across
all object types. It&rsquo;s sort of like the &ldquo;base class&rdquo; for objects. Because of
some cyclic dependencies between values and objects, we forward-declare it in
the &ldquo;value&rdquo; module.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;

</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">struct</span> <span class="t">Obj</span> <span class="t">Obj</span>;

</pre><pre class="insert-after">typedef enum {
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<p>And the actual definition is in a new module.</p>
<div class="codehilite"><div class="source-file"><em>object.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_object_h</span>
<span class="a">#define clox_object_h</span>

<span class="a">#include &quot;common.h&quot;</span>
<span class="a">#include &quot;value.h&quot;</span>

<span class="k">struct</span> <span class="t">Obj</span> {
  <span class="t">ObjType</span> <span class="i">type</span>;
};

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, create new file</div>

<p>Right now, it contains only the type tag. Shortly, we&rsquo;ll add some other
bookkeeping information for memory management. The type enum is this:</p>
<div class="codehilite"><pre class="insert-before">#include &quot;value.h&quot;
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">OBJ_STRING</span>,
} <span class="t">ObjType</span>;
</pre><pre class="insert-after">

struct Obj {
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Obviously, that will be more useful in later chapters after we add more
heap-allocated types. Since we&rsquo;ll be accessing these tag types frequently, it&rsquo;s
worth making a little macro that extracts the object type tag from a given
Value.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;value.h&quot;
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert">

<span class="a">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)</span>
</pre><pre class="insert-after">

typedef enum {
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>That&rsquo;s our foundation.</p>
<p>Now, let&rsquo;s build strings on top of it. The payload for strings is defined in a
separate struct. Again, we need to forward-declare it.</p>
<div class="codehilite"><pre class="insert-before">typedef struct Obj Obj;
</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">struct</span> <span class="t">ObjString</span> <span class="t">ObjString</span>;
</pre><pre class="insert-after">

typedef enum {
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<p>The definition lives alongside Obj.</p>
<div class="codehilite"><pre class="insert-before">};
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>Obj</em></div>
<pre class="insert">

<span class="k">struct</span> <span class="t">ObjString</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">int</span> <span class="i">length</span>;
  <span class="t">char</span>* <span class="i">chars</span>;
};
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>Obj</em></div>

<p>A string object contains an array of characters. Those are stored in a separate,
heap-allocated array so that we set aside only as much room as needed for each
string. We also store the number of bytes in the array. This isn&rsquo;t strictly
necessary but lets us tell how much memory is allocated for the string without
walking the character array to find the null terminator.</p>
<p>Because ObjString is an Obj, it also needs the state all Objs share. It
accomplishes that by having its first field be an Obj. C specifies that struct
fields are arranged in memory in the order that they are declared. Also, when
you nest structs, the inner struct&rsquo;s fields are expanded right in place. So the
memory for Obj and for ObjString looks like this:</p><img src="image/strings/obj.png" alt="The memory layout for the fields in Obj and ObjString." />
<p>Note how the first bytes of ObjString exactly line up with Obj. This is not a
coincidence<span class="em">&mdash;</span>C <span name="spec">mandates</span> it. This is designed to
enable a clever pattern: You can take a pointer to a struct and safely convert
it to a pointer to its first field and back.</p>
<aside name="spec">
<p>The key part of the spec is:</p>
<blockquote>
<p>&sect; 6.7.2.1 13</p>
<p>Within a structure object, the non-bit-field members and the units in which
bit-fields reside have addresses that increase in the order in which they
are declared. A pointer to a structure object, suitably converted, points to
its initial member (or if that member is a bit-field, then to the unit in
which it resides), and vice versa. There may be unnamed padding within a
structure object, but not at its beginning.</p>
</blockquote>
</aside>
<p>Given an <code>ObjString*</code>, you can safely cast it to <code>Obj*</code> and then access the
<code>type</code> field from it. Every ObjString &ldquo;is&rdquo; an Obj in the OOP sense of &ldquo;is&rdquo;. When
we later add other object types, each struct will have an Obj as its first
field. Any code that wants to work with all objects can treat them as base
<code>Obj*</code> and ignore any other fields that may happen to follow.</p>
<p>You can go in the other direction too. Given an <code>Obj*</code>, you can &ldquo;downcast&rdquo; it to
an <code>ObjString*</code>. Of course, you need to ensure that the <code>Obj*</code> pointer you have
does point to the <code>obj</code> field of an actual ObjString. Otherwise, you are
unsafely reinterpreting random bits of memory. To detect that such a cast is
safe, we add another macro.</p>
<div class="codehilite"><pre class="insert-before">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert">

<span class="a">#define IS_STRING(value)       isObjType(value, OBJ_STRING)</span>
</pre><pre class="insert-after">

typedef enum {
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>It takes a Value, not a raw <code>Obj*</code> because most code in the VM works with
Values. It relies on this inline function:</p>
<div class="codehilite"><pre class="insert-before">};

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjString</em></div>
<pre class="insert"><span class="k">static</span> <span class="k">inline</span> <span class="t">bool</span> <span class="i">isObjType</span>(<span class="t">Value</span> <span class="i">value</span>, <span class="t">ObjType</span> <span class="i">type</span>) {
  <span class="k">return</span> <span class="a">IS_OBJ</span>(<span class="i">value</span>) &amp;&amp; <span class="a">AS_OBJ</span>(<span class="i">value</span>)-&gt;<span class="i">type</span> == <span class="i">type</span>;
}

</pre><pre class="insert-after">#endif
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>

<p>Pop quiz: Why not just put the body of this function right in the macro? What&rsquo;s
different about this one compared to the others? Right, it&rsquo;s because the body
uses <code>value</code> twice. A macro is expanded by inserting the argument <em>expression</em>
every place the parameter name appears in the body. If a macro uses a parameter
more than once, that expression gets evaluated multiple times.</p>
<p>That&rsquo;s bad if the expression has side effects. If we put the body of
<code>isObjType()</code> into the macro definition and then you did, say,</p>
<div class="codehilite"><pre><span class="a">IS_STRING</span>(<span class="a">POP</span>())
</pre></div>
<p>then it would pop two values off the stack! Using a function fixes that.</p>
<p>As long as we ensure that we set the type tag correctly whenever we create an
Obj of some type, this macro will tell us when it&rsquo;s safe to cast a value to a
specific object type. We can do that using these:</p>
<div class="codehilite"><pre class="insert-before">#define IS_STRING(value)       isObjType(value, OBJ_STRING)
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert">

<span class="a">#define AS_STRING(value)       ((ObjString*)AS_OBJ(value))</span>
<span class="a">#define AS_CSTRING(value)      (((ObjString*)AS_OBJ(value))-&gt;chars)</span>
</pre><pre class="insert-after">

typedef enum {
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>These two macros take a Value that is expected to contain a pointer to a valid
ObjString on the heap. The first one returns the <code>ObjString*</code> pointer. The
second one steps through that to return the character array itself, since that&rsquo;s
often what we&rsquo;ll end up needing.</p>
<h2><a href="#strings" id="strings"><small>19&#8202;.&#8202;3</small>Strings</a></h2>
<p>OK, our VM can now represent string values. It&rsquo;s time to add strings to the
language itself. As usual, we begin in the front end. The lexer already
tokenizes string literals, so it&rsquo;s the parser&rsquo;s turn.</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_IDENTIFIER]    = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_STRING</span>]        = {<span class="i">string</span>,   <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_NUMBER]        = {number,   NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>When the parser hits a string token, it calls this parse function:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>number</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">string</span>() {
  <span class="i">emitConstant</span>(<span class="a">OBJ_VAL</span>(<span class="i">copyString</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">start</span> + <span class="n">1</span>,
                                  <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">length</span> - <span class="n">2</span>)));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>number</em>()</div>

<p>This takes the string&rsquo;s characters <span name="escape">directly</span> from the
lexeme. The <code>+ 1</code> and <code>- 2</code> parts trim the leading and trailing quotation marks.
It then creates a string object, wraps it in a Value, and stuffs it into the
constant table.</p>
<aside name="escape">
<p>If Lox supported string escape sequences like <code>\n</code>, we&rsquo;d translate those here.
Since it doesn&rsquo;t, we can take the characters as they are.</p>
</aside>
<p>To create the string, we use <code>copyString()</code>, which is declared in <code>object.h</code>.</p>
<div class="codehilite"><pre class="insert-before">};

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjString</em></div>
<pre class="insert"><span class="t">ObjString</span>* <span class="i">copyString</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>);

</pre><pre class="insert-after">static inline bool isObjType(Value value, ObjType type) {
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>

<p>The compiler module needs to include that.</p>
<div class="codehilite"><pre class="insert-before">#define clox_compiler_h

</pre><div class="source-file"><em>compiler.h</em></div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
</pre><pre class="insert-after">#include &quot;vm.h&quot;
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em></div>

<p>Our &ldquo;object&rdquo; module gets an implementation file where we define the new
function.</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
create new file</div>
<pre><span class="a">#include &lt;stdio.h&gt;</span>
<span class="a">#include &lt;string.h&gt;</span>

<span class="a">#include &quot;memory.h&quot;</span>
<span class="a">#include &quot;object.h&quot;</span>
<span class="a">#include &quot;value.h&quot;</span>
<span class="a">#include &quot;vm.h&quot;</span>

<span class="t">ObjString</span>* <span class="i">copyString</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>) {
  <span class="t">char</span>* <span class="i">heapChars</span> = <span class="a">ALLOCATE</span>(<span class="t">char</span>, <span class="i">length</span> + <span class="n">1</span>);
  <span class="i">memcpy</span>(<span class="i">heapChars</span>, <span class="i">chars</span>, <span class="i">length</span>);
  <span class="i">heapChars</span>[<span class="i">length</span>] = <span class="s">&#39;\0&#39;</span>;
  <span class="k">return</span> <span class="i">allocateString</span>(<span class="i">heapChars</span>, <span class="i">length</span>);
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, create new file</div>

<p>First, we allocate a new array on the heap, just big enough for the string&rsquo;s
characters and the trailing <span name="terminator">terminator</span>, using
this low-level macro that allocates an array with a given element type and
count:</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;

</pre><div class="source-file"><em>memory.h</em></div>
<pre class="insert"><span class="a">#define ALLOCATE(type, count) \</span>
<span class="a">    (type*)reallocate(NULL, 0, sizeof(type) * (count))</span>

</pre><pre class="insert-after">#define GROW_CAPACITY(capacity) \
</pre></div>
<div class="source-file-narrow"><em>memory.h</em></div>

<p>Once we have the array, we copy over the characters from the lexeme and
terminate it.</p>
<aside name="terminator" class="bottom">
<p>We need to terminate the string ourselves because the lexeme points at a range
of characters inside the monolithic source string and isn&rsquo;t terminated.</p>
<p>Since ObjString stores the length explicitly, we <em>could</em> leave the character
array unterminated, but slapping a terminator on the end costs us only a byte
and lets us pass the character array to C standard library functions that expect
a terminated string.</p>
</aside>
<p>You might wonder why the ObjString can&rsquo;t just point back to the original
characters in the source string. Some ObjStrings will be created dynamically at
runtime as a result of string operations like concatenation. Those strings
obviously need to dynamically allocate memory for the characters, which means
the string needs to <em>free</em> that memory when it&rsquo;s no longer needed.</p>
<p>If we had an ObjString for a string literal, and tried to free its character
array that pointed into the original source code string, bad things would
happen. So, for literals, we preemptively copy the characters over to the heap.
This way, every ObjString reliably owns its character array and can free it.</p>
<p>The real work of creating a string object happens in this function:</p>
<div class="codehilite"><pre class="insert-before">#include &quot;vm.h&quot;

</pre><div class="source-file"><em>object.c</em></div>
<pre class="insert"><span class="k">static</span> <span class="t">ObjString</span>* <span class="i">allocateString</span>(<span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>) {
  <span class="t">ObjString</span>* <span class="i">string</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjString</span>, <span class="a">OBJ_STRING</span>);
  <span class="i">string</span>-&gt;<span class="i">length</span> = <span class="i">length</span>;
  <span class="i">string</span>-&gt;<span class="i">chars</span> = <span class="i">chars</span>;
  <span class="k">return</span> <span class="i">string</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em></div>

<p>It creates a new ObjString on the heap and then initializes its fields. It&rsquo;s
sort of like a constructor in an OOP language. As such, it first calls the &ldquo;base
class&rdquo; constructor to initialize the Obj state, using a new macro.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;vm.h&quot;
</pre><div class="source-file"><em>object.c</em></div>
<pre class="insert">

<span class="a">#define ALLOCATE_OBJ(type, objectType) \</span>
<span class="a">    (type*)allocateObject(sizeof(type), objectType)</span>
</pre><pre class="insert-after">

static ObjString* allocateString(char* chars, int length) {
</pre></div>
<div class="source-file-narrow"><em>object.c</em></div>

<p><span name="factored">Like</span> the previous macro, this exists mainly to
avoid the need to redundantly cast a <code>void*</code> back to the desired type. The
actual functionality is here:</p>
<aside name="factored">
<p>I admit this chapter has a sea of helper functions and macros to wade through. I
try to keep the code nicely factored, but that leads to a scattering of tiny
functions. They will pay off when we reuse them later.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#define ALLOCATE_OBJ(type, objectType) \
    (type*)allocateObject(sizeof(type), objectType)
</pre><div class="source-file"><em>object.c</em></div>
<pre class="insert">

<span class="k">static</span> <span class="t">Obj</span>* <span class="i">allocateObject</span>(<span class="t">size_t</span> <span class="i">size</span>, <span class="t">ObjType</span> <span class="i">type</span>) {
  <span class="t">Obj</span>* <span class="i">object</span> = (<span class="t">Obj</span>*)<span class="i">reallocate</span>(<span class="a">NULL</span>, <span class="n">0</span>, <span class="i">size</span>);
  <span class="i">object</span>-&gt;<span class="i">type</span> = <span class="i">type</span>;
  <span class="k">return</span> <span class="i">object</span>;
}
</pre><pre class="insert-after">

static ObjString* allocateString(char* chars, int length) {
</pre></div>
<div class="source-file-narrow"><em>object.c</em></div>

<p>It allocates an object of the given size on the heap. Note that the size is
<em>not</em> just the size of Obj itself. The caller passes in the number of bytes so
that there is room for the extra payload fields needed by the specific object
type being created.</p>
<p>Then it initializes the Obj state<span class="em">&mdash;</span>right now, that&rsquo;s just the type tag. This
function returns to <code>allocateString()</code>, which finishes initializing the ObjString
fields. <span name="viola"><em>Voilà</em></span>, we can compile and execute string
literals.</p>
<aside name="viola"><img src="image/strings/viola.png" class="above" alt="A viola." />
<p>Don&rsquo;t get &ldquo;voilà&rdquo; confused with &ldquo;viola&rdquo;. One means &ldquo;there it is&rdquo; and the other
is a string instrument, the middle child between a violin and a cello. Yes, I
did spend two hours drawing a viola just to mention that.</p>
</aside>
<h2><a href="#operations-on-strings" id="operations-on-strings"><small>19&#8202;.&#8202;4</small>Operations on Strings</a></h2>
<p>Our fancy strings are there, but they don&rsquo;t do much of anything yet. A good
first step is to make the existing print code not barf on the new value type.</p>
<div class="codehilite"><pre class="insert-before">    case VAL_NUMBER: printf(&quot;%g&quot;, AS_NUMBER(value)); break;
</pre><div class="source-file"><em>value.c</em><br>
in <em>printValue</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">VAL_OBJ</span>: <span class="i">printObject</span>(<span class="i">value</span>); <span class="k">break</span>;
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>printValue</em>()</div>

<p>If the value is a heap-allocated object, it defers to a helper function over in
the &ldquo;object&rdquo; module.</p>
<div class="codehilite"><pre class="insert-before">ObjString* copyString(const char* chars, int length);
</pre><div class="source-file"><em>object.h</em><br>
add after <em>copyString</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">printObject</span>(<span class="t">Value</span> <span class="i">value</span>);
</pre><pre class="insert-after">

static inline bool isObjType(Value value, ObjType type) {
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>copyString</em>()</div>

<p>The implementation looks like this:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>copyString</em>()</div>
<pre><span class="t">void</span> <span class="i">printObject</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="k">switch</span> (<span class="a">OBJ_TYPE</span>(<span class="i">value</span>)) {
    <span class="k">case</span> <span class="a">OBJ_STRING</span>:
      <span class="i">printf</span>(<span class="s">&quot;%s&quot;</span>, <span class="a">AS_CSTRING</span>(<span class="i">value</span>));
      <span class="k">break</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>copyString</em>()</div>

<p>We have only a single object type now, but this function will sprout additional
switch cases in later chapters. For string objects, it simply <span
name="term-2">prints</span> the character array as a C string.</p>
<aside name="term-2">
<p>I told you terminating the string would come in handy.</p>
</aside>
<p>The equality operators also need to gracefully handle strings. Consider:</p>
<div class="codehilite"><pre><span class="s">&quot;string&quot;</span> == <span class="s">&quot;string&quot;</span>
</pre></div>
<p>These are two separate string literals. The compiler will make two separate
calls to <code>copyString()</code>, create two distinct ObjString objects and store them as
two constants in the chunk. They are different objects in the heap. But our
users (and thus we) expect strings to have value equality. The above expression
should evaluate to <code>true</code>. That requires a little special support.</p>
<div class="codehilite"><pre class="insert-before">    case VAL_NUMBER: return AS_NUMBER(a) == AS_NUMBER(b);
</pre><div class="source-file"><em>value.c</em><br>
in <em>valuesEqual</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">VAL_OBJ</span>: {
      <span class="t">ObjString</span>* <span class="i">aString</span> = <span class="a">AS_STRING</span>(<span class="i">a</span>);
      <span class="t">ObjString</span>* <span class="i">bString</span> = <span class="a">AS_STRING</span>(<span class="i">b</span>);
      <span class="k">return</span> <span class="i">aString</span>-&gt;<span class="i">length</span> == <span class="i">bString</span>-&gt;<span class="i">length</span> &amp;&amp;
          <span class="i">memcmp</span>(<span class="i">aString</span>-&gt;<span class="i">chars</span>, <span class="i">bString</span>-&gt;<span class="i">chars</span>,
                 <span class="i">aString</span>-&gt;<span class="i">length</span>) == <span class="n">0</span>;
    }
</pre><pre class="insert-after">    default:         return false; // Unreachable.
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>valuesEqual</em>()</div>

<p>If the two values are both strings, then they are equal if their character
arrays contain the same characters, regardless of whether they are two separate
objects or the exact same one. This does mean that string equality is slower
than equality on other types since it has to walk the whole string. We&rsquo;ll revise
that <a href="hash-tables.html">later</a>, but this gives us the right semantics for now.</p>
<p>Finally, in order to use <code>memcmp()</code> and the new stuff in the &ldquo;object&rdquo; module, we
need a couple of includes. Here:</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdio.h&gt;
</pre><div class="source-file"><em>value.c</em></div>
<pre class="insert"><span class="a">#include &lt;string.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;memory.h&quot;
</pre></div>
<div class="source-file-narrow"><em>value.c</em></div>

<p>And here:</p>
<div class="codehilite"><pre class="insert-before">#include &lt;string.h&gt;

</pre><div class="source-file"><em>value.c</em></div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
</pre><pre class="insert-after">#include &quot;memory.h&quot;
</pre></div>
<div class="source-file-narrow"><em>value.c</em></div>

<h3><a href="#concatenation" id="concatenation"><small>19&#8202;.&#8202;4&#8202;.&#8202;1</small>Concatenation</a></h3>
<p>Full-grown languages provide lots of operations for working with strings<span class="em">&mdash;</span>access to individual characters, the string&rsquo;s length, changing case, splitting,
joining, searching, etc. When you implement your language, you&rsquo;ll likely want
all that. But for this book, we keep things <em>very</em> minimal.</p>
<p>The only interesting operation we support on strings is <code>+</code>. If you use that
operator on two string objects, it produces a new string that&rsquo;s a concatenation
of the two operands. Since Lox is dynamically typed, we can&rsquo;t tell which
behavior is needed at compile time because we don&rsquo;t know the types of the
operands until runtime. Thus, the <code>OP_ADD</code> instruction dynamically inspects the
operands and chooses the right operation.</p>
<div class="codehilite"><pre class="insert-before">      case OP_LESS:     BINARY_OP(BOOL_VAL, &lt;); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_ADD</span>: {
        <span class="k">if</span> (<span class="a">IS_STRING</span>(<span class="i">peek</span>(<span class="n">0</span>)) &amp;&amp; <span class="a">IS_STRING</span>(<span class="i">peek</span>(<span class="n">1</span>))) {
          <span class="i">concatenate</span>();
        } <span class="k">else</span> <span class="k">if</span> (<span class="a">IS_NUMBER</span>(<span class="i">peek</span>(<span class="n">0</span>)) &amp;&amp; <span class="a">IS_NUMBER</span>(<span class="i">peek</span>(<span class="n">1</span>))) {
          <span class="t">double</span> <span class="i">b</span> = <span class="a">AS_NUMBER</span>(<span class="i">pop</span>());
          <span class="t">double</span> <span class="i">a</span> = <span class="a">AS_NUMBER</span>(<span class="i">pop</span>());
          <span class="i">push</span>(<span class="a">NUMBER_VAL</span>(<span class="i">a</span> + <span class="i">b</span>));
        } <span class="k">else</span> {
          <span class="i">runtimeError</span>(
              <span class="s">&quot;Operands must be two numbers or two strings.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_SUBTRACT: BINARY_OP(NUMBER_VAL, -); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>If both operands are strings, it concatenates. If they&rsquo;re both numbers, it adds
them. Any other <span name="convert">combination</span> of operand types is a
runtime error.</p>
<aside name="convert" class="bottom">
<p>This is more conservative than most languages. In other languages, if one
operand is a string, the other can be any type and it will be implicitly
converted to a string before concatenating the two.</p>
<p>I think that&rsquo;s a fine feature, but would require writing tedious &ldquo;convert to
string&rdquo; code for each type, so I left it out of Lox.</p>
</aside>
<p>To concatenate strings, we define a new function.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>isFalsey</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">concatenate</span>() {
  <span class="t">ObjString</span>* <span class="i">b</span> = <span class="a">AS_STRING</span>(<span class="i">pop</span>());
  <span class="t">ObjString</span>* <span class="i">a</span> = <span class="a">AS_STRING</span>(<span class="i">pop</span>());

  <span class="t">int</span> <span class="i">length</span> = <span class="i">a</span>-&gt;<span class="i">length</span> + <span class="i">b</span>-&gt;<span class="i">length</span>;
  <span class="t">char</span>* <span class="i">chars</span> = <span class="a">ALLOCATE</span>(<span class="t">char</span>, <span class="i">length</span> + <span class="n">1</span>);
  <span class="i">memcpy</span>(<span class="i">chars</span>, <span class="i">a</span>-&gt;<span class="i">chars</span>, <span class="i">a</span>-&gt;<span class="i">length</span>);
  <span class="i">memcpy</span>(<span class="i">chars</span> + <span class="i">a</span>-&gt;<span class="i">length</span>, <span class="i">b</span>-&gt;<span class="i">chars</span>, <span class="i">b</span>-&gt;<span class="i">length</span>);
  <span class="i">chars</span>[<span class="i">length</span>] = <span class="s">&#39;\0&#39;</span>;

  <span class="t">ObjString</span>* <span class="i">result</span> = <span class="i">takeString</span>(<span class="i">chars</span>, <span class="i">length</span>);
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">result</span>));
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>isFalsey</em>()</div>

<p>It&rsquo;s pretty verbose, as C code that works with strings tends to be. First, we
calculate the length of the result string based on the lengths of the operands.
We allocate a character array for the result and then copy the two halves in. As
always, we carefully ensure the string is terminated.</p>
<p>In order to call <code>memcpy()</code>, the VM needs an include.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdio.h&gt;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert"><span class="a">#include &lt;string.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>

<p>Finally, we produce an ObjString to contain those characters. This time we use a
new function, <code>takeString()</code>.</p>
<div class="codehilite"><pre class="insert-before">};

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjString</em></div>
<pre class="insert"><span class="t">ObjString</span>* <span class="i">takeString</span>(<span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>);
</pre><pre class="insert-after">ObjString* copyString(const char* chars, int length);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>

<p>The implementation looks like this:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateString</em>()</div>
<pre><span class="t">ObjString</span>* <span class="i">takeString</span>(<span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>) {
  <span class="k">return</span> <span class="i">allocateString</span>(<span class="i">chars</span>, <span class="i">length</span>);
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateString</em>()</div>

<p>The previous <code>copyString()</code> function assumes it <em>cannot</em> take ownership of the
characters you pass in. Instead, it conservatively creates a copy of the
characters on the heap that the ObjString can own. That&rsquo;s the right thing for
string literals where the passed-in characters are in the middle of the source
string.</p>
<p>But, for concatenation, we&rsquo;ve already dynamically allocated a character array on
the heap. Making another copy of that would be redundant (and would mean
<code>concatenate()</code> has to remember to free its copy). Instead, this function claims
ownership of the string you give it.</p>
<p>As usual, stitching this functionality together requires a couple of includes.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;debug.h&quot;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
<span class="a">#include &quot;memory.h&quot;</span>
</pre><pre class="insert-after">#include &quot;vm.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>

<h2><a href="#freeing-objects" id="freeing-objects"><small>19&#8202;.&#8202;5</small>Freeing Objects</a></h2>
<p>Behold this innocuous-seeming expression:</p>
<div class="codehilite"><pre><span class="s">&quot;st&quot;</span> + <span class="s">&quot;ri&quot;</span> + <span class="s">&quot;ng&quot;</span>
</pre></div>
<p>When the compiler chews through this, it allocates an ObjString for each of
those three string literals and stores them in the chunk&rsquo;s constant table and
generates this <span name="stack">bytecode</span>:</p>
<aside name="stack">
<p>Here&rsquo;s what the stack looks like after each instruction:</p><img src="image/strings/stack.png" alt="The state of the stack at each instruction." />
</aside>
<div class="codehilite"><pre>0000    OP_CONSTANT         0 &quot;st&quot;
0002    OP_CONSTANT         1 &quot;ri&quot;
0004    OP_ADD
0005    OP_CONSTANT         2 &quot;ng&quot;
0007    OP_ADD
0008    OP_RETURN
</pre></div>
<p>The first two instructions push <code>"st"</code> and <code>"ri"</code> onto the stack. Then the
<code>OP_ADD</code> pops those and concatenates them. That dynamically allocates a new
<code>"stri"</code> string on the heap. The VM pushes that and then pushes the <code>"ng"</code>
constant. The last <code>OP_ADD</code> pops <code>"stri"</code> and <code>"ng"</code>, concatenates them, and
pushes the result: <code>"string"</code>. Great, that&rsquo;s what we expect.</p>
<p>But, wait. What happened to that <code>"stri"</code> string? We dynamically allocated it,
then the VM discarded it after concatenating it with <code>"ng"</code>. We popped it from
the stack and no longer have a reference to it, but we never freed its memory.
We&rsquo;ve got ourselves a classic memory leak.</p>
<p>Of course, it&rsquo;s perfectly fine for the <em>Lox program</em> to forget about
intermediate strings and not worry about freeing them. Lox automatically manages
memory on the user&rsquo;s behalf. The responsibility to manage memory doesn&rsquo;t
<em>disappear</em>. Instead, it falls on our shoulders as VM implementers.</p>
<p>The full <span name="borrowed">solution</span> is a <a href="garbage-collection.html">garbage collector</a> that
reclaims unused memory while the program is running. We&rsquo;ve got some other stuff
to get in place before we&rsquo;re ready to tackle that project. Until then, we are
living on borrowed time. The longer we wait to add the collector, the harder it
is to do.</p>
<aside name="borrowed">
<p>I&rsquo;ve seen a number of people implement large swathes of their language before
trying to start on the GC. For the kind of toy programs you typically run while
a language is being developed, you actually don&rsquo;t run out of memory before
reaching the end of the program, so this gets you surprisingly far.</p>
<p>But that underestimates how <em>hard</em> it is to add a garbage collector later. The
collector <em>must</em> ensure it can find every bit of memory that <em>is</em> still being
used so that it doesn&rsquo;t collect live data. There are hundreds of places a
language implementation can squirrel away a reference to some object. If you
don&rsquo;t find all of them, you get nightmarish bugs.</p>
<p>I&rsquo;ve seen language implementations die because it was too hard to get the GC in
later. If your language needs GC, get it working as soon as you can. It&rsquo;s a
crosscutting concern that touches the entire codebase.</p>
</aside>
<p>Today, we should at least do the bare minimum: avoid <em>leaking</em> memory by making
sure the VM can still find every allocated object even if the Lox program itself
no longer references them. There are many sophisticated techniques that advanced
memory managers use to allocate and track memory for objects. We&rsquo;re going to
take the simplest practical approach.</p>
<p>We&rsquo;ll create a linked list that stores every Obj. The VM can traverse that
list to find every single object that has been allocated on the heap, whether or
not the user&rsquo;s program or the VM&rsquo;s stack still has a reference to it.</p>
<p>We could define a separate linked list node struct but then we&rsquo;d have to
allocate those too. Instead, we&rsquo;ll use an <strong>intrusive list</strong><span class="em">&mdash;</span>the Obj struct
itself will be the linked list node. Each Obj gets a pointer to the next Obj in
the chain.</p>
<div class="codehilite"><pre class="insert-before">struct Obj {
  ObjType type;
</pre><div class="source-file"><em>object.h</em><br>
in struct <em>Obj</em></div>
<pre class="insert">  <span class="k">struct</span> <span class="t">Obj</span>* <span class="i">next</span>;
</pre><pre class="insert-after">};
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>Obj</em></div>

<p>The VM stores a pointer to the head of the list.</p>
<div class="codehilite"><pre class="insert-before">  Value* stackTop;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">Obj</span>* <span class="i">objects</span>;
</pre><pre class="insert-after">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>When we first initialize the VM, there are no allocated objects.</p>
<div class="codehilite"><pre class="insert-before">  resetStack();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">  <span class="i">vm</span>.<span class="i">objects</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>Every time we allocate an Obj, we insert it in the list.</p>
<div class="codehilite"><pre class="insert-before">  object-&gt;type = type;
</pre><div class="source-file"><em>object.c</em><br>
in <em>allocateObject</em>()</div>
<pre class="insert">

  <span class="i">object</span>-&gt;<span class="i">next</span> = <span class="i">vm</span>.<span class="i">objects</span>;
  <span class="i">vm</span>.<span class="i">objects</span> = <span class="i">object</span>;
</pre><pre class="insert-after">  return object;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateObject</em>()</div>

<p>Since this is a singly linked list, the easiest place to insert it is as the
head. That way, we don&rsquo;t need to also store a pointer to the tail and keep it
updated.</p>
<p>The &ldquo;object&rdquo; module is directly using the global <code>vm</code> variable from the &ldquo;vm&rdquo;
module, so we need to expose that externally.</p>
<div class="codehilite"><pre class="insert-before">} InterpretResult;

</pre><div class="source-file"><em>vm.h</em><br>
add after enum <em>InterpretResult</em></div>
<pre class="insert"><span class="k">extern</span> <span class="a">VM</span> <span class="i">vm</span>;

</pre><pre class="insert-after">void initVM();
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after enum <em>InterpretResult</em></div>

<p>Eventually, the garbage collector will free memory while the VM is still
running. But, even then, there will usually be unused objects still lingering in
memory when the user&rsquo;s program completes. The VM should free those too.</p>
<p>There&rsquo;s no sophisticated logic for that. Once the program is done, we can free
<em>every</em> object. We can and should implement that now.</p>
<div class="codehilite"><pre class="insert-before">void freeVM() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>freeVM</em>()</div>
<pre class="insert">  <span class="i">freeObjects</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>freeVM</em>()</div>

<p>That empty function we defined <a href="a-virtual-machine.html#an-instruction-execution-machine">way back when</a> finally does something! It
calls this:</p>
<div class="codehilite"><pre class="insert-before">void* reallocate(void* pointer, size_t oldSize, size_t newSize);
</pre><div class="source-file"><em>memory.h</em><br>
add after <em>reallocate</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">freeObjects</span>();
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>memory.h</em>, add after <em>reallocate</em>()</div>

<p>Here&rsquo;s how we free the objects:</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>reallocate</em>()</div>
<pre><span class="t">void</span> <span class="i">freeObjects</span>() {
  <span class="t">Obj</span>* <span class="i">object</span> = <span class="i">vm</span>.<span class="i">objects</span>;
  <span class="k">while</span> (<span class="i">object</span> != <span class="a">NULL</span>) {
    <span class="t">Obj</span>* <span class="i">next</span> = <span class="i">object</span>-&gt;<span class="i">next</span>;
    <span class="i">freeObject</span>(<span class="i">object</span>);
    <span class="i">object</span> = <span class="i">next</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>reallocate</em>()</div>

<p>This is a CS 101 textbook implementation of walking a linked list and freeing
its nodes. For each node, we call:</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>reallocate</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">freeObject</span>(<span class="t">Obj</span>* <span class="i">object</span>) {
  <span class="k">switch</span> (<span class="i">object</span>-&gt;<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">OBJ_STRING</span>: {
      <span class="t">ObjString</span>* <span class="i">string</span> = (<span class="t">ObjString</span>*)<span class="i">object</span>;
      <span class="a">FREE_ARRAY</span>(<span class="t">char</span>, <span class="i">string</span>-&gt;<span class="i">chars</span>, <span class="i">string</span>-&gt;<span class="i">length</span> + <span class="n">1</span>);
      <span class="a">FREE</span>(<span class="t">ObjString</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>reallocate</em>()</div>

<p>We aren&rsquo;t only freeing the Obj itself. Since some object types also allocate
other memory that they own, we also need a little type-specific code to handle
each object type&rsquo;s special needs. Here, that means we free the character array
and then free the ObjString. Those both use one last memory management macro.</p>
<div class="codehilite"><pre class="insert-before">    (type*)reallocate(NULL, 0, sizeof(type) * (count))
</pre><div class="source-file"><em>memory.h</em></div>
<pre class="insert">

<span class="a">#define FREE(type, pointer) reallocate(pointer, sizeof(type), 0)</span>
</pre><pre class="insert-after">

#define GROW_CAPACITY(capacity) \
</pre></div>
<div class="source-file-narrow"><em>memory.h</em></div>

<p>It&rsquo;s a tiny <span name="free">wrapper</span> around <code>reallocate()</code> that
&ldquo;resizes&rdquo; an allocation down to zero bytes.</p>
<aside name="free">
<p>Using <code>reallocate()</code> to free memory might seem pointless. Why not just call
<code>free()</code>? Later, this will help the VM track how much memory is still being
used. If all allocation and freeing goes through <code>reallocate()</code>, it&rsquo;s easy to
keep a running count of the number of bytes of allocated memory.</p>
</aside>
<p>As usual, we need an include to wire everything together.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>memory.h</em></div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
</pre><pre class="insert-after">

#define ALLOCATE(type, count) \
</pre></div>
<div class="source-file-narrow"><em>memory.h</em></div>

<p>Then in the implementation file:</p>
<div class="codehilite"><pre class="insert-before">#include &quot;memory.h&quot;
</pre><div class="source-file"><em>memory.c</em></div>
<pre class="insert"><span class="a">#include &quot;vm.h&quot;</span>
</pre><pre class="insert-after">

void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em></div>

<p>With this, our VM no longer leaks memory. Like a good C program, it cleans up
its mess before exiting. But it doesn&rsquo;t free any objects while the VM is
running. Later, when it&rsquo;s possible to write longer-running Lox programs, the VM
will eat more and more memory as it goes, not relinquishing a single byte until
the entire program is done.</p>
<p>We won&rsquo;t address that until we&rsquo;ve added <a href="garbage-collection.html">a real garbage collector</a>, but this
is a big step. We now have the infrastructure to support a variety of different
kinds of dynamically allocated objects. And we&rsquo;ve used that to add strings to
clox, one of the most used types in most programming languages. Strings in turn
enable us to build another fundamental data type, especially in dynamic
languages: the venerable <a href="hash-tables.html">hash table</a>. But that&rsquo;s for the next chapter<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Each string requires two separate dynamic allocations<span class="em">&mdash;</span>one for the
ObjString and a second for the character array. Accessing the characters
from a value requires two pointer indirections, which can be bad for
performance. A more efficient solution relies on a technique called
<strong><a href="https://en.wikipedia.org/wiki/Flexible_array_member">flexible array members</a></strong>. Use that to store the ObjString and its
character array in a single contiguous allocation.</p>
</li>
<li>
<p>When we create the ObjString for each string literal, we copy the characters
onto the heap. That way, when the string is later freed, we know it is safe
to free the characters too.</p>
<p>This is a simpler approach but wastes some memory, which might be a problem
on very constrained devices. Instead, we could keep track of which
ObjStrings own their character array and which are &ldquo;constant strings&rdquo; that
just point back to the original source string or some other non-freeable
location. Add support for this.</p>
</li>
<li>
<p>If Lox was your language, what would you have it do when a user tries to use
<code>+</code> with one string operand and the other some other type? Justify your
choice. What do other languages do?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: String Encoding</a></h2>
<p>In this book, I try not to shy away from the gnarly problems you&rsquo;ll run into in
a real language implementation. We might not always use the most <em>sophisticated</em>
solution<span class="em">&mdash;</span>it&rsquo;s an intro book after all<span class="em">&mdash;</span>but I don&rsquo;t think it&rsquo;s honest to
pretend the problem doesn&rsquo;t exist at all. However, I did skirt around one really
nasty conundrum: deciding how to represent strings.</p>
<p>There are two facets to a string encoding:</p>
<ul>
<li>
<p><strong>What is a single &ldquo;character&rdquo; in a string?</strong> How many different values are
there and what do they represent? The first widely adopted standard answer
to this was <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>. It gave you 127 different character values and
specified what they were. It was great<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>if you only ever cared about
English. While it has weird, mostly forgotten characters like &ldquo;record
separator&rdquo; and &ldquo;synchronous idle&rdquo;, it doesn&rsquo;t have a single umlaut, acute,
or grave. It can&rsquo;t represent &ldquo;jalapeño&rdquo;, &ldquo;naïve&rdquo;, <span
name="gruyere">&ldquo;Gruyère&rdquo;</span>, or &ldquo;Mötley Crüe&rdquo;.</p>
<aside name="gruyere">
<p>It goes without saying that a language that does not let one discuss Gruyère
or Mötley Crüe is a language not worth using.</p>
</aside>
<p>Next came <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>. Initially, it supported 16,384 different characters
(<strong>code points</strong>), which fit nicely in 16 bits with a couple of bits to
spare. Later that grew and grew, and now there are well over 100,000
different code points including such vital instruments of human
communication as 💩 (Unicode Character &lsquo;PILE OF POO&rsquo;, <code>U+1F4A9</code>).</p>
<p>Even that long list of code points is not enough to represent each possible
visible glyph a language might support. To handle that, Unicode also has
<strong>combining characters</strong> that modify a preceding code point. For example,
&ldquo;a&rdquo; followed by the combining character &ldquo;¨&rdquo; gives you &ldquo;ä&rdquo;. (To make things
more confusing Unicode <em>also</em> has a single code point that looks like &ldquo;ä&rdquo;.)</p>
<p>If a user accesses the fourth &ldquo;character&rdquo; in &ldquo;naïve&rdquo;, do they expect to get
back &ldquo;v&rdquo; or &ldquo;¨&rdquo;? The former means they are thinking of each code
point and its combining character as a single unit<span class="em">&mdash;</span>what Unicode calls an
<strong>extended grapheme cluster</strong><span class="em">&mdash;</span>the latter means they are thinking in
individual code points. Which do your users expect?</p>
</li>
<li>
<p><strong>How is a single unit represented in memory?</strong> Most systems using ASCII
gave a single byte to each character and left the high bit unused. Unicode
has a handful of common encodings. UTF-16 packs most code points into 16
bits. That was great when every code point fit in that size. When that
overflowed, they added <em>surrogate pairs</em> that use multiple 16-bit code units
to represent a single code point. UTF-32 is the next evolution of
UTF-16<span class="em">&mdash;</span>it gives a full 32 bits to each and every code point.</p>
<p>UTF-8 is more complex than either of those. It uses a variable number of
bytes to encode a code point. Lower-valued code points fit in fewer bytes.
Since each character may occupy a different number of bytes, you can&rsquo;t
directly index into the string to find a specific code point. If you want,
say, the 10th code point, you don&rsquo;t know how many bytes into the string that
is without walking and decoding all of the preceding ones.</p>
</li>
</ul>
<p>Choosing a character representation and encoding involves fundamental
trade-offs. Like many things in engineering, there&rsquo;s no <span
name="python">perfect</span> solution:</p>
<aside name="python">
<p>An example of how difficult this problem is comes from Python. The achingly long
transition from Python 2 to 3 is painful mostly because of its changes around
string encoding.</p>
</aside>
<ul>
<li>
<p>ASCII is memory efficient and fast, but it kicks non-Latin languages to the
side.</p>
</li>
<li>
<p>UTF-32 is fast and supports the whole Unicode range, but wastes a lot of
memory given that most code points do tend to be in the lower range of
values, where a full 32 bits aren&rsquo;t needed.</p>
</li>
<li>
<p>UTF-8 is memory efficient and supports the whole Unicode range, but its
variable-length encoding makes it slow to access arbitrary code points.</p>
</li>
<li>
<p>UTF-16 is worse than all of them<span class="em">&mdash;</span>an ugly consequence of Unicode
outgrowing its earlier 16-bit range. It&rsquo;s less memory efficient than UTF-8
but is still a variable-length encoding thanks to surrogate pairs. Avoid it
if you can. Alas, if your language needs to run on or interoperate with the
browser, the JVM, or the CLR, you might be stuck with it, since those all
use UTF-16 for their strings and you don&rsquo;t want to have to convert every
time you pass a string to the underlying system.</p>
</li>
</ul>
<p>One option is to take the maximal approach and do the &ldquo;rightest&rdquo; thing. Support
all the Unicode code points. Internally, select an encoding for each string
based on its contents<span class="em">&mdash;</span>use ASCII if every code point fits in a byte, UTF-16 if
there are no surrogate pairs, etc. Provide APIs to let users iterate over both
code points and extended grapheme clusters.</p>
<p>This covers all your bases but is really complex. It&rsquo;s a lot to implement,
debug, and optimize. When serializing strings or interoperating with other
systems, you have to deal with all of the encodings. Users need to understand
the two indexing APIs and know which to use when. This is the approach that
newer, big languages tend to take<span class="em">&mdash;</span>like Raku and Swift.</p>
<p>A simpler compromise is to always encode using UTF-8 and only expose an API that
works with code points. For users that want to work with grapheme clusters, let
them use a third-party library for that. This is less Latin-centric than ASCII
but not much more complex. You lose fast direct indexing by code point, but you
can usually live without that or afford to make it <em>O(n)</em> instead of <em>O(1)</em>.</p>
<p>If I were designing a big workhorse language for people writing large
applications, I&rsquo;d probably go with the maximal approach. For my little embedded
scripting language <a href="http://wren.io">Wren</a>, I went with UTF-8 and code points.</p>
</div>

<footer>
<a href="hash-tables.html" class="next">
  Next Chapter: &ldquo;Hash Tables&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Hash Tables &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Hash Tables<small>20</small></a></h3>

<ul>
    <li><a href="#an-array-of-buckets"><small>20.1</small> An Array of Buckets</a></li>
    <li><a href="#collision-resolution"><small>20.2</small> Collision Resolution</a></li>
    <li><a href="#hash-functions"><small>20.3</small> Hash Functions</a></li>
    <li><a href="#building-a-hash-table"><small>20.4</small> Building a Hash Table</a></li>
    <li><a href="#string-interning"><small>20.5</small> String Interning</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="strings.html" title="Strings" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="global-variables.html" title="Global Variables" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="strings.html" title="Strings" class="prev">←</a>
<a href="global-variables.html" title="Global Variables" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Hash Tables<small>20</small></a></h3>

<ul>
    <li><a href="#an-array-of-buckets"><small>20.1</small> An Array of Buckets</a></li>
    <li><a href="#collision-resolution"><small>20.2</small> Collision Resolution</a></li>
    <li><a href="#hash-functions"><small>20.3</small> Hash Functions</a></li>
    <li><a href="#building-a-hash-table"><small>20.4</small> Building a Hash Table</a></li>
    <li><a href="#string-interning"><small>20.5</small> String Interning</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="strings.html" title="Strings" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="global-variables.html" title="Global Variables" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">20</div>
  <h1>Hash Tables</h1>

<blockquote>
<p>Hash, x. There is no definition for this word<span class="em">&mdash;</span>nobody knows what hash is.</p>
<p><cite>Ambrose Bierce, <em>The Unabridged Devil&rsquo;s Dictionary</em></cite></p>
</blockquote>
<p>Before we can add variables to our burgeoning virtual machine, we need some way
to look up a value given a variable&rsquo;s name. Later, when we add classes, we&rsquo;ll
also need a way to store fields on instances. The perfect data structure for
these problems and others is a hash table.</p>
<p>You probably already know what a hash table is, even if you don&rsquo;t know it by
that name. If you&rsquo;re a Java programmer, you call them &ldquo;HashMaps&rdquo;. C# and Python
users call them &ldquo;dictionaries&rdquo;. In C++, it&rsquo;s an &ldquo;unordered map&rdquo;. &ldquo;Objects&rdquo; in
JavaScript and &ldquo;tables&rdquo; in Lua are hash tables under the hood, which is what
gives them their flexibility.</p>
<p>A hash table, whatever your language calls it, associates a set of <strong>keys</strong> with
a set of <strong>values</strong>. Each key/value pair is an <strong>entry</strong> in the table. Given a
key, you can look up its corresponding value. You can add new key/value pairs
and remove entries by key. If you add a new value for an existing key, it
replaces the previous entry.</p>
<p>Hash tables appear in so many languages because they are incredibly powerful.
Much of this power comes from one metric: given a key, a hash table returns the
corresponding value in <span name="constant">constant time</span>, <em>regardless
of how many keys are in the hash table</em>.</p>
<aside name="constant">
<p>More specifically, the <em>average-case</em> lookup time is constant. Worst-case
performance can be, well, worse. In practice, it&rsquo;s easy to avoid degenerate
behavior and stay on the happy path.</p>
</aside>
<p>That&rsquo;s pretty remarkable when you think about it. Imagine you&rsquo;ve got a big stack
of business cards and I ask you to find a certain person. The bigger the pile
is, the longer it will take. Even if the pile is nicely sorted and you&rsquo;ve got
the manual dexterity to do a binary search by hand, you&rsquo;re still talking
<em>O(log n)</em>. But with a <span name="rolodex">hash table</span>, it takes the
same time to find that business card when the stack has ten cards as when it has
a million.</p>
<aside name="rolodex">
<p>Stuff all those cards in a Rolodex<span class="em">&mdash;</span>does anyone even remember those things
anymore?<span class="em">&mdash;</span>with dividers for each letter, and you improve your speed
dramatically. As we&rsquo;ll see, that&rsquo;s not too far from the trick a hash table uses.</p>
</aside>
<h2><a href="#an-array-of-buckets" id="an-array-of-buckets"><small>20&#8202;.&#8202;1</small>An Array of Buckets</a></h2>
<p>A complete, fast hash table has a couple of moving parts. I&rsquo;ll introduce them
one at a time by working through a couple of toy problems and their solutions.
Eventually, we&rsquo;ll build up to a data structure that can associate any set of
names with their values.</p>
<p>For now, imagine if Lox was a <em>lot</em> more restricted in variable names. What if a
variable&rsquo;s name could only be a <span name="basic">single</span> lowercase
letter. How could we very efficiently represent a set of variable names and
their values?</p>
<aside name="basic">
<p>This limitation isn&rsquo;t <em>too</em> far-fetched. The initial versions of BASIC out of
Dartmouth allowed variable names to be only a single letter followed by one
optional digit.</p>
</aside>
<p>With only 26 possible variables (27 if you consider underscore a &ldquo;letter&rdquo;, I
guess), the answer is easy. Declare a fixed-size array with 26 elements. We&rsquo;ll
follow tradition and call each element a <strong>bucket</strong>. Each represents a variable
with <code>a</code> starting at index zero. If there&rsquo;s a value in the array at some
letter&rsquo;s index, then that key is present with that value. Otherwise, the bucket
is empty and that key/value pair isn&rsquo;t in the data structure.</p>
<aside name="bucket">
<p><img src="image/hash-tables/bucket-array.png" alt="A row of buckets, each
labeled with a letter of the alphabet." /></p>
</aside>
<p>Memory usage is great<span class="em">&mdash;</span>just a single, reasonably sized <span
name="bucket">array</span>. There&rsquo;s some waste from the empty buckets, but it&rsquo;s
not huge. There&rsquo;s no overhead for node pointers, padding, or other stuff you&rsquo;d
get with something like a linked list or tree.</p>
<p>Performance is even better. Given a variable name<span class="em">&mdash;</span>its character<span class="em">&mdash;</span>you can
subtract the ASCII value of <code>a</code> and use the result to index directly into the
array. Then you can either look up the existing value or store a new value
directly into that slot. It doesn&rsquo;t get much faster than that.</p>
<p>This is sort of our Platonic ideal data structure. Lightning fast, dead simple,
and compact in memory. As we add support for more complex keys, we&rsquo;ll have to
make some concessions, but this is what we&rsquo;re aiming for. Even once you add in
hash functions, dynamic resizing, and collision resolution, this is still the
core of every hash table out there<span class="em">&mdash;</span>a contiguous array of buckets that you
index directly into.</p>
<h3><a href="#load-factor-and-wrapped-keys" id="load-factor-and-wrapped-keys"><small>20&#8202;.&#8202;1&#8202;.&#8202;1</small>Load factor and wrapped keys</a></h3>
<p>Confining Lox to single-letter variables would make our job as implementers
easier, but it&rsquo;s probably no fun programming in a language that gives you only
26 storage locations. What if we loosened it a little and allowed variables up
to <span name="six">eight</span> characters long?</p>
<aside name="six">
<p>Again, this restriction isn&rsquo;t so crazy. Early linkers for C treated only the
first six characters of external identifiers as meaningful. Everything after
that was ignored. If you&rsquo;ve ever wondered why the C standard library is so
enamored of abbreviation<span class="em">&mdash;</span>looking at you, <code>strncmp()</code><span class="em">&mdash;</span>it turns out it
wasn&rsquo;t entirely because of the small screens (or teletypes!) of the day.</p>
</aside>
<p>That&rsquo;s small enough that we can pack all eight characters into a 64-bit integer
and easily turn the string into a number. We can then use it as an array index.
Or, at least, we could if we could somehow allocate a 295,148 <em>petabyte</em> array.
Memory&rsquo;s gotten cheaper over time, but not quite <em>that</em> cheap. Even if we could
make an array that big, it would be heinously wasteful. Almost every bucket
would be empty unless users started writing way bigger Lox programs than we&rsquo;ve
anticipated.</p>
<p>Even though our variable keys cover the full 64-bit numeric range, we clearly
don&rsquo;t need an array that large. Instead, we allocate an array with more than
enough capacity for the entries we need, but not unreasonably large. We map the
full 64-bit keys down to that smaller range by taking the value modulo the size
of the array. Doing that essentially folds the larger numeric range onto itself
until it fits the smaller range of array elements.</p>
<p>For example, say we want to store &ldquo;bagel&rdquo;. We allocate an array with eight
elements, plenty enough to store it and more later. We treat the key string as a
64-bit integer. On a little-endian machine like Intel, packing those characters
into a 64-bit word puts the first letter, &ldquo;b&rdquo; (ASCII value 98), in the
least-significant byte. We take that integer modulo the array size (<span
name="power-of-two">8</span>) to fit it in the bounds and get a bucket index, 2.
Then we store the value there as usual.</p>
<aside name="power-of-two">
<p>I&rsquo;m using powers of two for the array sizes here, but they don&rsquo;t need to be.
Some styles of hash tables work best with powers of two, including the one we&rsquo;ll
build in this book. Others prefer prime number array sizes or have other rules.</p>
</aside>
<p>Using the array size as a modulus lets us map the key&rsquo;s numeric range down to
fit an array of any size. We can thus control the number of buckets
independently of the key range. That solves our waste problem, but introduces a
new one. Any two variables whose key number has the same remainder when divided
by the array size will end up in the same bucket. Keys can <strong>collide</strong>. For
example, if we try to add &ldquo;jam&rdquo;, it also ends up in bucket 2.</p><img src="image/hash-tables/collision.png" alt="'Bagel' and 'jam' both end up in bucket index 2." />
<p>We have some control over this by tuning the array size. The bigger the array,
the fewer the indexes that get mapped to the same bucket and the fewer the
collisions that are likely to occur. Hash table implementers track this
collision likelihood by measuring the table&rsquo;s <strong>load factor</strong>. It&rsquo;s defined as
the number of entries divided by the number of buckets. So a hash table with
five entries and an array of 16 elements has a load factor of 0.3125. The higher
the load factor, the greater the chance of collisions.</p>
<p>One way we mitigate collisions is by resizing the array. Just like the dynamic
arrays we implemented earlier, we reallocate and grow the hash table&rsquo;s array as
it fills up. Unlike a regular dynamic array, though, we won&rsquo;t wait until the
array is <em>full</em>. Instead, we pick a desired load factor and grow the array when
it goes over that.</p>
<h2><a href="#collision-resolution" id="collision-resolution"><small>20&#8202;.&#8202;2</small>Collision Resolution</a></h2>
<p>Even with a very low load factor, collisions can still occur. The <a href="https://en.wikipedia.org/wiki/Birthday_problem"><em>birthday
paradox</em></a> tells us that as the number of entries in the hash table
increases, the chance of collision increases very quickly. We can pick a large
array size to reduce that, but it&rsquo;s a losing game. Say we wanted to store a
hundred items in a hash table. To keep the chance of collision below a
still-pretty-high 10%, we need an array with at least 47,015 elements. To get
the chance below 1% requires an array with 492,555 elements, over 4,000 empty
buckets for each one in use.</p>
<p>A low load factor can make collisions <span name="pigeon">rarer</span>, but the
<a href="https://en.wikipedia.org/wiki/Pigeonhole_principle"><em>pigeonhole principle</em></a> tells us we can never eliminate them entirely.
If you&rsquo;ve got five pet pigeons and four holes to put them in, at least one hole
is going to end up with more than one pigeon. With 18,446,744,073,709,551,616
different variable names, any reasonably sized array can potentially end up with
multiple keys in the same bucket.</p>
<p>Thus we still have to handle collisions gracefully when they occur. Users don&rsquo;t
like it when their programming language can look up variables correctly only
<em>most</em> of the time.</p>
<aside name="pigeon">
<p>Put these two funny-named mathematical rules together and you get this
observation: Take a birdhouse containing 365 pigeonholes, and use each pigeon&rsquo;s
birthday to assign it to a pigeonhole. You&rsquo;ll need only about 26 randomly chosen
pigeons before you get a greater than 50% chance of two pigeons in the same box.</p><img src="image/hash-tables/pigeons.png" alt="Two pigeons in the same hole." />
</aside>
<h3><a href="#separate-chaining" id="separate-chaining"><small>20&#8202;.&#8202;2&#8202;.&#8202;1</small>Separate chaining</a></h3>
<p>Techniques for resolving collisions fall into two broad categories. The first is
<strong>separate chaining</strong>. Instead of each bucket containing a single entry, we let
it contain a collection of them. In the classic implementation, each bucket
points to a linked list of entries. To look up an entry, you find its bucket and
then walk the list until you find an entry with the matching key.</p><img src="image/hash-tables/chaining.png" alt="An array with eight buckets. Bucket 2 links to a chain of two nodes. Bucket 5 links to a single node." />
<p>In catastrophically bad cases where every entry collides in the same bucket, the
data structure degrades into a single unsorted linked list with <em>O(n)</em> lookup.
In practice, it&rsquo;s easy to avoid that by controlling the load factor and how
entries get scattered across buckets. In typical separate-chained hash tables,
it&rsquo;s rare for a bucket to have more than one or two entries.</p>
<p>Separate chaining is conceptually simple<span class="em">&mdash;</span>it&rsquo;s literally an array of linked
lists. Most operations are straightforward to implement, even deletion which, as
we&rsquo;ll see, can be a pain. But it&rsquo;s not a great fit for modern CPUs. It has a lot
of overhead from pointers and tends to scatter little linked list <span
name="node">nodes</span> around in memory which isn&rsquo;t great for cache usage.</p>
<aside name="node">
<p>There are a few tricks to optimize this. Many implementations store the first
entry right in the bucket so that in the common case where there&rsquo;s only one, no
extra pointer indirection is needed. You can also make each linked list node
store a few entries to reduce the pointer overhead.</p>
</aside>
<h3><a href="#open-addressing" id="open-addressing"><small>20&#8202;.&#8202;2&#8202;.&#8202;2</small>Open addressing</a></h3>
<p>The other technique is <span name="open">called</span> <strong>open addressing</strong> or
(confusingly) <strong>closed hashing</strong>. With this technique, all entries live directly
in the bucket array, with one entry per bucket. If two entries collide in the
same bucket, we find a different empty bucket to use instead.</p>
<aside name="open">
<p>It&rsquo;s called &ldquo;open&rdquo; addressing because the entry may end up at an address
(bucket) outside of its preferred one. It&rsquo;s called &ldquo;closed&rdquo; hashing because all
of the entries stay inside the array of buckets.</p>
</aside>
<p>Storing all entries in a single, big, contiguous array is great for keeping the
memory representation simple and fast. But it makes all of the operations on the
hash table more complex. When inserting an entry, its bucket may be full,
sending us to look at another bucket. That bucket itself may be occupied and so
on. This process of finding an available bucket is called <strong>probing</strong>, and the
order that you examine buckets is a <strong>probe sequence</strong>.</p>
<p>There are a <span name="probe">number</span> of algorithms for determining
which buckets to probe and how to decide which entry goes in which bucket.
There&rsquo;s been a ton of research here because even slight tweaks can have a large
performance impact. And, on a data structure as heavily used as hash tables,
that performance impact touches a very large number of real-world programs
across a range of hardware capabilities.</p>
<aside name="probe">
<p>If you&rsquo;d like to learn more (and you should, because some of these are really
cool), look into &ldquo;double hashing&rdquo;, &ldquo;cuckoo hashing&rdquo;, &ldquo;Robin Hood hashing&rdquo;, and
anything those lead you to.</p>
</aside>
<p>As usual in this book, we&rsquo;ll pick the simplest one that gets the job done
efficiently. That&rsquo;s good old <strong>linear probing</strong>. When looking for an entry, we
look in the first bucket its key maps to. If it&rsquo;s not in there, we look in the
very next element in the array, and so on. If we reach the end, we wrap back
around to the beginning.</p>
<p>The good thing about linear probing is that it&rsquo;s cache friendly. Since you walk
the array directly in memory order, it keeps the CPU&rsquo;s cache lines full and
happy. The bad thing is that it&rsquo;s prone to <strong>clustering</strong>. If you have a lot of
entries with numerically similar key values, you can end up with a lot of
colliding, overflowing buckets right next to each other.</p>
<p>Compared to separate chaining, open addressing can be harder to wrap your head
around. I think of open addressing as similar to separate chaining except that
the &ldquo;list&rdquo; of nodes is threaded through the bucket array itself. Instead of
storing the links between them in pointers, the connections are calculated
implicitly by the order that you look through the buckets.</p>
<p>The tricky part is that more than one of these implicit lists may be interleaved
together. Let&rsquo;s walk through an example that covers all the interesting cases.
We&rsquo;ll ignore values for now and just worry about a set of keys. We start with an
empty array of 8 buckets.</p><img src="image/hash-tables/insert-1.png" alt="An array with eight empty buckets." class="wide" />
<p>We decide to insert &ldquo;bagel&rdquo;. The first letter, &ldquo;b&rdquo; (ASCII value 98), modulo the
array size (8) puts it in bucket 2.</p><img src="image/hash-tables/insert-2.png" alt="Bagel goes into bucket 2." class="wide" />
<p>Next, we insert &ldquo;jam&rdquo;. That also wants to go in bucket 2 (106 mod 8 = 2), but
that bucket&rsquo;s taken. We keep probing to the next bucket. It&rsquo;s empty, so we put
it there.</p><img src="image/hash-tables/insert-3.png" alt="Jam goes into bucket 3, since 2 is full." class="wide" />
<p>We insert &ldquo;fruit&rdquo;, which happily lands in bucket 6.</p><img src="image/hash-tables/insert-4.png" alt="Fruit goes into bucket 6." class="wide" />
<p>Likewise, &ldquo;migas&rdquo; can go in its preferred bucket 5.</p><img src="image/hash-tables/insert-5.png" alt="Migas goes into bucket 5." class="wide" />
<p>When we try to insert &ldquo;eggs&rdquo;, it also wants to be in bucket 5. That&rsquo;s full, so we
skip to 6. Bucket 6 is also full. Note that the entry in there is <em>not</em> part of
the same probe sequence. &ldquo;Fruit&rdquo; is in its preferred bucket, 6. So the 5 and 6
sequences have collided and are interleaved. We skip over that and finally put
&ldquo;eggs&rdquo; in bucket 7.</p><img src="image/hash-tables/insert-6.png" alt="Eggs goes into bucket 7 because 5 and 6 are full." class="wide" />
<p>We run into a similar problem with &ldquo;nuts&rdquo;. It can&rsquo;t land in 6 like it wants to.
Nor can it go into 7. So we keep going. But we&rsquo;ve reached the end of the array,
so we wrap back around to 0 and put it there.</p><img src="image/hash-tables/insert-7.png" alt="Nuts wraps around to bucket 0 because 6 and 7 are full." class="wide" />
<p>In practice, the interleaving turns out to not be much of a problem. Even in
separate chaining, we need to walk the list to check each entry&rsquo;s key because
multiple keys can reduce to the same bucket. With open addressing, we need to do
that same check, and that also covers the case where you are stepping over
entries that &ldquo;belong&rdquo; to a different original bucket.</p>
<h2><a href="#hash-functions" id="hash-functions"><small>20&#8202;.&#8202;3</small>Hash Functions</a></h2>
<p>We can now build ourselves a reasonably efficient table for storing variable
names up to eight characters long, but that limitation is still annoying. In
order to relax the last constraint, we need a way to take a string of any length
and convert it to a fixed-size integer.</p>
<p>Finally, we get to the &ldquo;hash&rdquo; part of &ldquo;hash table&rdquo;. A <strong>hash function</strong> takes
some larger blob of data and &ldquo;hashes&rdquo; it to produce a fixed-size integer <strong>hash
code</strong> whose value depends on all of the bits of the original data. A <span
name="crypto">good</span> hash function has three main goals:</p>
<aside name="crypto">
<p>Hash functions are also used for cryptography. In that domain, &ldquo;good&rdquo; has a
<em>much</em> more stringent definition to avoid exposing details about the data being
hashed. We, thankfully, don&rsquo;t need to worry about those concerns for this book.</p>
</aside>
<ul>
<li>
<p><strong>It must be <em>deterministic</em>.</strong> The same input must always hash to the same
number. If the same variable ends up in different buckets at different
points in time, it&rsquo;s gonna get really hard to find it.</p>
</li>
<li>
<p><strong>It must be <em>uniform</em>.</strong> Given a typical set of inputs, it should produce a
wide and evenly distributed range of output numbers, with as few clumps or
patterns as possible. We want it to <span name="scatter">scatter</span>
values across the whole numeric range to minimize collisions and clustering.</p>
</li>
<li>
<p><strong>It must be <em>fast</em>.</strong> Every operation on the hash table requires us to hash
the key first. If hashing is slow, it can potentially cancel out the speed
of the underlying array storage.</p>
</li>
</ul>
<aside name="scatter">
<p>One of the original names for a hash table was &ldquo;scatter table&rdquo; because it takes
the entries and scatters them throughout the array. The word &ldquo;hash&rdquo; came from
the idea that a hash function takes the input data, chops it up, and tosses it
all together into a pile to come up with a single number from all of those bits.</p>
</aside>
<p>There is a veritable pile of hash functions out there. Some are old and
optimized for architectures no one uses anymore. Some are designed to be fast,
others cryptographically secure. Some take advantage of vector instructions and
cache sizes for specific chips, others aim to maximize portability.</p>
<p>There are people out there for whom designing and evaluating hash functions is,
like, their <em>jam</em>. I admire them, but I&rsquo;m not mathematically astute enough to
<em>be</em> one. So for clox, I picked a simple, well-worn hash function called
<a href="http://www.isthe.com/chongo/tech/comp/fnv/">FNV-1a</a> that&rsquo;s served me fine over the years. Consider <span
name="thing">trying</span> out different ones in your code and see if they make
a difference.</p>
<aside name="thing">
<p>Who knows, maybe hash functions could turn out to be your thing too?</p>
</aside>
<p>OK, that&rsquo;s a quick run through of buckets, load factors, open addressing,
collision resolution, and hash functions. That&rsquo;s an awful lot of text and not a
lot of real code. Don&rsquo;t worry if it still seems vague. Once we&rsquo;re done coding it
up, it will all click into place.</p>
<h2><a href="#building-a-hash-table" id="building-a-hash-table"><small>20&#8202;.&#8202;4</small>Building a Hash Table</a></h2>
<p>The great thing about hash tables compared to other classic techniques like
balanced search trees is that the actual data structure is so simple. Ours goes
into a new module.</p>
<div class="codehilite"><div class="source-file"><em>table.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_table_h</span>
<span class="a">#define clox_table_h</span>

<span class="a">#include &quot;common.h&quot;</span>
<span class="a">#include &quot;value.h&quot;</span>

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">int</span> <span class="i">count</span>;
  <span class="t">int</span> <span class="i">capacity</span>;
  <span class="t">Entry</span>* <span class="i">entries</span>;
} <span class="t">Table</span>;

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>table.h</em>, create new file</div>

<p>A hash table is an array of entries. As in our dynamic array earlier, we keep
track of both the allocated size of the array (<code>capacity</code>) and the number of
key/value pairs currently stored in it (<code>count</code>). The ratio of count to capacity
is exactly the load factor of the hash table.</p>
<p>Each entry is one of these:</p>
<div class="codehilite"><pre class="insert-before">#include &quot;value.h&quot;
</pre><div class="source-file"><em>table.h</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">ObjString</span>* <span class="i">key</span>;
  <span class="t">Value</span> <span class="i">value</span>;
} <span class="t">Entry</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>table.h</em></div>

<p>It&rsquo;s a simple key/value pair. Since the key is always a <span
name="string">string</span>, we store the ObjString pointer directly instead of
wrapping it in a Value. It&rsquo;s a little faster and smaller this way.</p>
<aside name="string">
<p>In clox, we only need to support keys that are strings. Handling other types of
keys doesn&rsquo;t add much complexity. As long as you can compare two objects for
equality and reduce them to sequences of bits, it&rsquo;s easy to use them as hash
keys.</p>
</aside>
<p>To create a new, empty hash table, we declare a constructor-like function.</p>
<div class="codehilite"><pre class="insert-before">} Table;

</pre><div class="source-file"><em>table.h</em><br>
add after struct <em>Table</em></div>
<pre class="insert"><span class="t">void</span> <span class="i">initTable</span>(<span class="t">Table</span>* <span class="i">table</span>);

</pre><pre class="insert-after">#endif
</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after struct <em>Table</em></div>

<p>We need a new implementation file to define that. While we&rsquo;re at it, let&rsquo;s get
all of the pesky includes out of the way.</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
create new file</div>
<pre><span class="a">#include &lt;stdlib.h&gt;</span>
<span class="a">#include &lt;string.h&gt;</span>

<span class="a">#include &quot;memory.h&quot;</span>
<span class="a">#include &quot;object.h&quot;</span>
<span class="a">#include &quot;table.h&quot;</span>
<span class="a">#include &quot;value.h&quot;</span>

<span class="t">void</span> <span class="i">initTable</span>(<span class="t">Table</span>* <span class="i">table</span>) {
  <span class="i">table</span>-&gt;<span class="i">count</span> = <span class="n">0</span>;
  <span class="i">table</span>-&gt;<span class="i">capacity</span> = <span class="n">0</span>;
  <span class="i">table</span>-&gt;<span class="i">entries</span> = <span class="a">NULL</span>;
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, create new file</div>

<p>As in our dynamic value array type, a hash table initially starts with zero
capacity and a <code>NULL</code> array. We don&rsquo;t allocate anything until needed. Assuming
we do eventually allocate something, we need to be able to free it too.</p>
<div class="codehilite"><pre class="insert-before">void initTable(Table* table);
</pre><div class="source-file"><em>table.h</em><br>
add after <em>initTable</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">freeTable</span>(<span class="t">Table</span>* <span class="i">table</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after <em>initTable</em>()</div>

<p>And its glorious implementation:</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
add after <em>initTable</em>()</div>
<pre><span class="t">void</span> <span class="i">freeTable</span>(<span class="t">Table</span>* <span class="i">table</span>) {
  <span class="a">FREE_ARRAY</span>(<span class="t">Entry</span>, <span class="i">table</span>-&gt;<span class="i">entries</span>, <span class="i">table</span>-&gt;<span class="i">capacity</span>);
  <span class="i">initTable</span>(<span class="i">table</span>);
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>initTable</em>()</div>

<p>Again, it looks just like a dynamic array. In fact, you can think of a hash
table as basically a dynamic array with a really strange policy for inserting
items. We don&rsquo;t need to check for <code>NULL</code> here since <code>FREE_ARRAY()</code> already
handles that gracefully.</p>
<h3><a href="#hashing-strings" id="hashing-strings"><small>20&#8202;.&#8202;4&#8202;.&#8202;1</small>Hashing strings</a></h3>
<p>Before we can start putting entries in the table, we need to, well, hash them.
To ensure that the entries get distributed uniformly throughout the array, we
want a good hash function that looks at all of the bits of the key string. If it
looked at, say, only the first few characters, then a series of strings that all
shared the same prefix would end up colliding in the same bucket.</p>
<p>On the other hand, walking the entire string to calculate the hash is kind of
slow. We&rsquo;d lose some of the performance benefit of the hash table if we had to
walk the string every time we looked for a key in the table. So we&rsquo;ll do the
obvious thing: cache it.</p>
<p>Over in the &ldquo;object&rdquo; module in ObjString, we add:</p>
<div class="codehilite"><pre class="insert-before">  char* chars;
</pre><div class="source-file"><em>object.h</em><br>
in struct <em>ObjString</em></div>
<pre class="insert">  <span class="t">uint32_t</span> <span class="i">hash</span>;
</pre><pre class="insert-after">};
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjString</em></div>

<p>Each ObjString stores the hash code for its string. Since strings are immutable
in Lox, we can calculate the hash code once up front and be certain that it will
never get invalidated. Caching it eagerly makes a kind of sense: allocating the
string and copying its characters over is already an <em>O(n)</em> operation, so it&rsquo;s a
good time to also do the <em>O(n)</em> calculation of the string&rsquo;s hash.</p>
<p>Whenever we call the internal function to allocate a string, we pass in its
hash code.</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
function <em>allocateString</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">ObjString</span>* <span class="i">allocateString</span>(<span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>,
                                 <span class="t">uint32_t</span> <span class="i">hash</span>) {
</pre><pre class="insert-after">  ObjString* string = ALLOCATE_OBJ(ObjString, OBJ_STRING);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, function <em>allocateString</em>(), replace 1 line</div>

<p>That function simply stores the hash in the struct.</p>
<div class="codehilite"><pre class="insert-before">  string-&gt;chars = chars;
</pre><div class="source-file"><em>object.c</em><br>
in <em>allocateString</em>()</div>
<pre class="insert">  <span class="i">string</span>-&gt;<span class="i">hash</span> = <span class="i">hash</span>;
</pre><pre class="insert-after">  return string;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateString</em>()</div>

<p>The fun happens over at the callers. <code>allocateString()</code> is called from two
places: the function that copies a string and the one that takes ownership of an
existing dynamically allocated string. We&rsquo;ll start with the first.</p>
<div class="codehilite"><pre class="insert-before">ObjString* copyString(const char* chars, int length) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>copyString</em>()</div>
<pre class="insert">  <span class="t">uint32_t</span> <span class="i">hash</span> = <span class="i">hashString</span>(<span class="i">chars</span>, <span class="i">length</span>);
</pre><pre class="insert-after">  char* heapChars = ALLOCATE(char, length + 1);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>copyString</em>()</div>

<p>No magic here. We calculate the hash code and then pass it along.</p>
<div class="codehilite"><pre class="insert-before">  memcpy(heapChars, chars, length);
  heapChars[length] = '\0';
</pre><div class="source-file"><em>object.c</em><br>
in <em>copyString</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">return</span> <span class="i">allocateString</span>(<span class="i">heapChars</span>, <span class="i">length</span>, <span class="i">hash</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>copyString</em>(), replace 1 line</div>

<p>The other string function is similar.</p>
<div class="codehilite"><pre class="insert-before">ObjString* takeString(char* chars, int length) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>takeString</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">uint32_t</span> <span class="i">hash</span> = <span class="i">hashString</span>(<span class="i">chars</span>, <span class="i">length</span>);
  <span class="k">return</span> <span class="i">allocateString</span>(<span class="i">chars</span>, <span class="i">length</span>, <span class="i">hash</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>takeString</em>(), replace 1 line</div>

<p>The interesting code is over here:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateString</em>()</div>
<pre><span class="k">static</span> <span class="t">uint32_t</span> <span class="i">hashString</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">key</span>, <span class="t">int</span> <span class="i">length</span>) {
  <span class="t">uint32_t</span> <span class="i">hash</span> = <span class="n">2166136261u</span>;
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">length</span>; <span class="i">i</span>++) {
    <span class="i">hash</span> ^= (<span class="t">uint8_t</span>)<span class="i">key</span>[<span class="i">i</span>];
    <span class="i">hash</span> *= <span class="n">16777619</span>;
  }
  <span class="k">return</span> <span class="i">hash</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateString</em>()</div>

<p>This is the actual bona fide &ldquo;hash function&rdquo; in clox. The algorithm is called
&ldquo;FNV-1a&rdquo;, and is the shortest decent hash function I know. Brevity is certainly
a virtue in a book that aims to show you every line of code.</p>
<p>The basic idea is pretty simple, and many hash functions follow the same
pattern. You start with some initial hash value, usually a constant with certain
carefully chosen mathematical properties. Then you walk the data to be hashed.
For each byte (or sometimes word), you mix the bits into the hash value somehow,
and then scramble the resulting bits around some.</p>
<p>What it means to &ldquo;mix&rdquo; and &ldquo;scramble&rdquo; can get pretty sophisticated. Ultimately,
though, the basic goal is <em>uniformity</em><span class="em">&mdash;</span>we want the resulting hash values to
be as widely scattered around the numeric range as possible to avoid collisions
and clustering.</p>
<h3><a href="#inserting-entries" id="inserting-entries"><small>20&#8202;.&#8202;4&#8202;.&#8202;2</small>Inserting entries</a></h3>
<p>Now that string objects know their hash code, we can start putting them into
hash tables.</p>
<div class="codehilite"><pre class="insert-before">void freeTable(Table* table);
</pre><div class="source-file"><em>table.h</em><br>
add after <em>freeTable</em>()</div>
<pre class="insert"><span class="t">bool</span> <span class="i">tableSet</span>(<span class="t">Table</span>* <span class="i">table</span>, <span class="t">ObjString</span>* <span class="i">key</span>, <span class="t">Value</span> <span class="i">value</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after <em>freeTable</em>()</div>

<p>This function adds the given key/value pair to the given hash table. If an entry
for that key is already present, the new value overwrites the old value. The
function returns <code>true</code> if a new entry was added. Here&rsquo;s the implementation:</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
add after <em>freeTable</em>()</div>
<pre><span class="t">bool</span> <span class="i">tableSet</span>(<span class="t">Table</span>* <span class="i">table</span>, <span class="t">ObjString</span>* <span class="i">key</span>, <span class="t">Value</span> <span class="i">value</span>) {
  <span class="t">Entry</span>* <span class="i">entry</span> = <span class="i">findEntry</span>(<span class="i">table</span>-&gt;<span class="i">entries</span>, <span class="i">table</span>-&gt;<span class="i">capacity</span>, <span class="i">key</span>);
  <span class="t">bool</span> <span class="i">isNewKey</span> = <span class="i">entry</span>-&gt;<span class="i">key</span> == <span class="a">NULL</span>;
  <span class="k">if</span> (<span class="i">isNewKey</span>) <span class="i">table</span>-&gt;<span class="i">count</span>++;

  <span class="i">entry</span>-&gt;<span class="i">key</span> = <span class="i">key</span>;
  <span class="i">entry</span>-&gt;<span class="i">value</span> = <span class="i">value</span>;
  <span class="k">return</span> <span class="i">isNewKey</span>;
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>freeTable</em>()</div>

<p>Most of the interesting logic is in <code>findEntry()</code> which we&rsquo;ll get to soon. That
function&rsquo;s job is to take a key and figure out which bucket in the array it
should go in. It returns a pointer to that bucket<span class="em">&mdash;</span>the address of the Entry in
the array.</p>
<p>Once we have a bucket, inserting is straightforward. We update the hash table&rsquo;s
size, taking care to not increase the count if we overwrote the value for an
already-present key. Then we copy the key and value into the corresponding
fields in the Entry.</p>
<p>We&rsquo;re missing a little something here, though. We haven&rsquo;t actually allocated the
Entry array yet. Oops! Before we can insert anything, we need to make sure we
have an array, and that it&rsquo;s big enough.</p>
<div class="codehilite"><pre class="insert-before">bool tableSet(Table* table, ObjString* key, Value value) {
</pre><div class="source-file"><em>table.c</em><br>
in <em>tableSet</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">table</span>-&gt;<span class="i">count</span> + <span class="n">1</span> &gt; <span class="i">table</span>-&gt;<span class="i">capacity</span> * <span class="a">TABLE_MAX_LOAD</span>) {
    <span class="t">int</span> <span class="i">capacity</span> = <span class="a">GROW_CAPACITY</span>(<span class="i">table</span>-&gt;<span class="i">capacity</span>);
    <span class="i">adjustCapacity</span>(<span class="i">table</span>, <span class="i">capacity</span>);
  }

</pre><pre class="insert-after">  Entry* entry = findEntry(table-&gt;entries, table-&gt;capacity, key);
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, in <em>tableSet</em>()</div>

<p>This is similar to the code we wrote a while back for growing a dynamic array.
If we don&rsquo;t have enough capacity to insert an item, we reallocate and grow the
array. The <code>GROW_CAPACITY()</code> macro takes an existing capacity and grows it by
a multiple to ensure that we get amortized constant performance over a series
of inserts.</p>
<p>The interesting difference here is that <code>TABLE_MAX_LOAD</code> constant.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;value.h&quot;

</pre><div class="source-file"><em>table.c</em></div>
<pre class="insert"><span class="a">#define TABLE_MAX_LOAD 0.75</span>

</pre><pre class="insert-after">void initTable(Table* table) {
</pre></div>
<div class="source-file-narrow"><em>table.c</em></div>

<p>This is how we manage the table&rsquo;s <span name="75">load</span> factor. We don&rsquo;t
grow when the capacity is completely full. Instead, we grow the array before
then, when the array becomes at least 75% full.</p>
<aside name="75">
<p>Ideal max load factor varies based on the hash function, collision-handling
strategy, and typical keysets you&rsquo;ll see. Since a toy language like Lox doesn&rsquo;t
have &ldquo;real world&rdquo; data sets, it&rsquo;s hard to optimize this, and I picked 75%
somewhat arbitrarily. When you build your own hash tables, benchmark and tune
this.</p>
</aside>
<p>We&rsquo;ll get to the implementation of <code>adjustCapacity()</code> soon. First, let&rsquo;s look
at that <code>findEntry()</code> function you&rsquo;ve been wondering about.</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
add after <em>freeTable</em>()</div>
<pre><span class="k">static</span> <span class="t">Entry</span>* <span class="i">findEntry</span>(<span class="t">Entry</span>* <span class="i">entries</span>, <span class="t">int</span> <span class="i">capacity</span>,
                        <span class="t">ObjString</span>* <span class="i">key</span>) {
  <span class="t">uint32_t</span> <span class="i">index</span> = <span class="i">key</span>-&gt;<span class="i">hash</span> % <span class="i">capacity</span>;
  <span class="k">for</span> (;;) {
    <span class="t">Entry</span>* <span class="i">entry</span> = &amp;<span class="i">entries</span>[<span class="i">index</span>];
    <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span> == <span class="i">key</span> || <span class="i">entry</span>-&gt;<span class="i">key</span> == <span class="a">NULL</span>) {
      <span class="k">return</span> <span class="i">entry</span>;
    }

    <span class="i">index</span> = (<span class="i">index</span> + <span class="n">1</span>) % <span class="i">capacity</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>freeTable</em>()</div>

<p>This function is the real core of the hash table. It&rsquo;s responsible for taking a
key and an array of buckets, and figuring out which bucket the entry belongs in.
This function is also where linear probing and collision handling come into
play. We&rsquo;ll use <code>findEntry()</code> both to look up existing entries in the hash
table and to decide where to insert new ones.</p>
<p>For all that, there isn&rsquo;t much to it. First, we use modulo to map the key&rsquo;s hash
code to an index within the array&rsquo;s bounds. That gives us a bucket index where,
ideally, we&rsquo;ll be able to find or place the entry.</p>
<p>There are a few cases to check for:</p>
<ul>
<li>
<p>If the key for the Entry at that array index is <code>NULL</code>, then the bucket is
empty. If we&rsquo;re using <code>findEntry()</code> to look up something in the hash table,
this means it isn&rsquo;t there. If we&rsquo;re using it to insert, it means we&rsquo;ve found
a place to add the new entry.</p>
</li>
<li>
<p>If the key in the bucket is <span name="equal">equal</span> to the key we&rsquo;re
looking for, then that key is already present in the table. If we&rsquo;re doing a
lookup, that&rsquo;s good<span class="em">&mdash;</span>we&rsquo;ve found the key we seek. If we&rsquo;re doing an insert,
this means we&rsquo;ll be replacing the value for that key instead of adding a new
entry.</p>
</li>
</ul>
<aside name="equal">
<p>It looks like we&rsquo;re using <code>==</code> to see if two strings are equal. That doesn&rsquo;t
work, does it? There could be two copies of the same string at different places
in memory. Fear not, astute reader. We&rsquo;ll solve this further on. And, strangely
enough, it&rsquo;s a hash table that provides the tool we need.</p>
</aside>
<ul>
<li>Otherwise, the bucket has an entry in it, but with a different key. This is
a collision. In that case, we start probing. That&rsquo;s what that <code>for</code> loop
does. We start at the bucket where the entry would ideally go. If that
bucket is empty or has the same key, we&rsquo;re done. Otherwise, we advance to
the next element<span class="em">&mdash;</span>this is the <em>linear</em> part of &ldquo;linear probing&rdquo;<span class="em">&mdash;</span>and
check there. If we go past the end of the array, that second modulo operator
wraps us back around to the beginning.</li>
</ul>
<p>We exit the loop when we find either an empty bucket or a bucket with the same
key as the one we&rsquo;re looking for. You might be wondering about an infinite loop.
What if we collide with <em>every</em> bucket? Fortunately, that can&rsquo;t happen thanks to
our load factor. Because we grow the array as soon as it gets close to being
full, we know there will always be empty buckets.</p>
<p>We return directly from within the loop, yielding a pointer to the found Entry
so the caller can either insert something into it or read from it. Way back in
<code>tableSet()</code>, the function that first kicked this off, we store the new entry in
that returned bucket and we&rsquo;re done.</p>
<h3><a href="#allocating-and-resizing" id="allocating-and-resizing"><small>20&#8202;.&#8202;4&#8202;.&#8202;3</small>Allocating and resizing</a></h3>
<p>Before we can put entries in the hash table, we do need a place to actually
store them. We need to allocate an array of buckets. That happens in this
function:</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
add after <em>findEntry</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">adjustCapacity</span>(<span class="t">Table</span>* <span class="i">table</span>, <span class="t">int</span> <span class="i">capacity</span>) {
  <span class="t">Entry</span>* <span class="i">entries</span> = <span class="a">ALLOCATE</span>(<span class="t">Entry</span>, <span class="i">capacity</span>);
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">capacity</span>; <span class="i">i</span>++) {
    <span class="i">entries</span>[<span class="i">i</span>].<span class="i">key</span> = <span class="a">NULL</span>;
    <span class="i">entries</span>[<span class="i">i</span>].<span class="i">value</span> = <span class="a">NIL_VAL</span>;
  }

  <span class="i">table</span>-&gt;<span class="i">entries</span> = <span class="i">entries</span>;
  <span class="i">table</span>-&gt;<span class="i">capacity</span> = <span class="i">capacity</span>;
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>findEntry</em>()</div>

<p>We create a bucket array with <code>capacity</code> entries. After we allocate the array,
we initialize every element to be an empty bucket and then store the array (and
its capacity) in the hash table&rsquo;s main struct. This code is fine for when we
insert the very first entry into the table, and we require the first allocation
of the array. But what about when we already have one and we need to grow it?</p>
<p>Back when we were doing a dynamic array, we could just use <code>realloc()</code> and let
the C standard library copy everything over. That doesn&rsquo;t work for a hash table.
Remember that to choose the bucket for each entry, we take its hash key <em>modulo
the array size</em>. That means that when the array size changes, entries may end up
in different buckets.</p>
<p>Those new buckets may have new collisions that we need to deal with. So the
simplest way to get every entry where it belongs is to rebuild the table from
scratch by re-inserting every entry into the new empty array.</p>
<div class="codehilite"><pre class="insert-before">    entries[i].value = NIL_VAL;
  }
</pre><div class="source-file"><em>table.c</em><br>
in <em>adjustCapacity</em>()</div>
<pre class="insert">

  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">table</span>-&gt;<span class="i">capacity</span>; <span class="i">i</span>++) {
    <span class="t">Entry</span>* <span class="i">entry</span> = &amp;<span class="i">table</span>-&gt;<span class="i">entries</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span> == <span class="a">NULL</span>) <span class="k">continue</span>;

    <span class="t">Entry</span>* <span class="i">dest</span> = <span class="i">findEntry</span>(<span class="i">entries</span>, <span class="i">capacity</span>, <span class="i">entry</span>-&gt;<span class="i">key</span>);
    <span class="i">dest</span>-&gt;<span class="i">key</span> = <span class="i">entry</span>-&gt;<span class="i">key</span>;
    <span class="i">dest</span>-&gt;<span class="i">value</span> = <span class="i">entry</span>-&gt;<span class="i">value</span>;
  }
</pre><pre class="insert-after">

  table-&gt;entries = entries;
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, in <em>adjustCapacity</em>()</div>

<p>We walk through the old array front to back. Any time we find a non-empty
bucket, we insert that entry into the new array. We use <code>findEntry()</code>, passing
in the <em>new</em> array instead of the one currently stored in the Table. (This is
why <code>findEntry()</code> takes a pointer directly to an Entry array and not the whole
<code>Table</code> struct. That way, we can pass the new array and capacity before we&rsquo;ve
stored those in the struct.)</p>
<p>After that&rsquo;s done, we can release the memory for the old array.</p>
<div class="codehilite"><pre class="insert-before">    dest-&gt;value = entry-&gt;value;
  }

</pre><div class="source-file"><em>table.c</em><br>
in <em>adjustCapacity</em>()</div>
<pre class="insert">  <span class="a">FREE_ARRAY</span>(<span class="t">Entry</span>, <span class="i">table</span>-&gt;<span class="i">entries</span>, <span class="i">table</span>-&gt;<span class="i">capacity</span>);
</pre><pre class="insert-after">  table-&gt;entries = entries;
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, in <em>adjustCapacity</em>()</div>

<p>With that, we have a hash table that we can stuff as many entries into as we
like. It handles overwriting existing keys and growing itself as needed to
maintain the desired load capacity.</p>
<p>While we&rsquo;re at it, let&rsquo;s also define a helper function for copying all of the
entries of one hash table into another.</p>
<div class="codehilite"><pre class="insert-before">bool tableSet(Table* table, ObjString* key, Value value);
</pre><div class="source-file"><em>table.h</em><br>
add after <em>tableSet</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">tableAddAll</span>(<span class="t">Table</span>* <span class="i">from</span>, <span class="t">Table</span>* <span class="i">to</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after <em>tableSet</em>()</div>

<p>We won&rsquo;t need this until much later when we support method inheritance, but we
may as well implement it now while we&rsquo;ve got all the hash table stuff fresh in
our minds.</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
add after <em>tableSet</em>()</div>
<pre><span class="t">void</span> <span class="i">tableAddAll</span>(<span class="t">Table</span>* <span class="i">from</span>, <span class="t">Table</span>* <span class="i">to</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">from</span>-&gt;<span class="i">capacity</span>; <span class="i">i</span>++) {
    <span class="t">Entry</span>* <span class="i">entry</span> = &amp;<span class="i">from</span>-&gt;<span class="i">entries</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span> != <span class="a">NULL</span>) {
      <span class="i">tableSet</span>(<span class="i">to</span>, <span class="i">entry</span>-&gt;<span class="i">key</span>, <span class="i">entry</span>-&gt;<span class="i">value</span>);
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>tableSet</em>()</div>

<p>There&rsquo;s not much to say about this. It walks the bucket array of the source hash
table. Whenever it finds a non-empty bucket, it adds the entry to the
destination hash table using the <code>tableSet()</code> function we recently defined.</p>
<h3><a href="#retrieving-values" id="retrieving-values"><small>20&#8202;.&#8202;4&#8202;.&#8202;4</small>Retrieving values</a></h3>
<p>Now that our hash table contains some stuff, let&rsquo;s start pulling things back
out. Given a key, we can look up the corresponding value, if there is one, with
this function:</p>
<div class="codehilite"><pre class="insert-before">void freeTable(Table* table);
</pre><div class="source-file"><em>table.h</em><br>
add after <em>freeTable</em>()</div>
<pre class="insert"><span class="t">bool</span> <span class="i">tableGet</span>(<span class="t">Table</span>* <span class="i">table</span>, <span class="t">ObjString</span>* <span class="i">key</span>, <span class="t">Value</span>* <span class="i">value</span>);
</pre><pre class="insert-after">bool tableSet(Table* table, ObjString* key, Value value);
</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after <em>freeTable</em>()</div>

<p>You pass in a table and a key. If it finds an entry with that key, it returns
<code>true</code>, otherwise it returns <code>false</code>. If the entry exists, the <code>value</code> output
parameter points to the resulting value.</p>
<p>Since <code>findEntry()</code> already does the hard work, the implementation isn&rsquo;t bad.</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
add after <em>findEntry</em>()</div>
<pre><span class="t">bool</span> <span class="i">tableGet</span>(<span class="t">Table</span>* <span class="i">table</span>, <span class="t">ObjString</span>* <span class="i">key</span>, <span class="t">Value</span>* <span class="i">value</span>) {
  <span class="k">if</span> (<span class="i">table</span>-&gt;<span class="i">count</span> == <span class="n">0</span>) <span class="k">return</span> <span class="k">false</span>;

  <span class="t">Entry</span>* <span class="i">entry</span> = <span class="i">findEntry</span>(<span class="i">table</span>-&gt;<span class="i">entries</span>, <span class="i">table</span>-&gt;<span class="i">capacity</span>, <span class="i">key</span>);
  <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span> == <span class="a">NULL</span>) <span class="k">return</span> <span class="k">false</span>;

  *<span class="i">value</span> = <span class="i">entry</span>-&gt;<span class="i">value</span>;
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>findEntry</em>()</div>

<p>If the table is completely empty, we definitely won&rsquo;t find the entry, so we
check for that first. This isn&rsquo;t just an optimization<span class="em">&mdash;</span>it also ensures that we
don&rsquo;t try to access the bucket array when the array is <code>NULL</code>. Otherwise, we let
<code>findEntry()</code> work its magic. That returns a pointer to a bucket. If the bucket
is empty, which we detect by seeing if the key is <code>NULL</code>, then we didn&rsquo;t find an
Entry with our key. If <code>findEntry()</code> does return a non-empty Entry, then that&rsquo;s
our match. We take the Entry&rsquo;s value and copy it to the output parameter so the
caller can get it. Piece of cake.</p>
<h3><a href="#deleting-entries" id="deleting-entries"><small>20&#8202;.&#8202;4&#8202;.&#8202;5</small>Deleting entries</a></h3>
<p>There is one more fundamental operation a full-featured hash table needs to
support: removing an entry. This seems pretty obvious, if you can add things,
you should be able to <em>un</em>-add them, right? But you&rsquo;d be surprised how many
tutorials on hash tables omit this.</p>
<p>I could have taken that route too. In fact, we use deletion in clox only in a
tiny edge case in the VM. But if you want to actually understand how to
completely implement a hash table, this feels important. I can sympathize with
their desire to overlook it. As we&rsquo;ll see, deleting from a hash table that uses
<span name="delete">open</span> addressing is tricky.</p>
<aside name="delete">
<p>With separate chaining, deleting is as easy as removing a node from a linked
list.</p>
</aside>
<p>At least the declaration is simple.</p>
<div class="codehilite"><pre class="insert-before">bool tableSet(Table* table, ObjString* key, Value value);
</pre><div class="source-file"><em>table.h</em><br>
add after <em>tableSet</em>()</div>
<pre class="insert"><span class="t">bool</span> <span class="i">tableDelete</span>(<span class="t">Table</span>* <span class="i">table</span>, <span class="t">ObjString</span>* <span class="i">key</span>);
</pre><pre class="insert-after">void tableAddAll(Table* from, Table* to);
</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after <em>tableSet</em>()</div>

<p>The obvious approach is to mirror insertion. Use <code>findEntry()</code> to look up the
entry&rsquo;s bucket. Then clear out the bucket. Done!</p>
<p>In cases where there are no collisions, that works fine. But if a collision has
occurred, then the bucket where the entry lives may be part of one or more
implicit probe sequences. For example, here&rsquo;s a hash table containing three keys
all with the same preferred bucket, 2:</p><img src="image/hash-tables/delete-1.png" alt="A hash table containing 'bagel' in bucket 2, 'biscuit' in bucket 3, and 'jam' in bucket 4." />
<p>Remember that when we&rsquo;re walking a probe sequence to find an entry, we know
we&rsquo;ve reached the end of a sequence and that the entry isn&rsquo;t present when we hit
an empty bucket. It&rsquo;s like the probe sequence is a list of entries and an empty
entry terminates that list.</p>
<p>If we delete &ldquo;biscuit&rdquo; by simply clearing the Entry, then we break that probe
sequence in the middle, leaving the trailing entries orphaned and unreachable.
Sort of like removing a node from a linked list without relinking the pointer
from the previous node to the next one.</p>
<p>If we later try to look for &ldquo;jam&rdquo;, we&rsquo;d start at &ldquo;bagel&rdquo;, stop at the next
empty Entry, and never find it.</p><img src="image/hash-tables/delete-2.png" alt="The 'biscuit' entry has been deleted from the hash table, breaking the chain." />
<p>To solve this, most implementations use a trick called <span
name="tombstone"><strong>tombstones</strong></span>. Instead of clearing the entry on
deletion, we replace it with a special sentinel entry called a &ldquo;tombstone&rdquo;. When
we are following a probe sequence during a lookup, and we hit a tombstone, we
<em>don&rsquo;t</em> treat it like an empty slot and stop iterating. Instead, we keep going
so that deleting an entry doesn&rsquo;t break any implicit collision chains and we can
still find entries after it.</p><img src="image/hash-tables/delete-3.png" alt="Instead of deleting 'biscuit', it's replaced with a tombstone." />
<p>The code looks like this:</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
add after <em>tableSet</em>()</div>
<pre><span class="t">bool</span> <span class="i">tableDelete</span>(<span class="t">Table</span>* <span class="i">table</span>, <span class="t">ObjString</span>* <span class="i">key</span>) {
  <span class="k">if</span> (<span class="i">table</span>-&gt;<span class="i">count</span> == <span class="n">0</span>) <span class="k">return</span> <span class="k">false</span>;

  <span class="c">// Find the entry.</span>
  <span class="t">Entry</span>* <span class="i">entry</span> = <span class="i">findEntry</span>(<span class="i">table</span>-&gt;<span class="i">entries</span>, <span class="i">table</span>-&gt;<span class="i">capacity</span>, <span class="i">key</span>);
  <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span> == <span class="a">NULL</span>) <span class="k">return</span> <span class="k">false</span>;

  <span class="c">// Place a tombstone in the entry.</span>
  <span class="i">entry</span>-&gt;<span class="i">key</span> = <span class="a">NULL</span>;
  <span class="i">entry</span>-&gt;<span class="i">value</span> = <span class="a">BOOL_VAL</span>(<span class="k">true</span>);
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>tableSet</em>()</div>

<p>First, we find the bucket containing the entry we want to delete. (If we don&rsquo;t
find it, there&rsquo;s nothing to delete, so we bail out.) We replace the entry with a
tombstone. In clox, we use a <code>NULL</code> key and a <code>true</code> value to represent that,
but any representation that can&rsquo;t be confused with an empty bucket or a valid
entry works.</p>
<aside name="tombstone"><img src="image/hash-tables/tombstone.png" alt="A tombstone enscribed 'Here lies entry biscuit &rarr; 3.75, gone but not deleted'." />
</aside>
<p>That&rsquo;s all we need to do to delete an entry. Simple and fast. But all of the
other operations need to correctly handle tombstones too. A tombstone is a sort
of &ldquo;half&rdquo; entry. It has some of the characteristics of a present entry, and some
of the characteristics of an empty one.</p>
<p>When we are following a probe sequence during a lookup, and we hit a tombstone,
we note it and keep going.</p>
<div class="codehilite"><pre class="insert-before">  for (;;) {
    Entry* entry = &amp;entries[index];
</pre><div class="source-file"><em>table.c</em><br>
in <em>findEntry</em>()<br>
replace 3 lines</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span> == <span class="a">NULL</span>) {
      <span class="k">if</span> (<span class="a">IS_NIL</span>(<span class="i">entry</span>-&gt;<span class="i">value</span>)) {
        <span class="c">// Empty entry.</span>
        <span class="k">return</span> <span class="i">tombstone</span> != <span class="a">NULL</span> ? <span class="i">tombstone</span> : <span class="i">entry</span>;
      } <span class="k">else</span> {
        <span class="c">// We found a tombstone.</span>
        <span class="k">if</span> (<span class="i">tombstone</span> == <span class="a">NULL</span>) <span class="i">tombstone</span> = <span class="i">entry</span>;
      }
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span> == <span class="i">key</span>) {
      <span class="c">// We found the key.</span>
      <span class="k">return</span> <span class="i">entry</span>;
    }
</pre><pre class="insert-after">

    index = (index + 1) % capacity;
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, in <em>findEntry</em>(), replace 3 lines</div>

<p>The first time we pass a tombstone, we store it in this local variable:</p>
<div class="codehilite"><pre class="insert-before">  uint32_t index = key-&gt;hash % capacity;
</pre><div class="source-file"><em>table.c</em><br>
in <em>findEntry</em>()</div>
<pre class="insert">  <span class="t">Entry</span>* <span class="i">tombstone</span> = <span class="a">NULL</span>;

</pre><pre class="insert-after">  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, in <em>findEntry</em>()</div>

<p>If we reach a truly empty entry, then the key isn&rsquo;t present. In that case, if we
have passed a tombstone, we return its bucket instead of the later empty one. If
we&rsquo;re calling <code>findEntry()</code> in order to insert a node, that lets us treat the
tombstone bucket as empty and reuse it for the new entry.</p>
<p>Reusing tombstone slots automatically like this helps reduce the number of
tombstones wasting space in the bucket array. In typical use cases where there
is a mixture of insertions and deletions, the number of tombstones grows for a
while and then tends to stabilize.</p>
<p>Even so, there&rsquo;s no guarantee that a large number of deletes won&rsquo;t cause the
array to be full of tombstones. In the very worst case, we could end up with
<em>no</em> empty buckets. That would be bad because, remember, the only thing
preventing an infinite loop in <code>findEntry()</code> is the assumption that we&rsquo;ll
eventually hit an empty bucket.</p>
<p>So we need to be thoughtful about how tombstones interact with the table&rsquo;s load
factor and resizing. The key question is, when calculating the load factor,
should we treat tombstones like full buckets or empty ones?</p>
<h3><a href="#counting-tombstones" id="counting-tombstones"><small>20&#8202;.&#8202;4&#8202;.&#8202;6</small>Counting tombstones</a></h3>
<p>If we treat tombstones like full buckets, then we may end up with a bigger array
than we probably need because it artificially inflates the load factor. There
are tombstones we could reuse, but they aren&rsquo;t treated as unused so we end up
growing the array prematurely.</p>
<p>But if we treat tombstones like empty buckets and <em>don&rsquo;t</em> include them in the
load factor, then we run the risk of ending up with <em>no</em> actual empty buckets to
terminate a lookup. An infinite loop is a much worse problem than a few extra
array slots, so for load factor, we consider tombstones to be full buckets.</p>
<p>That&rsquo;s why we don&rsquo;t reduce the count when deleting an entry in the previous
code. The count is no longer the number of entries in the hash table, it&rsquo;s the
number of entries plus tombstones. That implies that we increment the count
during insertion only if the new entry goes into an entirely empty bucket.</p>
<div class="codehilite"><pre class="insert-before">  bool isNewKey = entry-&gt;key == NULL;
</pre><div class="source-file"><em>table.c</em><br>
in <em>tableSet</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">isNewKey</span> &amp;&amp; <span class="a">IS_NIL</span>(<span class="i">entry</span>-&gt;<span class="i">value</span>)) <span class="i">table</span>-&gt;<span class="i">count</span>++;
</pre><pre class="insert-after">

  entry-&gt;key = key;
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, in <em>tableSet</em>(), replace 1 line</div>

<p>If we are replacing a tombstone with a new entry, the bucket has already been
accounted for and the count doesn&rsquo;t change.</p>
<p>When we resize the array, we allocate a new array and re-insert all of the
existing entries into it. During that process, we <em>don&rsquo;t</em> copy the tombstones
over. They don&rsquo;t add any value since we&rsquo;re rebuilding the probe sequences
anyway, and would just slow down lookups. That means we need to recalculate the
count since it may change during a resize. So we clear it out:</p>
<div class="codehilite"><pre class="insert-before">  }

</pre><div class="source-file"><em>table.c</em><br>
in <em>adjustCapacity</em>()</div>
<pre class="insert">  <span class="i">table</span>-&gt;<span class="i">count</span> = <span class="n">0</span>;
</pre><pre class="insert-after">  for (int i = 0; i &lt; table-&gt;capacity; i++) {
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, in <em>adjustCapacity</em>()</div>

<p>Then each time we find a non-tombstone entry, we increment it.</p>
<div class="codehilite"><pre class="insert-before">    dest-&gt;value = entry-&gt;value;
</pre><div class="source-file"><em>table.c</em><br>
in <em>adjustCapacity</em>()</div>
<pre class="insert">    <span class="i">table</span>-&gt;<span class="i">count</span>++;
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, in <em>adjustCapacity</em>()</div>

<p>This means that when we grow the capacity, we may end up with <em>fewer</em> entries in
the resulting larger array because all of the tombstones get discarded. That&rsquo;s a
little wasteful, but not a huge practical problem.</p>
<p>I find it interesting that much of the work to support deleting entries is in
<code>findEntry()</code> and <code>adjustCapacity()</code>. The actual delete logic is quite simple
and fast. In practice, deletions tend to be rare, so you&rsquo;d expect a hash table
to do as much work as it can in the delete function and leave the other
functions alone to keep them faster. With our tombstone approach, deletes are
fast, but lookups get penalized.</p>
<p>I did a little benchmarking to test this out in a few different deletion
scenarios. I was surprised to discover that tombstones did end up being faster
overall compared to doing all the work during deletion to reinsert the affected
entries.</p>
<p>But if you think about it, it&rsquo;s not that the tombstone approach pushes the work
of fully deleting an entry to other operations, it&rsquo;s more that it makes deleting
<em>lazy</em>. At first, it does the minimal work to turn the entry into a tombstone.
That can cause a penalty when later lookups have to skip over it. But it also
allows that tombstone bucket to be reused by a later insert too. That reuse is a
very efficient way to avoid the cost of rearranging all of the following
affected entries. You basically recycle a node in the chain of probed entries.
It&rsquo;s a neat trick.</p>
<h2><a href="#string-interning" id="string-interning"><small>20&#8202;.&#8202;5</small>String Interning</a></h2>
<p>We&rsquo;ve got ourselves a hash table that mostly works, though it has a critical
flaw in its center. Also, we aren&rsquo;t using it for anything yet. It&rsquo;s time to
address both of those and, in the process, learn a classic technique used by
interpreters.</p>
<p>The reason the hash table doesn&rsquo;t totally work is that when <code>findEntry()</code> checks
to see if an existing key matches the one it&rsquo;s looking for, it uses <code>==</code> to
compare two strings for equality. That only returns true if the two keys are the
exact same string in memory. Two separate strings with the same characters
should be considered equal, but aren&rsquo;t.</p>
<p>Remember, back when we added strings in the last chapter, we added <a href="strings.html#operations-on-strings">explicit
support to compare the strings character-by-character</a> in order to get
true value equality. We could do that in <code>findEntry()</code>, but that&rsquo;s <span
name="hash-collision">slow</span>.</p>
<aside name="hash-collision">
<p>In practice, we would first compare the hash codes of the two strings. That
quickly detects almost all different strings<span class="em">&mdash;</span>it wouldn&rsquo;t be a very good hash
function if it didn&rsquo;t. But when the two hashes are the same, we still have to
compare characters to make sure we didn&rsquo;t have a hash collision on different
strings.</p>
</aside>
<p>Instead, we&rsquo;ll use a technique called <strong>string interning</strong>. The core problem is
that it&rsquo;s possible to have different strings in memory with the same characters.
Those need to behave like equivalent values even though they are distinct
objects. They&rsquo;re essentially duplicates, and we have to compare all of their
bytes to detect that.</p>
<p><span name="intern">String interning</span> is a process of deduplication. We
create a collection of &ldquo;interned&rdquo; strings. Any string in that collection is
guaranteed to be textually distinct from all others. When you intern a string,
you look for a matching string in the collection. If found, you use that
original one. Otherwise, the string you have is unique, so you add it to the
collection.</p>
<aside name="intern">
<p>I&rsquo;m guessing &ldquo;intern&rdquo; is short for &ldquo;internal&rdquo;. I think the idea is that the
language&rsquo;s runtime keeps its own &ldquo;internal&rdquo; collection of these strings, whereas
other strings could be user created and floating around in memory. When you
intern a string, you ask the runtime to add the string to that internal
collection and return a pointer to it.</p>
<p>Languages vary in how much string interning they do and how it&rsquo;s exposed to the
user. Lua interns <em>all</em> strings, which is what clox will do too. Lisp, Scheme,
Smalltalk, Ruby and others have a separate string-like type called &ldquo;symbol&rdquo; that
is implicitly interned. (This is why they say symbols are &ldquo;faster&rdquo; in Ruby.)
Java interns constant strings by default, and provides an API to let you
explicitly intern any string you give it.</p>
</aside>
<p>In this way, you know that each sequence of characters is represented by only
one string in memory. This makes value equality trivial. If two strings point
to the same address in memory, they are obviously the same string and must be
equal. And, because we know strings are unique, if two strings point to
different addresses, they must be distinct strings.</p>
<p>Thus, pointer equality exactly matches value equality. Which in turn means that
our existing <code>==</code> in <code>findEntry()</code> does the right thing. Or, at least, it will
once we intern all the strings. In order to reliably deduplicate all strings,
the VM needs to be able to find every string that&rsquo;s created. We do that by
giving it a hash table to store them all.</p>
<div class="codehilite"><pre class="insert-before">  Value* stackTop;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">Table</span> <span class="i">strings</span>;
</pre><pre class="insert-after">  Obj* objects;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>As usual, we need an include.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert"><span class="a">#include &quot;table.h&quot;</span>
</pre><pre class="insert-after">#include &quot;value.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>

<p>When we spin up a new VM, the string table is empty.</p>
<div class="codehilite"><pre class="insert-before">  vm.objects = NULL;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">  <span class="i">initTable</span>(&amp;<span class="i">vm</span>.<span class="i">strings</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>And when we shut down the VM, we clean up any resources used by the table.</p>
<div class="codehilite"><pre class="insert-before">void freeVM() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>freeVM</em>()</div>
<pre class="insert">  <span class="i">freeTable</span>(&amp;<span class="i">vm</span>.<span class="i">strings</span>);
</pre><pre class="insert-after">  freeObjects();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>freeVM</em>()</div>

<p>Some languages have a separate type or an explicit step to intern a string. For
clox, we&rsquo;ll automatically intern every one. That means whenever we create a new
unique string, we add it to the table.</p>
<div class="codehilite"><pre class="insert-before">  string-&gt;hash = hash;
</pre><div class="source-file"><em>object.c</em><br>
in <em>allocateString</em>()</div>
<pre class="insert">  <span class="i">tableSet</span>(&amp;<span class="i">vm</span>.<span class="i">strings</span>, <span class="i">string</span>, <span class="a">NIL_VAL</span>);
</pre><pre class="insert-after">  return string;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateString</em>()</div>

<p>We&rsquo;re using the table more like a hash <em>set</em> than a hash <em>table</em>. The keys are
the strings and those are all we care about, so we just use <code>nil</code> for the
values.</p>
<p>This gets a string into the table assuming that it&rsquo;s unique, but we need to
actually check for duplication before we get here. We do that in the two
higher-level functions that call <code>allocateString()</code>. Here&rsquo;s one:</p>
<div class="codehilite"><pre class="insert-before">  uint32_t hash = hashString(chars, length);
</pre><div class="source-file"><em>object.c</em><br>
in <em>copyString</em>()</div>
<pre class="insert">  <span class="t">ObjString</span>* <span class="i">interned</span> = <span class="i">tableFindString</span>(&amp;<span class="i">vm</span>.<span class="i">strings</span>, <span class="i">chars</span>, <span class="i">length</span>,
                                        <span class="i">hash</span>);
  <span class="k">if</span> (<span class="i">interned</span> != <span class="a">NULL</span>) <span class="k">return</span> <span class="i">interned</span>;

</pre><pre class="insert-after">  char* heapChars = ALLOCATE(char, length + 1);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>copyString</em>()</div>

<p>When copying a string into a new LoxString, we look it up in the string table
first. If we find it, instead of &ldquo;copying&rdquo;, we just return a reference to that
string. Otherwise, we fall through, allocate a new string, and store it in the
string table.</p>
<p>Taking ownership of a string is a little different.</p>
<div class="codehilite"><pre class="insert-before">  uint32_t hash = hashString(chars, length);
</pre><div class="source-file"><em>object.c</em><br>
in <em>takeString</em>()</div>
<pre class="insert">  <span class="t">ObjString</span>* <span class="i">interned</span> = <span class="i">tableFindString</span>(&amp;<span class="i">vm</span>.<span class="i">strings</span>, <span class="i">chars</span>, <span class="i">length</span>,
                                        <span class="i">hash</span>);
  <span class="k">if</span> (<span class="i">interned</span> != <span class="a">NULL</span>) {
    <span class="a">FREE_ARRAY</span>(<span class="t">char</span>, <span class="i">chars</span>, <span class="i">length</span> + <span class="n">1</span>);
    <span class="k">return</span> <span class="i">interned</span>;
  }

</pre><pre class="insert-after">  return allocateString(chars, length, hash);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>takeString</em>()</div>

<p>Again, we look up the string in the string table first. If we find it, before we
return it, we free the memory for the string that was passed in. Since ownership
is being passed to this function and we no longer need the duplicate string,
it&rsquo;s up to us to free it.</p>
<p>Before we get to the new function we need to write, there&rsquo;s one more include.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;object.h&quot;
</pre><div class="source-file"><em>object.c</em></div>
<pre class="insert"><span class="a">#include &quot;table.h&quot;</span>
</pre><pre class="insert-after">#include &quot;value.h&quot;
</pre></div>
<div class="source-file-narrow"><em>object.c</em></div>

<p>To look for a string in the table, we can&rsquo;t use the normal <code>tableGet()</code> function
because that calls <code>findEntry()</code>, which has the exact problem with duplicate
strings that we&rsquo;re trying to fix right now. Instead, we use this new function:</p>
<div class="codehilite"><pre class="insert-before">void tableAddAll(Table* from, Table* to);
</pre><div class="source-file"><em>table.h</em><br>
add after <em>tableAddAll</em>()</div>
<pre class="insert"><span class="t">ObjString</span>* <span class="i">tableFindString</span>(<span class="t">Table</span>* <span class="i">table</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">chars</span>,
                           <span class="t">int</span> <span class="i">length</span>, <span class="t">uint32_t</span> <span class="i">hash</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after <em>tableAddAll</em>()</div>

<p>The implementation looks like so:</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
add after <em>tableAddAll</em>()</div>
<pre><span class="t">ObjString</span>* <span class="i">tableFindString</span>(<span class="t">Table</span>* <span class="i">table</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">chars</span>,
                           <span class="t">int</span> <span class="i">length</span>, <span class="t">uint32_t</span> <span class="i">hash</span>) {
  <span class="k">if</span> (<span class="i">table</span>-&gt;<span class="i">count</span> == <span class="n">0</span>) <span class="k">return</span> <span class="a">NULL</span>;

  <span class="t">uint32_t</span> <span class="i">index</span> = <span class="i">hash</span> % <span class="i">table</span>-&gt;<span class="i">capacity</span>;
  <span class="k">for</span> (;;) {
    <span class="t">Entry</span>* <span class="i">entry</span> = &amp;<span class="i">table</span>-&gt;<span class="i">entries</span>[<span class="i">index</span>];
    <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span> == <span class="a">NULL</span>) {
      <span class="c">// Stop if we find an empty non-tombstone entry.</span>
      <span class="k">if</span> (<span class="a">IS_NIL</span>(<span class="i">entry</span>-&gt;<span class="i">value</span>)) <span class="k">return</span> <span class="a">NULL</span>;
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span>-&gt;<span class="i">length</span> == <span class="i">length</span> &amp;&amp;
        <span class="i">entry</span>-&gt;<span class="i">key</span>-&gt;<span class="i">hash</span> == <span class="i">hash</span> &amp;&amp;
        <span class="i">memcmp</span>(<span class="i">entry</span>-&gt;<span class="i">key</span>-&gt;<span class="i">chars</span>, <span class="i">chars</span>, <span class="i">length</span>) == <span class="n">0</span>) {
      <span class="c">// We found it.</span>
      <span class="k">return</span> <span class="i">entry</span>-&gt;<span class="i">key</span>;
    }

    <span class="i">index</span> = (<span class="i">index</span> + <span class="n">1</span>) % <span class="i">table</span>-&gt;<span class="i">capacity</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>tableAddAll</em>()</div>

<p>It appears we have copy-pasted <code>findEntry()</code>. There is a lot of redundancy, but
also a couple of key differences. First, we pass in the raw character array of
the key we&rsquo;re looking for instead of an ObjString. At the point that we call
this, we haven&rsquo;t created an ObjString yet.</p>
<p>Second, when checking to see if we found the key, we look at the actual strings.
We first see if they have matching lengths and hashes. Those are quick to check
and if they aren&rsquo;t equal, the strings definitely aren&rsquo;t the same.</p>
<p>If there is a hash collision, we do an actual character-by-character string
comparison. This is the one place in the VM where we actually test strings for
textual equality. We do it here to deduplicate strings and then the rest of the
VM can take for granted that any two strings at different addresses in memory
must have different contents.</p>
<p>In fact, now that we&rsquo;ve interned all the strings, we can take advantage of it in
the bytecode interpreter. When a user does <code>==</code> on two objects that happen to be
strings, we don&rsquo;t need to test the characters any more.</p>
<div class="codehilite"><pre class="insert-before">    case VAL_NUMBER: return AS_NUMBER(a) == AS_NUMBER(b);
</pre><div class="source-file"><em>value.c</em><br>
in <em>valuesEqual</em>()<br>
replace 7 lines</div>
<pre class="insert">    <span class="k">case</span> <span class="a">VAL_OBJ</span>:    <span class="k">return</span> <span class="a">AS_OBJ</span>(<span class="i">a</span>) == <span class="a">AS_OBJ</span>(<span class="i">b</span>);
</pre><pre class="insert-after">    default:         return false; // Unreachable.
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>valuesEqual</em>(), replace 7 lines</div>

<p>We&rsquo;ve added a little overhead when creating strings to intern them. But in
return, at runtime, the equality operator on strings is much faster. With that,
we have a full-featured hash table ready for us to use for tracking variables,
instances, or any other key-value pairs that might show up.</p>
<p>We also sped up testing strings for equality. This is nice for when the user
does <code>==</code> on strings. But it&rsquo;s even more critical in a dynamically typed
language like Lox where method calls and instance fields are looked up by name
at runtime. If testing a string for equality is slow, then that means looking up
a method by name is slow. And if <em>that&rsquo;s</em> slow in your object-oriented language,
then <em>everything</em> is slow.</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>In clox, we happen to only need keys that are strings, so the hash table we
built is hardcoded for that key type. If we exposed hash tables to Lox users
as a first-class collection, it would be useful to support different kinds
of keys.</p>
<p>Add support for keys of the other primitive types: numbers, Booleans, and
<code>nil</code>. Later, clox will support user-defined classes. If we want to support
keys that are instances of those classes, what kind of complexity does that
add?</p>
</li>
<li>
<p>Hash tables have a lot of knobs you can tweak that affect their performance.
You decide whether to use separate chaining or open addressing. Depending on
which fork in that road you take, you can tune how many entries are stored
in each node, or the probing strategy you use. You control the hash
function, load factor, and growth rate.</p>
<p>All of this variety wasn&rsquo;t created just to give CS doctoral candidates
something to <span name="publish">publish</span> theses on: each has its
uses in the many varied domains and hardware scenarios where hashing comes
into play. Look up a few hash table implementations in different open source
systems, research the choices they made, and try to figure out why they did
things that way.</p>
<aside name="publish">
<p>Well, at least that wasn&rsquo;t the <em>only</em> reason they were created. Whether that
was the <em>main</em> reason is up for debate.</p>
</aside></li>
<li>
<p>Benchmarking a hash table is notoriously difficult. A hash table
implementation may perform well with some keysets and poorly with others. It
may work well at small sizes but degrade as it grows, or vice versa. It may
choke when deletions are common, but fly when they aren&rsquo;t. Creating
benchmarks that accurately represent how your users will use the hash table
is a challenge.</p>
<p>Write a handful of different benchmark programs to validate our hash table
implementation. How does the performance vary between them? Why did you
choose the specific test cases you chose?</p>
</li>
</ol>
</div>

<footer>
<a href="global-variables.html" class="next">
  Next Chapter: &ldquo;Global Variables&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Global Variables &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Global Variables<small>21</small></a></h3>

<ul>
    <li><a href="#statements"><small>21.1</small> Statements</a></li>
    <li><a href="#variable-declarations"><small>21.2</small> Variable Declarations</a></li>
    <li><a href="#reading-variables"><small>21.3</small> Reading Variables</a></li>
    <li><a href="#assignment"><small>21.4</small> Assignment</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="hash-tables.html" title="Hash Tables" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="local-variables.html" title="Local Variables" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="hash-tables.html" title="Hash Tables" class="prev">←</a>
<a href="local-variables.html" title="Local Variables" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Global Variables<small>21</small></a></h3>

<ul>
    <li><a href="#statements"><small>21.1</small> Statements</a></li>
    <li><a href="#variable-declarations"><small>21.2</small> Variable Declarations</a></li>
    <li><a href="#reading-variables"><small>21.3</small> Reading Variables</a></li>
    <li><a href="#assignment"><small>21.4</small> Assignment</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="hash-tables.html" title="Hash Tables" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="local-variables.html" title="Local Variables" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">21</div>
  <h1>Global Variables</h1>

<blockquote>
<p>If only there could be an invention that bottled up a memory, like scent. And
it never faded, and it never got stale. And then, when one wanted it, the
bottle could be uncorked, and it would be like living the moment all over
again.</p>
<p><cite>Daphne du Maurier, <em>Rebecca</em></cite></p>
</blockquote>
<p>The <a href="hash-tables.html">previous chapter</a> was a long exploration of one big, deep,
fundamental computer science data structure. Heavy on theory and concept. There
may have been some discussion of big-O notation and algorithms. This chapter has
fewer intellectual pretensions. There are no large ideas to learn. Instead, it&rsquo;s
a handful of straightforward engineering tasks. Once we&rsquo;ve completed them, our
virtual machine will support variables.</p>
<p>Actually, it will support only <em>global</em> variables. Locals are coming in the
<a href="local-variables.html">next chapter</a>. In jlox, we managed to cram them both into a single chapter
because we used the same implementation technique for all variables. We built a
chain of environments, one for each scope, all the way up to the top. That was a
simple, clean way to learn how to manage state.</p>
<p>But it&rsquo;s also <em>slow</em>. Allocating a new hash table each time you enter a block or
call a function is not the road to a fast VM. Given how much code is concerned
with using variables, if variables go slow, everything goes slow. For clox,
we&rsquo;ll improve that by using a much more efficient strategy for <span
name="different">local</span> variables, but globals aren&rsquo;t as easily optimized.</p>
<aside name="different">
<p>This is a common meta-strategy in sophisticated language implementations. Often,
the same language feature will have multiple implementation techniques, each
tuned for different use patterns. For example, JavaScript VMs often have a
faster representation for objects that are used more like instances of classes
compared to other objects whose set of properties is more freely modified. C and
C++ compilers usually have a variety of ways to compile <code>switch</code> statements
based on the number of cases and how densely packed the case values are.</p>
</aside>
<p>A quick refresher on Lox semantics: Global variables in Lox are &ldquo;late bound&rdquo;, or
resolved dynamically. This means you can compile a chunk of code that refers to
a global variable before it&rsquo;s defined. As long as the code doesn&rsquo;t <em>execute</em>
before the definition happens, everything is fine. In practice, that means you
can refer to later variables inside the body of functions.</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">showVariable</span>() {
  <span class="k">print</span> <span class="i">global</span>;
}

<span class="k">var</span> <span class="i">global</span> = <span class="s">&quot;after&quot;</span>;
<span class="i">showVariable</span>();
</pre></div>
<p>Code like this might seem odd, but it&rsquo;s handy for defining mutually recursive
functions. It also plays nicer with the REPL. You can write a little function in
one line, then define the variable it uses in the next.</p>
<p>Local variables work differently. Since a local variable&rsquo;s declaration <em>always</em>
occurs before it is used, the VM can resolve them at compile time, even in a
simple single-pass compiler. That will let us use a smarter representation for
locals. But that&rsquo;s for the next chapter. Right now, let&rsquo;s just worry about
globals.</p>
<h2><a href="#statements" id="statements"><small>21&#8202;.&#8202;1</small>Statements</a></h2>
<p>Variables come into being using variable declarations, which means now is also
the time to add support for statements to our compiler. If you recall, Lox
splits statements into two categories. &ldquo;Declarations&rdquo; are those statements that
bind a new name to a value. The other kinds of statements<span class="em">&mdash;</span>control flow,
print, etc.<span class="em">&mdash;</span>are just called &ldquo;statements&rdquo;. We disallow declarations directly
inside control flow statements, like this:</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">monday</span>) <span class="k">var</span> <span class="i">croissant</span> = <span class="s">&quot;yes&quot;</span>; <span class="c">// Error.</span>
</pre></div>
<p>Allowing it would raise confusing questions around the scope of the variable.
So, like other languages, we prohibit it syntactically by having a separate
grammar rule for the subset of statements that <em>are</em> allowed inside a control
flow body.</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">forStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">returnStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;
</pre></div>
<p>Then we use a separate rule for the top level of a script and inside a block.</p>
<div class="codehilite"><pre><span class="i">declaration</span>    → <span class="i">classDecl</span>
               | <span class="i">funDecl</span>
               | <span class="i">varDecl</span>
               | <span class="i">statement</span> ;
</pre></div>
<p>The <code>declaration</code> rule contains the statements that declare names, and also
includes <code>statement</code> so that all statement types are allowed. Since <code>block</code>
itself is in <code>statement</code>, you can put declarations <span
name="parens">inside</span> a control flow construct by nesting them inside a
block.</p>
<aside name="parens">
<p>Blocks work sort of like parentheses do for expressions. A block lets you put
the &ldquo;lower-precedence&rdquo; declaration statements in places where only a
&ldquo;higher-precedence&rdquo; non-declaring statement is allowed.</p>
</aside>
<p>In this chapter, we&rsquo;ll cover only a couple of statements and one
declaration.</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span> ;

<span class="i">declaration</span>    → <span class="i">varDecl</span>
               | <span class="i">statement</span> ;
</pre></div>
<p>Up to now, our VM considered a &ldquo;program&rdquo; to be a single expression since that&rsquo;s
all we could parse and compile. In a full Lox implementation, a program is a
sequence of declarations. We&rsquo;re ready to support that now.</p>
<div class="codehilite"><pre class="insert-before">  advance();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()<br>
replace 2 lines</div>
<pre class="insert">

  <span class="k">while</span> (!<span class="i">match</span>(<span class="a">TOKEN_EOF</span>)) {
    <span class="i">declaration</span>();
  }

</pre><pre class="insert-after">  endCompiler();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 2 lines</div>

<p>We keep compiling declarations until we hit the end of the source file. We
compile a single declaration using this:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">declaration</span>() {
  <span class="i">statement</span>();
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>We&rsquo;ll get to variable declarations later in the chapter, so for now, we simply
forward to <code>statement()</code>.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>declaration</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">statement</span>() {
  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_PRINT</span>)) {
    <span class="i">printStatement</span>();
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>declaration</em>()</div>

<p>Blocks can contain declarations, and control flow statements can contain other
statements. That means these two functions will eventually be recursive. We may
as well write out the forward declarations now.</p>
<div class="codehilite"><pre class="insert-before">static void expression();
</pre><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">statement</span>();
<span class="k">static</span> <span class="t">void</span> <span class="i">declaration</span>();
</pre><pre class="insert-after">static ParseRule* getRule(TokenType type);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<h3><a href="#print-statements" id="print-statements"><small>21&#8202;.&#8202;1&#8202;.&#8202;1</small>Print statements</a></h3>
<p>We have two statement types to support in this chapter. Let&rsquo;s start with <code>print</code>
statements, which begin, naturally enough, with a <code>print</code> token. We detect that
using this helper function:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>consume</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">match</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">if</span> (!<span class="i">check</span>(<span class="i">type</span>)) <span class="k">return</span> <span class="k">false</span>;
  <span class="i">advance</span>();
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>consume</em>()</div>

<p>You may recognize it from jlox. If the current token has the given type, we
consume the token and return <code>true</code>. Otherwise we leave the token alone and
return <code>false</code>. This <span name="turtles">helper</span> function is implemented
in terms of this other helper:</p>
<aside name="turtles">
<p>It&rsquo;s helpers all the way down!</p>
</aside>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>consume</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">check</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">return</span> <span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> == <span class="i">type</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>consume</em>()</div>

<p>The <code>check()</code> function returns <code>true</code> if the current token has the given type.
It seems a little <span name="read">silly</span> to wrap this in a function, but
we&rsquo;ll use it more later, and I think short verb-named functions like this make
the parser easier to read.</p>
<aside name="read">
<p>This sounds trivial, but handwritten parsers for non-toy languages get pretty
big. When you have thousands of lines of code, a utility function that turns two
lines into one and makes the result a little more readable easily earns its
keep.</p>
</aside>
<p>If we did match the <code>print</code> token, then we compile the rest of the statement
here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">printStatement</span>() {
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after value.&quot;</span>);
  <span class="i">emitByte</span>(<span class="a">OP_PRINT</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>A <code>print</code> statement evaluates an expression and prints the result, so we first
parse and compile that expression. The grammar expects a semicolon after that,
so we consume it. Finally, we emit a new instruction to print the result.</p>
<div class="codehilite"><pre class="insert-before">  OP_NEGATE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_PRINT</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>At runtime, we execute this instruction like so:</p>
<div class="codehilite"><pre class="insert-before">        break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_PRINT</span>: {
        <span class="i">printValue</span>(<span class="i">pop</span>());
        <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>When the interpreter reaches this instruction, it has already executed the code
for the expression, leaving the result value on top of the stack. Now we simply
pop and print it.</p>
<p>Note that we don&rsquo;t push anything else after that. This is a key difference
between expressions and statements in the VM. Every bytecode instruction has a
<span name="effect"><strong>stack effect</strong></span> that describes how the instruction
modifies the stack. For example, <code>OP_ADD</code> pops two values and pushes one,
leaving the stack one element smaller than before.</p>
<aside name="effect">
<p>The stack is one element shorter after an <code>OP_ADD</code>, so its effect is -1:</p><img src="image/global-variables/stack-effect.png" alt="The stack effect of an OP_ADD instruction." />
</aside>
<p>You can sum the stack effects of a series of instructions to get their total
effect. When you add the stack effects of the series of instructions compiled
from any complete expression, it will total one. Each expression leaves one
result value on the stack.</p>
<p>The bytecode for an entire statement has a total stack effect of zero. Since a
statement produces no values, it ultimately leaves the stack unchanged, though
it of course uses the stack while it&rsquo;s doing its thing. This is important
because when we get to control flow and looping, a program might execute a long
series of statements. If each statement grew or shrank the stack, it might
eventually overflow or underflow.</p>
<p>While we&rsquo;re in the interpreter loop, we should delete a bit of code.</p>
<div class="codehilite"><pre class="insert-before">      case OP_RETURN: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">        <span class="c">// Exit interpreter.</span>
</pre><pre class="insert-after">        return INTERPRET_OK;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>When the VM only compiled and evaluated a single expression, we had some
temporary code in <code>OP_RETURN</code> to output the value. Now that we have statements
and <code>print</code>, we don&rsquo;t need that anymore. We&rsquo;re one <span
name="return">step</span> closer to the complete implementation of clox.</p>
<aside name="return">
<p>We&rsquo;re only one step closer, though. We will revisit <code>OP_RETURN</code> again when we
add functions. Right now, it exits the entire interpreter loop.</p>
</aside>
<p>As usual, a new instruction needs support in the disassembler.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_NEGATE&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_PRINT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_PRINT&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>That&rsquo;s our <code>print</code> statement. If you want, give it a whirl:</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="n">1</span> + <span class="n">2</span>;
<span class="k">print</span> <span class="n">3</span> * <span class="n">4</span>;
</pre></div>
<p>Exciting! OK, maybe not thrilling, but we can build scripts that contain as many
statements as we want now, which feels like progress.</p>
<h3><a href="#expression-statements" id="expression-statements"><small>21&#8202;.&#8202;1&#8202;.&#8202;2</small>Expression statements</a></h3>
<p>Wait until you see the next statement. If we <em>don&rsquo;t</em> see a <code>print</code> keyword, then
we must be looking at an expression statement.</p>
<div class="codehilite"><pre class="insert-before">    printStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> {
    <span class="i">expressionStatement</span>();
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>It&rsquo;s parsed like so:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">expressionStatement</span>() {
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after expression.&quot;</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>An &ldquo;expression statement&rdquo; is simply an expression followed by a semicolon.
They&rsquo;re how you write an expression in a context where a statement is expected.
Usually, it&rsquo;s so that you can call a function or evaluate an assignment for its
side effect, like this:</p>
<div class="codehilite"><pre><span class="i">brunch</span> = <span class="s">&quot;quiche&quot;</span>;
<span class="i">eat</span>(<span class="i">brunch</span>);
</pre></div>
<p>Semantically, an expression statement evaluates the expression and discards the
result. The compiler directly encodes that behavior. It compiles the expression,
and then emits an <code>OP_POP</code> instruction.</p>
<div class="codehilite"><pre class="insert-before">  OP_FALSE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_POP</span>,
</pre><pre class="insert-after">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>As the name implies, that instruction pops the top value off the stack and
forgets it.</p>
<div class="codehilite"><pre class="insert-before">      case OP_FALSE: push(BOOL_VAL(false)); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_POP</span>: <span class="i">pop</span>(); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We can disassemble it too.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_FALSE&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_POP</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_POP&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Expression statements aren&rsquo;t very useful yet since we can&rsquo;t create any
expressions that have side effects, but they&rsquo;ll be essential when we
<a href="calls-and-functions.html">add functions later</a>. The <span name="majority">majority</span> of
statements in real-world code in languages like C are expression statements.</p>
<aside name="majority">
<p>By my count, 80 of the 149 statements, in the version of &ldquo;compiler.c&rdquo; that we
have at the end of this chapter are expression statements.</p>
</aside>
<h3><a href="#error-synchronization" id="error-synchronization"><small>21&#8202;.&#8202;1&#8202;.&#8202;3</small>Error synchronization</a></h3>
<p>While we&rsquo;re getting this initial work done in the compiler, we can tie off a
loose end we left <a href="compiling-expressions.html#handling-syntax-errors">several chapters back</a>. Like jlox, clox uses panic
mode error recovery to minimize the number of cascaded compile errors that it
reports. The compiler exits panic mode when it reaches a synchronization point.
For Lox, we chose statement boundaries as that point. Now that we have
statements, we can implement synchronization.</p>
<div class="codehilite"><pre class="insert-before">  statement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declaration</em>()</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">panicMode</span>) <span class="i">synchronize</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>()</div>

<p>If we hit a compile error while parsing the previous statement, we enter panic
mode. When that happens, after the statement we start synchronizing.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>printStatement</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">synchronize</span>() {
  <span class="i">parser</span>.<span class="i">panicMode</span> = <span class="k">false</span>;

  <span class="k">while</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> != <span class="a">TOKEN_EOF</span>) {
    <span class="k">if</span> (<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span> == <span class="a">TOKEN_SEMICOLON</span>) <span class="k">return</span>;
    <span class="k">switch</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span>) {
      <span class="k">case</span> <span class="a">TOKEN_CLASS</span>:
      <span class="k">case</span> <span class="a">TOKEN_FUN</span>:
      <span class="k">case</span> <span class="a">TOKEN_VAR</span>:
      <span class="k">case</span> <span class="a">TOKEN_FOR</span>:
      <span class="k">case</span> <span class="a">TOKEN_IF</span>:
      <span class="k">case</span> <span class="a">TOKEN_WHILE</span>:
      <span class="k">case</span> <span class="a">TOKEN_PRINT</span>:
      <span class="k">case</span> <span class="a">TOKEN_RETURN</span>:
        <span class="k">return</span>;

      <span class="k">default</span>:
        ; <span class="c">// Do nothing.</span>
    }

    <span class="i">advance</span>();
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>printStatement</em>()</div>

<p>We skip tokens indiscriminately until we reach something that looks like a
statement boundary. We recognize the boundary by looking for a preceding token
that can end a statement, like a semicolon. Or we&rsquo;ll look for a subsequent token
that begins a statement, usually one of the control flow or declaration
keywords.</p>
<h2><a href="#variable-declarations" id="variable-declarations"><small>21&#8202;.&#8202;2</small>Variable Declarations</a></h2>
<p>Merely being able to <em>print</em> doesn&rsquo;t win your language any prizes at the
programming language <span name="fair">fair</span>, so let&rsquo;s move on to
something a little more ambitious and get variables going. There are three
operations we need to support:</p>
<aside name="fair">
<p>I can&rsquo;t help but imagine a &ldquo;language fair&rdquo; like some country 4H thing. Rows of
straw-lined stalls full of baby languages <em>moo</em>ing and <em>baa</em>ing at each other.</p>
</aside>
<ul>
<li>Declaring a new variable using a <code>var</code> statement.</li>
<li>Accessing the value of a variable using an identifier expression.</li>
<li>Storing a new value in an existing variable using an assignment expression.</li>
</ul>
<p>We can&rsquo;t do either of the last two until we have some variables, so we start
with declarations.</p>
<div class="codehilite"><pre class="insert-before">static void declaration() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declaration</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_VAR</span>)) {
    <span class="i">varDeclaration</span>();
  } <span class="k">else</span> {
    <span class="i">statement</span>();
  }
</pre><pre class="insert-after">

  if (parser.panicMode) synchronize();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>

<p>The placeholder parsing function we sketched out for the declaration grammar
rule has an actual production now. If we match a <code>var</code> token, we jump here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">varDeclaration</span>() {
  <span class="t">uint8_t</span> <span class="i">global</span> = <span class="i">parseVariable</span>(<span class="s">&quot;Expect variable name.&quot;</span>);

  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">expression</span>();
  } <span class="k">else</span> {
    <span class="i">emitByte</span>(<span class="a">OP_NIL</span>);
  }
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>,
          <span class="s">&quot;Expect &#39;;&#39; after variable declaration.&quot;</span>);

  <span class="i">defineVariable</span>(<span class="i">global</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>The keyword is followed by the variable name. That&rsquo;s compiled by
<code>parseVariable()</code>, which we&rsquo;ll get to in a second. Then we look for an <code>=</code>
followed by an initializer expression. If the user doesn&rsquo;t initialize the
variable, the compiler implicitly initializes it to <span
name="nil"><code>nil</code></span> by emitting an <code>OP_NIL</code> instruction. Either way, we
expect the statement to be terminated with a semicolon.</p>
<aside name="nil" class="bottom">
<p>Essentially, the compiler desugars a variable declaration like:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span>;
</pre></div>
<p>into:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="k">nil</span>;
</pre></div>
<p>The code it generates for the former is identical to what it produces for the
latter.</p>
</aside>
<p>There are two new functions here for working with variables and identifiers.
Here is the first:</p>
<div class="codehilite"><pre class="insert-before">static void parsePrecedence(Precedence precedence);

</pre><div class="source-file"><em>compiler.c</em><br>
add after <em>parsePrecedence</em>()</div>
<pre class="insert"><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">parseVariable</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">errorMessage</span>) {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="i">errorMessage</span>);
  <span class="k">return</span> <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parsePrecedence</em>()</div>

<p>It requires the next token to be an identifier, which it consumes and sends
here:</p>
<div class="codehilite"><pre class="insert-before">static void parsePrecedence(Precedence precedence);

</pre><div class="source-file"><em>compiler.c</em><br>
add after <em>parsePrecedence</em>()</div>
<pre class="insert"><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">identifierConstant</span>(<span class="t">Token</span>* <span class="i">name</span>) {
  <span class="k">return</span> <span class="i">makeConstant</span>(<span class="a">OBJ_VAL</span>(<span class="i">copyString</span>(<span class="i">name</span>-&gt;<span class="i">start</span>,
                                         <span class="i">name</span>-&gt;<span class="i">length</span>)));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parsePrecedence</em>()</div>

<p>This function takes the given token and adds its lexeme to the chunk&rsquo;s constant
table as a string. It then returns the index of that constant in the constant
table.</p>
<p>Global variables are looked up <em>by name</em> at runtime. That means the VM<span class="em">&mdash;</span>the
bytecode interpreter loop<span class="em">&mdash;</span>needs access to the name. A whole string is too big
to stuff into the bytecode stream as an operand. Instead, we store the string in
the constant table and the instruction then refers to the name by its index in
the table.</p>
<p>This function returns that index all the way to <code>varDeclaration()</code> which later
hands it over to here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>parseVariable</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">defineVariable</span>(<span class="t">uint8_t</span> <span class="i">global</span>) {
  <span class="i">emitBytes</span>(<span class="a">OP_DEFINE_GLOBAL</span>, <span class="i">global</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parseVariable</em>()</div>

<p><span name="helper">This</span> outputs the bytecode instruction that defines
the new variable and stores its initial value. The index of the variable&rsquo;s name
in the constant table is the instruction&rsquo;s operand. As usual in a stack-based
VM, we emit this instruction last. At runtime, we execute the code for the
variable&rsquo;s initializer first. That leaves the value on the stack. Then this
instruction takes that value and stores it away for later.</p>
<aside name="helper">
<p>I know some of these functions seem pretty pointless right now. But we&rsquo;ll get
more mileage out of them as we add more language features for working with
names. Function and class declarations both declare new variables, and variable
and assignment expressions access them.</p>
</aside>
<p>Over in the runtime, we begin with this new instruction:</p>
<div class="codehilite"><pre class="insert-before">  OP_POP,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_DEFINE_GLOBAL</span>,
</pre><pre class="insert-after">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Thanks to our handy-dandy hash table, the implementation isn&rsquo;t too hard.</p>
<div class="codehilite"><pre class="insert-before">      case OP_POP: pop(); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_DEFINE_GLOBAL</span>: {
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();
        <span class="i">tableSet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>, <span class="i">peek</span>(<span class="n">0</span>));
        <span class="i">pop</span>();
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We get the name of the variable from the constant table. Then we <span
name="pop">take</span> the value from the top of the stack and store it in a
hash table with that name as the key.</p>
<aside name="pop">
<p>Note that we don&rsquo;t <em>pop</em> the value until <em>after</em> we add it to the hash table.
That ensures the VM can still find the value if a garbage collection is
triggered right in the middle of adding it to the hash table. That&rsquo;s a distinct
possibility since the hash table requires dynamic allocation when it resizes.</p>
</aside>
<p>This code doesn&rsquo;t check to see if the key is already in the table. Lox is pretty
lax with global variables and lets you redefine them without error. That&rsquo;s
useful in a REPL session, so the VM supports that by simply overwriting the
value if the key happens to already be in the hash table.</p>
<p>There&rsquo;s another little helper macro:</p>
<div class="codehilite"><pre class="insert-before">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#define READ_STRING() AS_STRING(READ_CONSTANT())</span>
</pre><pre class="insert-after">#define BINARY_OP(valueType, op) \
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>It reads a one-byte operand from the bytecode chunk. It treats that as an index
into the chunk&rsquo;s constant table and returns the string at that index. It doesn&rsquo;t
check that the value <em>is</em> a string<span class="em">&mdash;</span>it just indiscriminately casts it. That&rsquo;s
safe because the compiler never emits an instruction that refers to a non-string
constant.</p>
<p>Because we care about lexical hygiene, we also undefine this macro at the end of
the interpret function.</p>
<div class="codehilite"><pre class="insert-before">#undef READ_CONSTANT
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#undef READ_STRING</span>
</pre><pre class="insert-after">#undef BINARY_OP
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>I keep saying &ldquo;the hash table&rdquo;, but we don&rsquo;t actually have one yet. We need a
place to store these globals. Since we want them to persist as long as clox is
running, we store them right in the VM.</p>
<div class="codehilite"><pre class="insert-before">  Value* stackTop;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">Table</span> <span class="i">globals</span>;
</pre><pre class="insert-after">  Table strings;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>As we did with the string table, we need to initialize the hash table to a valid
state when the VM boots up.</p>
<div class="codehilite"><pre class="insert-before">  vm.objects = NULL;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">

  <span class="i">initTable</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>);
</pre><pre class="insert-after">  initTable(&amp;vm.strings);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>And we <span name="tear">tear</span> it down when we exit.</p>
<aside name="tear">
<p>The process will free everything on exit, but it feels undignified to require
the operating system to clean up our mess.</p>
</aside>
<div class="codehilite"><pre class="insert-before">void freeVM() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>freeVM</em>()</div>
<pre class="insert">  <span class="i">freeTable</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>);
</pre><pre class="insert-after">  freeTable(&amp;vm.strings);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>freeVM</em>()</div>

<p>As usual, we want to be able to disassemble the new instruction too.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_POP&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_DEFINE_GLOBAL</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_DEFINE_GLOBAL&quot;</span>, <span class="i">chunk</span>,
                                 <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>And with that, we can define global variables. Not that users can <em>tell</em> that
they&rsquo;ve done so, because they can&rsquo;t actually <em>use</em> them. So let&rsquo;s fix that next.</p>
<h2><a href="#reading-variables" id="reading-variables"><small>21&#8202;.&#8202;3</small>Reading Variables</a></h2>
<p>As in every programming language ever, we access a variable&rsquo;s value using its
name. We hook up identifier tokens to the expression parser here:</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_LESS_EQUAL]    = {NULL,     binary, PREC_COMPARISON},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_IDENTIFIER</span>]    = {<span class="i">variable</span>, <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_STRING]        = {string,   NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>That calls this new parser function:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>string</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">variable</span>() {
  <span class="i">namedVariable</span>(<span class="i">parser</span>.<span class="i">previous</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>string</em>()</div>

<p>Like with declarations, there are a couple of tiny helper functions that seem
pointless now but will become more useful in later chapters. I promise.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>string</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">namedVariable</span>(<span class="t">Token</span> <span class="i">name</span>) {
  <span class="t">uint8_t</span> <span class="i">arg</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">name</span>);
  <span class="i">emitBytes</span>(<span class="a">OP_GET_GLOBAL</span>, <span class="i">arg</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>string</em>()</div>

<p>This calls the same <code>identifierConstant()</code> function from before to take the
given identifier token and add its lexeme to the chunk&rsquo;s constant table as a
string. All that remains is to emit an instruction that loads the global
variable with that name. Here&rsquo;s the instruction:</p>
<div class="codehilite"><pre class="insert-before">  OP_POP,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_GET_GLOBAL</span>,
</pre><pre class="insert-after">  OP_DEFINE_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Over in the interpreter, the implementation mirrors <code>OP_DEFINE_GLOBAL</code>.</p>
<div class="codehilite"><pre class="insert-before">      case OP_POP: pop(); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GET_GLOBAL</span>: {
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();
        <span class="t">Value</span> <span class="i">value</span>;
        <span class="k">if</span> (!<span class="i">tableGet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>, &amp;<span class="i">value</span>)) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Undefined variable &#39;%s&#39;.&quot;</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="i">push</span>(<span class="i">value</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_DEFINE_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We pull the constant table index from the instruction&rsquo;s operand and get the
variable name. Then we use that as a key to look up the variable&rsquo;s value in the
globals hash table.</p>
<p>If the key isn&rsquo;t present in the hash table, it means that global variable has
never been defined. That&rsquo;s a runtime error in Lox, so we report it and exit the
interpreter loop if that happens. Otherwise, we take the value and push it
onto the stack.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_POP&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_GET_GLOBAL</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_GET_GLOBAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_DEFINE_GLOBAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>A little bit of disassembling, and we&rsquo;re done. Our interpreter is now able to
run code like this:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">beverage</span> = <span class="s">&quot;cafe au lait&quot;</span>;
<span class="k">var</span> <span class="i">breakfast</span> = <span class="s">&quot;beignets with &quot;</span> + <span class="i">beverage</span>;
<span class="k">print</span> <span class="i">breakfast</span>;
</pre></div>
<p>There&rsquo;s only one operation left.</p>
<h2><a href="#assignment" id="assignment"><small>21&#8202;.&#8202;4</small>Assignment</a></h2>
<p>Throughout this book, I&rsquo;ve tried to keep you on a fairly safe and easy path. I
don&rsquo;t avoid hard <em>problems</em>, but I try to not make the <em>solutions</em> more complex
than they need to be. Alas, other design choices in our <span
name="jlox">bytecode</span> compiler make assignment annoying to implement.</p>
<aside name="jlox">
<p>If you recall, assignment was pretty easy in jlox.</p>
</aside>
<p>Our bytecode VM uses a single-pass compiler. It parses and generates bytecode
on the fly without any intermediate AST. As soon as it recognizes a piece of
syntax, it emits code for it. Assignment doesn&rsquo;t naturally fit that. Consider:</p>
<div class="codehilite"><pre><span class="i">menu</span>.<span class="i">brunch</span>(<span class="i">sunday</span>).<span class="i">beverage</span> = <span class="s">&quot;mimosa&quot;</span>;
</pre></div>
<p>In this code, the parser doesn&rsquo;t realize <code>menu.brunch(sunday).beverage</code> is the
target of an assignment and not a normal expression until it reaches <code>=</code>, many
tokens after the first <code>menu</code>. By then, the compiler has already emitted
bytecode for the whole thing.</p>
<p>The problem is not as dire as it might seem, though. Look at how the parser sees that example:</p><img src="image/global-variables/setter.png" alt="The 'menu.brunch(sunday).beverage = &quot;mimosa&quot;' statement, showing that 'menu.brunch(sunday)' is an expression." />
<p>Even though the <code>.beverage</code> part must not be compiled as a get expression,
everything to the left of the <code>.</code> is an expression, with the normal expression
semantics. The <code>menu.brunch(sunday)</code> part can be compiled and executed as usual.</p>
<p>Fortunately for us, the only semantic differences on the left side of an
assignment appear at the very right-most end of the tokens, immediately
preceding the <code>=</code>. Even though the receiver of a setter may be an arbitrarily
long expression, the part whose behavior differs from a get expression is only
the trailing identifier, which is right before the <code>=</code>. We don&rsquo;t need much
lookahead to realize <code>beverage</code> should be compiled as a set expression and not a
getter.</p>
<p>Variables are even easier since they are just a single bare identifier before an
<code>=</code>. The idea then is that right <em>before</em> compiling an expression that can also
be used as an assignment target, we look for a subsequent <code>=</code> token. If we see
one, we compile it as an assignment or setter instead of a variable access or
getter.</p>
<p>We don&rsquo;t have setters to worry about yet, so all we need to handle are variables.</p>
<div class="codehilite"><pre class="insert-before">  uint8_t arg = identifierConstant(&amp;name);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">expression</span>();
    <span class="i">emitBytes</span>(<span class="a">OP_SET_GLOBAL</span>, <span class="i">arg</span>);
  } <span class="k">else</span> {
    <span class="i">emitBytes</span>(<span class="a">OP_GET_GLOBAL</span>, <span class="i">arg</span>);
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>In the parse function for identifier expressions, we look for an equals sign
after the identifier. If we find one, instead of emitting code for a variable
access, we compile the assigned value and then emit an assignment instruction.</p>
<p>That&rsquo;s the last instruction we need to add in this chapter.</p>
<div class="codehilite"><pre class="insert-before">  OP_DEFINE_GLOBAL,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_SET_GLOBAL</span>,
</pre><pre class="insert-after">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>As you&rsquo;d expect, its runtime behavior is similar to defining a new variable.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_SET_GLOBAL</span>: {
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();
        <span class="k">if</span> (<span class="i">tableSet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>, <span class="i">peek</span>(<span class="n">0</span>))) {
          <span class="i">tableDelete</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>);<span name="delete"> </span>
          <span class="i">runtimeError</span>(<span class="s">&quot;Undefined variable &#39;%s&#39;.&quot;</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>The main difference is what happens when the key doesn&rsquo;t already exist in the
globals hash table. If the variable hasn&rsquo;t been defined yet, it&rsquo;s a runtime
error to try to assign to it. Lox <a href="statements-and-state.html#design-note">doesn&rsquo;t do implicit variable
declaration</a>.</p>
<aside name="delete">
<p>The call to <code>tableSet()</code> stores the value in the global variable table even if
the variable wasn&rsquo;t previously defined. That fact is visible in a REPL session,
since it keeps running even after the runtime error is reported. So we also take
care to delete that zombie value from the table.</p>
</aside>
<p>The other difference is that setting a variable doesn&rsquo;t pop the value off the
stack. Remember, assignment is an expression, so it needs to leave that value
there in case the assignment is nested inside some larger expression.</p>
<p>Add a dash of disassembly:</p>
<div class="codehilite"><pre class="insert-before">      return constantInstruction(&quot;OP_DEFINE_GLOBAL&quot;, chunk,
                                 offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_SET_GLOBAL</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_SET_GLOBAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>So we&rsquo;re done, right? Well<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>not quite. We&rsquo;ve made a mistake! Take a gander at:</p>
<div class="codehilite"><pre><span class="i">a</span> * <span class="i">b</span> = <span class="i">c</span> + <span class="i">d</span>;
</pre></div>
<p>According to Lox&rsquo;s grammar, <code>=</code> has the lowest precedence, so this should be
parsed roughly like:</p><img src="image/global-variables/ast-good.png" alt="The expected parse, like '(a * b) = (c + d)'." />
<p>Obviously, <code>a * b</code> isn&rsquo;t a <span name="do">valid</span> assignment target, so
this should be a syntax error. But here&rsquo;s what our parser does:</p>
<aside name="do">
<p>Wouldn&rsquo;t it be wild if <code>a * b</code> <em>was</em> a valid assignment target, though? You
could imagine some algebra-like language that tried to divide the assigned value
up in some reasonable way and distribute it to <code>a</code> and <code>b</code><span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>that&rsquo;s probably
a terrible idea.</p>
</aside>
<ol>
<li>First, <code>parsePrecedence()</code> parses <code>a</code> using the <code>variable()</code> prefix parser.</li>
<li>After that, it enters the infix parsing loop.</li>
<li>It reaches the <code>*</code> and calls <code>binary()</code>.</li>
<li>That recursively calls <code>parsePrecedence()</code> to parse the right-hand operand.</li>
<li>That calls <code>variable()</code> again for parsing <code>b</code>.</li>
<li>Inside that call to <code>variable()</code>, it looks for a trailing <code>=</code>. It sees one
and thus parses the rest of the line as an assignment.</li>
</ol>
<p>In other words, the parser sees the above code like:</p><img src="image/global-variables/ast-bad.png" alt="The actual parse, like 'a * (b = c + d)'." />
<p>We&rsquo;ve messed up the precedence handling because <code>variable()</code> doesn&rsquo;t take into
account the precedence of the surrounding expression that contains the variable.
If the variable happens to be the right-hand side of an infix operator, or the
operand of a unary operator, then that containing expression is too high
precedence to permit the <code>=</code>.</p>
<p>To fix this, <code>variable()</code> should look for and consume the <code>=</code> only if it&rsquo;s in
the context of a low-precedence expression. The code that knows the current
precedence is, logically enough, <code>parsePrecedence()</code>. The <code>variable()</code> function
doesn&rsquo;t need to know the actual level. It just cares that the precedence is low
enough to allow assignment, so we pass that fact in as a Boolean.</p>
<div class="codehilite"><pre class="insert-before">    error(&quot;Expect expression.&quot;);
    return;
  }

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parsePrecedence</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">bool</span> <span class="i">canAssign</span> = <span class="i">precedence</span> &lt;= <span class="a">PREC_ASSIGNMENT</span>;
  <span class="i">prefixRule</span>(<span class="i">canAssign</span>);
</pre><pre class="insert-after">

  while (precedence &lt;= getRule(parser.current.type)-&gt;precedence) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>(), replace 1 line</div>

<p>Since assignment is the lowest-precedence expression, the only time we allow an
assignment is when parsing an assignment expression or top-level expression like
in an expression statement. That flag makes its way to the parser function here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>variable</em>()<br>
replace 3 lines</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">variable</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="i">namedVariable</span>(<span class="i">parser</span>.<span class="i">previous</span>, <span class="i">canAssign</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>variable</em>(), replace 3 lines</div>

<p>Which passes it through a new parameter:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">namedVariable</span>(<span class="t">Token</span> <span class="i">name</span>, <span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  uint8_t arg = identifierConstant(&amp;name);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>namedVariable</em>(), replace 1 line</div>

<p>And then finally uses it here:</p>
<div class="codehilite"><pre class="insert-before">  uint8_t arg = identifierConstant(&amp;name);

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">canAssign</span> &amp;&amp; <span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
</pre><pre class="insert-after">    expression();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>That&rsquo;s a lot of plumbing to get literally one bit of data to the right place in
the compiler, but arrived it has. If the variable is nested inside some
expression with higher precedence, <code>canAssign</code> will be <code>false</code> and this will
ignore the <code>=</code> even if there is one there. Then <code>namedVariable()</code> returns, and
execution eventually makes its way back to <code>parsePrecedence()</code>.</p>
<p>Then what? What does the compiler do with our broken example from before? Right
now, <code>variable()</code> won&rsquo;t consume the <code>=</code>, so that will be the current token. The
compiler returns back to <code>parsePrecedence()</code> from the <code>variable()</code> prefix parser
and then tries to enter the infix parsing loop. There is no parsing function
associated with <code>=</code>, so it skips that loop.</p>
<p>Then <code>parsePrecedence()</code> silently returns back to the caller. That also isn&rsquo;t
right. If the <code>=</code> doesn&rsquo;t get consumed as part of the expression, nothing else
is going to consume it. It&rsquo;s an error and we should report it.</p>
<div class="codehilite"><pre class="insert-before">    infixRule();
  }
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parsePrecedence</em>()</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">canAssign</span> &amp;&amp; <span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">error</span>(<span class="s">&quot;Invalid assignment target.&quot;</span>);
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>()</div>

<p>With that, the previous bad program correctly gets an error at compile time. OK,
<em>now</em> are we done? Still not quite. See, we&rsquo;re passing an argument to one of the
parse functions. But those functions are stored in a table of function pointers,
so all of the parse functions need to have the same type. Even though most parse
functions don&rsquo;t support being used as an assignment target<span class="em">&mdash;</span>setters are the
<span name="index">only</span> other one<span class="em">&mdash;</span>our friendly C compiler requires
them <em>all</em> to accept the parameter.</p>
<aside name="index">
<p>If Lox had arrays and subscript operators like <code>array[index]</code> then an infix <code>[</code>
would also allow assignment to support <code>array[index] = value</code>.</p>
</aside>
<p>So we&rsquo;re going to finish off this chapter with some grunt work. First, let&rsquo;s go
ahead and pass the flag to the infix parse functions.</p>
<div class="codehilite"><pre class="insert-before">    ParseFn infixRule = getRule(parser.previous.type)-&gt;infix;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parsePrecedence</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">infixRule</span>(<span class="i">canAssign</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>(), replace 1 line</div>

<p>We&rsquo;ll need that for setters eventually. Then we&rsquo;ll fix the typedef for the
function type.</p>
<div class="codehilite"><pre class="insert-before">} Precedence;

</pre><div class="source-file"><em>compiler.c</em><br>
add after enum <em>Precedence</em><br>
replace 1 line</div>
<pre class="insert"><span class="k">typedef</span> <span class="t">void</span> (*<span class="t">ParseFn</span>)(<span class="t">bool</span> <span class="i">canAssign</span>);
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>Precedence</em>, replace 1 line</div>

<p>And some completely tedious code to accept this parameter in all of our existing
parse functions. Here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>binary</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">binary</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  TokenType operatorType = parser.previous.type;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>binary</em>(), replace 1 line</div>

<p>And here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>literal</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">literal</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  switch (parser.previous.type) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>literal</em>(), replace 1 line</div>

<p>And here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>grouping</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">grouping</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  expression();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>grouping</em>(), replace 1 line</div>

<p>And here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>number</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">number</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  double value = strtod(parser.previous.start, NULL);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>number</em>(), replace 1 line</div>

<p>And here too:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>string</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">string</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  emitConstant(OBJ_VAL(copyString(parser.previous.start + 1,
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>string</em>(), replace 1 line</div>

<p>And, finally:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>unary</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">unary</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  TokenType operatorType = parser.previous.type;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>unary</em>(), replace 1 line</div>

<p>Phew! We&rsquo;re back to a C program we can compile. Fire it up and now you can run
this:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">breakfast</span> = <span class="s">&quot;beignets&quot;</span>;
<span class="k">var</span> <span class="i">beverage</span> = <span class="s">&quot;cafe au lait&quot;</span>;
<span class="i">breakfast</span> = <span class="s">&quot;beignets with &quot;</span> + <span class="i">beverage</span>;

<span class="k">print</span> <span class="i">breakfast</span>;
</pre></div>
<p>It&rsquo;s starting to look like real code for an actual language!</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>The compiler adds a global variable&rsquo;s name to the constant table as a string
every time an identifier is encountered. It creates a new constant each
time, even if that variable name is already in a previous slot in the
constant table. That&rsquo;s wasteful in cases where the same variable is
referenced multiple times by the same function. That, in turn, increases the
odds of filling up the constant table and running out of slots since we
allow only 256 constants in a single chunk.</p>
<p>Optimize this. How does your optimization affect the performance of the
compiler compared to the runtime? Is this the right trade-off?</p>
</li>
<li>
<p>Looking up a global variable by name in a hash table each time it is used
is pretty slow, even with a good hash table. Can you come up with a more
efficient way to store and access global variables without changing the
semantics?</p>
</li>
<li>
<p>When running in the REPL, a user might write a function that references an
unknown global variable. Then, in the next line, they declare the variable.
Lox should handle this gracefully by not reporting an &ldquo;unknown variable&rdquo;
compile error when the function is first defined.</p>
<p>But when a user runs a Lox <em>script</em>, the compiler has access to the full
text of the entire program before any code is run. Consider this program:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">useVar</span>() {
  <span class="k">print</span> <span class="i">oops</span>;
}

<span class="k">var</span> <span class="i">ooops</span> = <span class="s">&quot;too many o&#39;s!&quot;</span>;
</pre></div>
<p>Here, we can tell statically that <code>oops</code> will not be defined because there
is <em>no</em> declaration of that global anywhere in the program. Note that
<code>useVar()</code> is never called either, so even though the variable isn&rsquo;t
defined, no runtime error will occur because it&rsquo;s never used either.</p>
<p>We could report mistakes like this as compile errors, at least when running
from a script. Do you think we should? Justify your answer. What do other
scripting languages you know do?</p>
</li>
</ol>
</div>

<footer>
<a href="local-variables.html" class="next">
  Next Chapter: &ldquo;Local Variables&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Local Variables &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Local Variables<small>22</small></a></h3>

<ul>
    <li><a href="#representing-local-variables"><small>22.1</small> Representing Local Variables</a></li>
    <li><a href="#block-statements"><small>22.2</small> Block Statements</a></li>
    <li><a href="#declaring-local-variables"><small>22.3</small> Declaring Local Variables</a></li>
    <li><a href="#using-locals"><small>22.4</small> Using Locals</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="global-variables.html" title="Global Variables" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="global-variables.html" title="Global Variables" class="prev">←</a>
<a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Local Variables<small>22</small></a></h3>

<ul>
    <li><a href="#representing-local-variables"><small>22.1</small> Representing Local Variables</a></li>
    <li><a href="#block-statements"><small>22.2</small> Block Statements</a></li>
    <li><a href="#declaring-local-variables"><small>22.3</small> Declaring Local Variables</a></li>
    <li><a href="#using-locals"><small>22.4</small> Using Locals</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="global-variables.html" title="Global Variables" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">22</div>
  <h1>Local Variables</h1>

<blockquote>
<p>And as imagination bodies forth<br />
The forms of things unknown, the poet&rsquo;s pen<br />
Turns them to shapes and gives to airy nothing<br />
A local habitation and a name.</p>
<p><cite>William Shakespeare, <em>A Midsummer Night&rsquo;s Dream</em></cite></p>
</blockquote>
<p>The <a href="global-variables.html">last chapter</a> introduced variables to clox, but only of the <span
name="global">global</span> variety. In this chapter, we&rsquo;ll extend that to
support blocks, block scope, and local variables. In jlox, we managed to pack
all of that and globals into one chapter. For clox, that&rsquo;s two chapters worth of
work partially because, frankly, everything takes more effort in C.</p>
<aside name="global">
<p>There&rsquo;s probably some dumb &ldquo;think globally, act locally&rdquo; joke here, but I&rsquo;m
struggling to find it.</p>
</aside>
<p>But an even more important reason is that our approach to local variables will
be quite different from how we implemented globals. Global variables are late
bound in Lox. &ldquo;Late&rdquo; in this context means &ldquo;resolved after compile time&rdquo;. That&rsquo;s
good for keeping the compiler simple, but not great for performance. Local
variables are one of the most-used <span name="params">parts</span> of a
language. If locals are slow, <em>everything</em> is slow. So we want a strategy for
local variables that&rsquo;s as efficient as possible.</p>
<aside name="params">
<p>Function parameters are also heavily used. They work like local variables too,
so we&rsquo;ll use the same implementation technique for them.</p>
</aside>
<p>Fortunately, lexical scoping is here to help us. As the name implies, lexical
scope means we can resolve a local variable just by looking at the text of the
program<span class="em">&mdash;</span>locals are <em>not</em> late bound. Any processing work we do in the
compiler is work we <em>don&rsquo;t</em> have to do at runtime, so our implementation of
local variables will lean heavily on the compiler.</p>
<h2><a href="#representing-local-variables" id="representing-local-variables"><small>22&#8202;.&#8202;1</small>Representing Local Variables</a></h2>
<p>The nice thing about hacking on a programming language in modern times is
there&rsquo;s a long lineage of other languages to learn from. So how do C and Java
manage their local variables? Why, on the stack, of course! They typically use
the native stack mechanisms supported by the chip and OS. That&rsquo;s a little too
low level for us, but inside the virtual world of clox, we have our own stack we
can use.</p>
<p>Right now, we only use it for holding on to <strong>temporaries</strong><span class="em">&mdash;</span>short-lived blobs
of data that we need to remember while computing an expression. As long as we
don&rsquo;t get in the way of those, we can stuff our local variables onto the stack
too. This is great for performance. Allocating space for a new local requires
only incrementing the <code>stackTop</code> pointer, and freeing is likewise a decrement.
Accessing a variable from a known stack slot is an indexed array lookup.</p>
<p>We do need to be careful, though. The VM expects the stack to behave like, well,
a stack. We have to be OK with allocating new locals only on the top of the
stack, and we have to accept that we can discard a local only when nothing is
above it on the stack. Also, we need to make sure temporaries don&rsquo;t interfere.</p>
<p>Conveniently, the design of Lox is in <span name="harmony">harmony</span> with
these constraints. New locals are always created by declaration statements.
Statements don&rsquo;t nest inside expressions, so there are never any temporaries on
the stack when a statement begins executing. Blocks are strictly nested. When a
block ends, it always takes the innermost, most recently declared locals with
it. Since those are also the locals that came into scope last, they should be on
top of the stack where we need them.</p>
<aside name="harmony">
<p>This alignment obviously isn&rsquo;t coincidental. I designed Lox to be amenable to
single-pass compilation to stack-based bytecode. But I didn&rsquo;t have to tweak the
language too much to fit in those restrictions. Most of its design should feel
pretty natural.</p>
<p>This is in large part because the history of languages is deeply tied to
single-pass compilation and<span class="em">&mdash;</span>to a lesser degree<span class="em">&mdash;</span>stack-based architectures.
Lox&rsquo;s block scoping follows a tradition stretching back to BCPL. As programmers,
our intuition of what&rsquo;s &ldquo;normal&rdquo; in a language is informed even today by the
hardware limitations of yesteryear.</p>
</aside>
<p>Step through this example program and watch how the local variables come in and
go out of scope:</p><img src="image/local-variables/scopes.png" alt="A series of local variables come into and out of scope in a stack-like fashion." />
<p>See how they fit a stack perfectly? It seems that the stack will work for
storing locals at runtime. But we can go further than that. Not only do we know
<em>that</em> they will be on the stack, but we can even pin down precisely <em>where</em>
they will be on the stack. Since the compiler knows exactly which local
variables are in scope at any point in time, it can effectively simulate the
stack during compilation and note <span name="fn">where</span> in the stack each
variable lives.</p>
<p>We&rsquo;ll take advantage of this by using these stack offsets as operands for the
bytecode instructions that read and store local variables. This makes working
with locals deliciously fast<span class="em">&mdash;</span>as simple as indexing into an array.</p>
<aside name="fn">
<p>In this chapter, locals start at the bottom of the VM&rsquo;s stack array and are
indexed from there. When we add <a href="calls-and-functions.html">functions</a>, that scheme gets a little more
complex. Each function needs its own region of the stack for its parameters and
local variables. But, as we&rsquo;ll see, that doesn&rsquo;t add as much complexity as you
might expect.</p>
</aside>
<p>There&rsquo;s a lot of state we need to track in the compiler to make this whole thing
go, so let&rsquo;s get started there. In jlox, we used a linked chain of &ldquo;environment&rdquo;
HashMaps to track which local variables were currently in scope. That&rsquo;s sort of
the classic, schoolbook way of representing lexical scope. For clox, as usual,
we&rsquo;re going a little closer to the metal. All of the state lives in a new
struct.</p>
<div class="codehilite"><pre class="insert-before">} ParseRule;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>ParseRule</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Local</span> <span class="i">locals</span>[<span class="a">UINT8_COUNT</span>];
  <span class="t">int</span> <span class="i">localCount</span>;
  <span class="t">int</span> <span class="i">scopeDepth</span>;
} <span class="t">Compiler</span>;
</pre><pre class="insert-after">

Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>ParseRule</em></div>

<p>We have a simple, flat array of all locals that are in scope during each point in
the compilation process. They are <span name="order">ordered</span> in the array
in the order that their declarations appear in the code. Since the instruction
operand we&rsquo;ll use to encode a local is a single byte, our VM has a hard limit on
the number of locals that can be in scope at once. That means we can also give
the locals array a fixed size.</p>
<aside name="order">
<p>We&rsquo;re writing a single-pass compiler, so it&rsquo;s not like we have <em>too</em> many other
options for how to order them in the array.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#define DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert">

<span class="a">#define UINT8_COUNT (UINT8_MAX + 1)</span>
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>Back in the Compiler struct, the <code>localCount</code> field tracks how many locals are
in scope<span class="em">&mdash;</span>how many of those array slots are in use. We also track the &ldquo;scope
depth&rdquo;. This is the number of blocks surrounding the current bit of code we&rsquo;re
compiling.</p>
<p>Our Java interpreter used a chain of maps to keep each block&rsquo;s variables
separate from other blocks&rsquo;. This time, we&rsquo;ll simply number variables with the
level of nesting where they appear. Zero is the global scope, one is the first
top-level block, two is inside that, you get the idea. We use this to track
which block each local belongs to so that we know which locals to discard when a
block ends.</p>
<p>Each local in the array is one of these:</p>
<div class="codehilite"><pre class="insert-before">} ParseRule;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>ParseRule</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Token</span> <span class="i">name</span>;
  <span class="t">int</span> <span class="i">depth</span>;
} <span class="t">Local</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>ParseRule</em></div>

<p>We store the name of the variable. When we&rsquo;re resolving an identifier, we
compare the identifier&rsquo;s lexeme with each local&rsquo;s name to find a match. It&rsquo;s
pretty hard to resolve a variable if you don&rsquo;t know its name. The <code>depth</code> field
records the scope depth of the block where the local variable was declared.
That&rsquo;s all the state we need for now.</p>
<p>This is a very different representation from what we had in jlox, but it still
lets us answer all of the same questions our compiler needs to ask of the
lexical environment. The next step is figuring out how the compiler <em>gets</em> at
this state. If we were <span name="thread">principled</span> engineers, we&rsquo;d
give each function in the front end a parameter that accepts a pointer to a
Compiler. We&rsquo;d create a Compiler at the beginning and carefully thread it
through each function call<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>but that would mean a lot of boring changes to
the code we already wrote, so here&rsquo;s a global variable instead:</p>
<aside name="thread">
<p>In particular, if we ever want to use our compiler in a multi-threaded
application, possibly with multiple compilers running in parallel, then using a
global variable is a <em>bad</em> idea.</p>
</aside>
<div class="codehilite"><pre class="insert-before">Parser parser;
</pre><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre class="insert"><span class="t">Compiler</span>* <span class="i">current</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">Chunk* compilingChunk;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>Here&rsquo;s a little function to initialize the compiler:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">initCompiler</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>) {
  <span class="i">compiler</span>-&gt;<span class="i">localCount</span> = <span class="n">0</span>;
  <span class="i">compiler</span>-&gt;<span class="i">scopeDepth</span> = <span class="n">0</span>;
  <span class="i">current</span> = <span class="i">compiler</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitConstant</em>()</div>

<p>When we first start up the VM, we call it to get everything into a clean state.</p>
<div class="codehilite"><pre class="insert-before">  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="t">Compiler</span> <span class="i">compiler</span>;
  <span class="i">initCompiler</span>(&amp;<span class="i">compiler</span>);
</pre><pre class="insert-after">  compilingChunk = chunk;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>Our compiler has the data it needs, but not the operations on that data. There&rsquo;s
no way to create and destroy scopes, or add and resolve variables. We&rsquo;ll add
those as we need them. First, let&rsquo;s start building some language features.</p>
<h2><a href="#block-statements" id="block-statements"><small>22&#8202;.&#8202;2</small>Block Statements</a></h2>
<p>Before we can have any local variables, we need some local scopes. These come
from two things: function bodies and <span name="block">blocks</span>. Functions
are a big chunk of work that we&rsquo;ll tackle in <a href="calls-and-functions.html">a later chapter</a>, so
for now we&rsquo;re only going to do blocks. As usual, we start with the syntax. The
new grammar we&rsquo;ll introduce is:</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">block</span>          → <span class="s">&quot;{&quot;</span> <span class="i">declaration</span>* <span class="s">&quot;}&quot;</span> ;
</pre></div>
<aside name="block">
<p>When you think about it, &ldquo;block&rdquo; is a weird name. Used metaphorically, &ldquo;block&rdquo;
usually means a small indivisible unit, but for some reason, the Algol 60
committee decided to use it to refer to a <em>compound</em> structure<span class="em">&mdash;</span>a series of
statements. It could be worse, I suppose. Algol 58 called <code>begin</code> and <code>end</code>
&ldquo;statement parentheses&rdquo;.</p><img src="image/local-variables/block.png" alt="A cinder block." class="above" />
</aside>
<p>Blocks are a kind of statement, so the rule for them goes in the <code>statement</code>
production. The corresponding code to compile one looks like this:</p>
<div class="codehilite"><pre class="insert-before">  if (match(TOKEN_PRINT)) {
    printStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_LEFT_BRACE</span>)) {
    <span class="i">beginScope</span>();
    <span class="i">block</span>();
    <span class="i">endScope</span>();
</pre><pre class="insert-after">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>After <span name="helper">parsing</span> the initial curly brace, we use this
helper function to compile the rest of the block:</p>
<aside name="helper">
<p>This function will come in handy later for compiling function bodies.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">block</span>() {
  <span class="k">while</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_BRACE</span>) &amp;&amp; !<span class="i">check</span>(<span class="a">TOKEN_EOF</span>)) {
    <span class="i">declaration</span>();
  }

  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_BRACE</span>, <span class="s">&quot;Expect &#39;}&#39; after block.&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>It keeps parsing declarations and statements until it hits the closing brace. As
we do with any loop in the parser, we also check for the end of the token
stream. This way, if there&rsquo;s a malformed program with a missing closing curly,
the compiler doesn&rsquo;t get stuck in a loop.</p>
<p>Executing a block simply means executing the statements it contains, one after
the other, so there isn&rsquo;t much to compiling them. The semantically interesting
thing blocks do is create scopes. Before we compile the body of a block, we call
this function to enter a new local scope:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">beginScope</span>() {
  <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>In order to &ldquo;create&rdquo; a scope, all we do is increment the current depth. This is
certainly much faster than jlox, which allocated an entire new HashMap for
each one. Given <code>beginScope()</code>, you can probably guess what <code>endScope()</code> does.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>beginScope</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">endScope</span>() {
  <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>--;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>beginScope</em>()</div>

<p>That&rsquo;s it for blocks and scopes<span class="em">&mdash;</span>more or less<span class="em">&mdash;</span>so we&rsquo;re ready to stuff some
variables into them.</p>
<h2><a href="#declaring-local-variables" id="declaring-local-variables"><small>22&#8202;.&#8202;3</small>Declaring Local Variables</a></h2>
<p>Usually we start with parsing here, but our compiler already supports parsing
and compiling variable declarations. We&rsquo;ve got <code>var</code> statements, identifier
expressions and assignment in there now. It&rsquo;s just that the compiler assumes
all variables are global. So we don&rsquo;t need any new parsing support, we just need
to hook up the new scoping semantics to the existing code.</p><img src="image/local-variables/declaration.png" alt="The code flow within varDeclaration()." />
<p>Variable declaration parsing begins in <code>varDeclaration()</code> and relies on a couple
of other functions. First, <code>parseVariable()</code> consumes the identifier token for
the variable name, adds its lexeme to the chunk&rsquo;s constant table as a string,
and then returns the constant table index where it was added. Then, after
<code>varDeclaration()</code> compiles the initializer, it calls <code>defineVariable()</code> to emit
the bytecode for storing the variable&rsquo;s value in the global variable hash table.</p>
<p>Both of those helpers need a few changes to support local variables. In
<code>parseVariable()</code>, we add:</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_IDENTIFIER, errorMessage);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parseVariable</em>()</div>
<pre class="insert">

  <span class="i">declareVariable</span>();
  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> &gt; <span class="n">0</span>) <span class="k">return</span> <span class="n">0</span>;

</pre><pre class="insert-after">  return identifierConstant(&amp;parser.previous);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parseVariable</em>()</div>

<p>First, we &ldquo;declare&rdquo; the variable. I&rsquo;ll get to what that means in a second. After
that, we exit the function if we&rsquo;re in a local scope. At runtime, locals aren&rsquo;t
looked up by name. There&rsquo;s no need to stuff the variable&rsquo;s name into the
constant table, so if the declaration is inside a local scope, we return a dummy
table index instead.</p>
<p>Over in <code>defineVariable()</code>, we need to emit the code to store a local variable
if we&rsquo;re in a local scope. It looks like this:</p>
<div class="codehilite"><pre class="insert-before">static void defineVariable(uint8_t global) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>defineVariable</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> &gt; <span class="n">0</span>) {
    <span class="k">return</span>;
  }

</pre><pre class="insert-after">  emitBytes(OP_DEFINE_GLOBAL, global);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>defineVariable</em>()</div>

<p>Wait, what? Yup. That&rsquo;s it. There is no code to create a local variable at
runtime. Think about what state the VM is in. It has already executed the code
for the variable&rsquo;s initializer (or the implicit <code>nil</code> if the user omitted an
initializer), and that value is sitting right on top of the stack as the only
remaining temporary. We also know that new locals are allocated at the top of
the stack<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>right where that value already is. Thus, there&rsquo;s nothing to do. The
temporary simply <em>becomes</em> the local variable. It doesn&rsquo;t get much more
efficient than that.</p>
<p><span name="locals"></span></p><img src="image/local-variables/local-slots.png" alt="Walking through the bytecode execution showing that each initializer's result ends up in the local's slot." />
<aside name="locals">
<p>The code on the left compiles to the sequence of instructions on the right.</p>
</aside>
<p>OK, so what&rsquo;s &ldquo;declaring&rdquo; about? Here&rsquo;s what that does:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">declareVariable</span>() {
  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> == <span class="n">0</span>) <span class="k">return</span>;

  <span class="t">Token</span>* <span class="i">name</span> = &amp;<span class="i">parser</span>.<span class="i">previous</span>;
  <span class="i">addLocal</span>(*<span class="i">name</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>This is the point where the compiler records the existence of the variable. We
only do this for locals, so if we&rsquo;re in the top-level global scope, we just bail
out. Because global variables are late bound, the compiler doesn&rsquo;t keep track of
which declarations for them it has seen.</p>
<p>But for local variables, the compiler does need to remember that the variable
exists. That&rsquo;s what declaring it does<span class="em">&mdash;</span>it adds it to the compiler&rsquo;s list of
variables in the current scope. We implement that using another new function.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">addLocal</span>(<span class="t">Token</span> <span class="i">name</span>) {
  <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span>++];
  <span class="i">local</span>-&gt;<span class="i">name</span> = <span class="i">name</span>;
  <span class="i">local</span>-&gt;<span class="i">depth</span> = <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>This initializes the next available Local in the compiler&rsquo;s array of variables.
It stores the variable&rsquo;s <span name="lexeme">name</span> and the depth of the
scope that owns the variable.</p>
<aside name="lexeme">
<p>Worried about the lifetime of the string for the variable&rsquo;s name? The Local
directly stores a copy of the Token struct for the identifier. Tokens store a
pointer to the first character of their lexeme and the lexeme&rsquo;s length. That
pointer points into the original source string for the script or REPL entry
being compiled.</p>
<p>As long as that string stays around during the entire compilation process<span class="em">&mdash;</span>which it must since, you know, we&rsquo;re compiling it<span class="em">&mdash;</span>then all of the tokens
pointing into it are fine.</p>
</aside>
<p>Our implementation is fine for a correct Lox program, but what about invalid
code? Let&rsquo;s aim to be robust. The first error to handle is not really the user&rsquo;s
fault, but more a limitation of the VM. The instructions to work with local
variables refer to them by slot index. That index is stored in a single-byte
operand, which means the VM only supports up to 256 local variables in scope at
one time.</p>
<p>If we try to go over that, not only could we not refer to them at runtime, but
the compiler would overwrite its own locals array, too. Let&rsquo;s prevent that.</p>
<div class="codehilite"><pre class="insert-before">static void addLocal(Token name) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addLocal</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">localCount</span> == <span class="a">UINT8_COUNT</span>) {
    <span class="i">error</span>(<span class="s">&quot;Too many local variables in function.&quot;</span>);
    <span class="k">return</span>;
  }

</pre><pre class="insert-after">  Local* local = &amp;current-&gt;locals[current-&gt;localCount++];
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addLocal</em>()</div>

<p>The next case is trickier. Consider:</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;first&quot;</span>;
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;second&quot;</span>;
}
</pre></div>
<p>At the top level, Lox allows redeclaring a variable with the same name as a
previous declaration because that&rsquo;s useful for the REPL. But inside a local
scope, that&rsquo;s a pretty <span name="rust">weird</span> thing to do. It&rsquo;s likely
to be a mistake, and many languages, including our own Lox, enshrine that
assumption by making this an error.</p>
<aside name="rust">
<p>Interestingly, the Rust programming language <em>does</em> allow this, and idiomatic
code relies on it.</p>
</aside>
<p>Note that the above program is different from this one:</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;outer&quot;</span>;
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;inner&quot;</span>;
  }
}
</pre></div>
<p>It&rsquo;s OK to have two variables with the same name in <em>different</em> scopes, even
when the scopes overlap such that both are visible at the same time. That&rsquo;s
shadowing, and Lox does allow that. It&rsquo;s only an error to have two variables
with the same name in the <em>same</em> local scope.</p>
<p>We detect that error like so:</p>
<div class="codehilite"><pre class="insert-before">  Token* name = &amp;parser.previous;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declareVariable</em>()</div>
<pre class="insert">  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">local</span>-&gt;<span class="i">depth</span> != -<span class="n">1</span> &amp;&amp; <span class="i">local</span>-&gt;<span class="i">depth</span> &lt; <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>) {
      <span class="k">break</span>;<span name="negative"> </span>
    }

    <span class="k">if</span> (<span class="i">identifiersEqual</span>(<span class="i">name</span>, &amp;<span class="i">local</span>-&gt;<span class="i">name</span>)) {
      <span class="i">error</span>(<span class="s">&quot;Already a variable with this name in this scope.&quot;</span>);
    }
  }

</pre><pre class="insert-after">  addLocal(*name);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declareVariable</em>()</div>

<aside name="negative">
<p>Don&rsquo;t worry about that odd <code>depth != -1</code> part yet. We&rsquo;ll get to what that&rsquo;s
about later.</p>
</aside>
<p>Local variables are appended to the array when they&rsquo;re declared, which means the
current scope is always at the end of the array. When we declare a new variable,
we start at the end and work backward, looking for an existing variable with the
same name. If we find one in the current scope, we report the error. Otherwise,
if we reach the beginning of the array or a variable owned by another scope,
then we know we&rsquo;ve checked all of the existing variables in the scope.</p>
<p>To see if two identifiers are the same, we use this:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">identifiersEqual</span>(<span class="t">Token</span>* <span class="i">a</span>, <span class="t">Token</span>* <span class="i">b</span>) {
  <span class="k">if</span> (<span class="i">a</span>-&gt;<span class="i">length</span> != <span class="i">b</span>-&gt;<span class="i">length</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">return</span> <span class="i">memcmp</span>(<span class="i">a</span>-&gt;<span class="i">start</span>, <span class="i">b</span>-&gt;<span class="i">start</span>, <span class="i">a</span>-&gt;<span class="i">length</span>) == <span class="n">0</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>Since we know the lengths of both lexemes, we check that first. That will fail
quickly for many non-equal strings. If the <span name="hash">lengths</span> are
the same, we check the characters using <code>memcmp()</code>. To get to <code>memcmp()</code>, we
need an include.</p>
<aside name="hash">
<p>It would be a nice little optimization if we could check their hashes, but
tokens aren&rsquo;t full LoxStrings, so we haven&rsquo;t calculated their hashes yet.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#include &lt;stdlib.h&gt;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert"><span class="a">#include &lt;string.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>With this, we&rsquo;re able to bring variables into being. But, like ghosts, they
linger on beyond the scope where they are declared. When a block ends, we need
to put them to rest.</p>
<div class="codehilite"><pre class="insert-before">  current-&gt;scopeDepth--;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endScope</em>()</div>
<pre class="insert">

  <span class="k">while</span> (<span class="i">current</span>-&gt;<span class="i">localCount</span> &gt; <span class="n">0</span> &amp;&amp;
         <span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>].<span class="i">depth</span> &gt;
            <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>) {
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
    <span class="i">current</span>-&gt;<span class="i">localCount</span>--;
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endScope</em>()</div>

<p>When we pop a scope, we walk backward through the local array looking for any
variables declared at the scope depth we just left. We discard them by simply
decrementing the length of the array.</p>
<p>There is a runtime component to this too. Local variables occupy slots on the
stack. When a local variable goes out of scope, that slot is no longer needed
and should be freed. So, for each variable that we discard, we also emit an
<code>OP_POP</code> <span name="pop">instruction</span> to pop it from the stack.</p>
<aside name="pop">
<p>When multiple local variables go out of scope at once, you get a series of
<code>OP_POP</code> instructions that get interpreted one at a time. A simple optimization
you could add to your Lox implementation is a specialized <code>OP_POPN</code> instruction
that takes an operand for the number of slots to pop and pops them all at once.</p>
</aside>
<h2><a href="#using-locals" id="using-locals"><small>22&#8202;.&#8202;4</small>Using Locals</a></h2>
<p>We can now compile and execute local variable declarations. At runtime, their
values are sitting where they should be on the stack. Let&rsquo;s start using them.
We&rsquo;ll do both variable access and assignment at the same time since they touch
the same functions in the compiler.</p>
<p>We already have code for getting and setting global variables, and<span class="em">&mdash;</span>like good
little software engineers<span class="em">&mdash;</span>we want to reuse as much of that existing code as
we can. Something like this:</p>
<div class="codehilite"><pre class="insert-before">static void namedVariable(Token name, bool canAssign) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">uint8_t</span> <span class="i">getOp</span>, <span class="i">setOp</span>;
  <span class="t">int</span> <span class="i">arg</span> = <span class="i">resolveLocal</span>(<span class="i">current</span>, &amp;<span class="i">name</span>);
  <span class="k">if</span> (<span class="i">arg</span> != -<span class="n">1</span>) {
    <span class="i">getOp</span> = <span class="a">OP_GET_LOCAL</span>;
    <span class="i">setOp</span> = <span class="a">OP_SET_LOCAL</span>;
  } <span class="k">else</span> {
    <span class="i">arg</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">name</span>);
    <span class="i">getOp</span> = <span class="a">OP_GET_GLOBAL</span>;
    <span class="i">setOp</span> = <span class="a">OP_SET_GLOBAL</span>;
  }
</pre><pre class="insert-after">

  if (canAssign &amp;&amp; match(TOKEN_EQUAL)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>Instead of hardcoding the bytecode instructions emitted for variable access and
assignment, we use a couple of C variables. First, we try to find a local
variable with the given name. If we find one, we use the instructions for
working with locals. Otherwise, we assume it&rsquo;s a global variable and use the
existing bytecode instructions for globals.</p>
<p>A little further down, we use those variables to emit the right instructions.
For assignment:</p>
<div class="codehilite"><pre class="insert-before">  if (canAssign &amp;&amp; match(TOKEN_EQUAL)) {
    expression();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">emitBytes</span>(<span class="i">setOp</span>, (<span class="t">uint8_t</span>)<span class="i">arg</span>);
</pre><pre class="insert-after">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>And for access:</p>
<div class="codehilite"><pre class="insert-before">    emitBytes(setOp, (uint8_t)arg);
  } else {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">emitBytes</span>(<span class="i">getOp</span>, (<span class="t">uint8_t</span>)<span class="i">arg</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>The real heart of this chapter, the part where we resolve a local variable, is
here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifiersEqual</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">resolveLocal</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">Token</span>* <span class="i">name</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">compiler</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">compiler</span>-&gt;<span class="i">locals</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">identifiersEqual</span>(<span class="i">name</span>, &amp;<span class="i">local</span>-&gt;<span class="i">name</span>)) {
      <span class="k">return</span> <span class="i">i</span>;
    }
  }

  <span class="k">return</span> -<span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifiersEqual</em>()</div>

<p>For all that, it&rsquo;s straightforward. We walk the list of locals that are
currently in scope. If one has the same name as the identifier token, the
identifier must refer to that variable. We&rsquo;ve found it! We walk the array
backward so that we find the <em>last</em> declared variable with the identifier. That
ensures that inner local variables correctly shadow locals with the same name in
surrounding scopes.</p>
<p>At runtime, we load and store locals using the stack slot index, so that&rsquo;s what
the compiler needs to calculate after it resolves the variable. Whenever a
variable is declared, we append it to the locals array in Compiler. That means
the first local variable is at index zero, the next one is at index one, and so
on. In other words, the locals array in the compiler has the <em>exact</em> same layout
as the VM&rsquo;s stack will have at runtime. The variable&rsquo;s index in the locals array
is the same as its stack slot. How convenient!</p>
<p>If we make it through the whole array without finding a variable with the given
name, it must not be a local. In that case, we return <code>-1</code> to signal that it
wasn&rsquo;t found and should be assumed to be a global variable instead.</p>
<h3><a href="#interpreting-local-variables" id="interpreting-local-variables"><small>22&#8202;.&#8202;4&#8202;.&#8202;1</small>Interpreting local variables</a></h3>
<p>Our compiler is emitting two new instructions, so let&rsquo;s get them working. First
is loading a local variable:</p>
<div class="codehilite"><pre class="insert-before">  OP_POP,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_GET_LOCAL</span>,
</pre><pre class="insert-after">  OP_GET_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>And its implementation:</p>
<div class="codehilite"><pre class="insert-before">      case OP_POP: pop(); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GET_LOCAL</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        <span class="i">push</span>(<span class="i">vm</span>.<span class="i">stack</span>[<span class="i">slot</span>]);<span name="slot"> </span>
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_GET_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>It takes a single-byte operand for the stack slot where the local lives. It
loads the value from that index and then pushes it on top of the stack where
later instructions can find it.</p>
<aside name="slot">
<p>It seems redundant to push the local&rsquo;s value onto the stack since it&rsquo;s already
on the stack lower down somewhere. The problem is that the other bytecode
instructions only look for data at the <em>top</em> of the stack. This is the core
aspect that makes our bytecode instruction set <em>stack</em>-based.
<a href="a-virtual-machine.html#design-note">Register-based</a> bytecode instruction sets avoid this stack juggling at the
cost of having larger instructions with more operands.</p>
</aside>
<p>Next is assignment:</p>
<div class="codehilite"><pre class="insert-before">  OP_GET_LOCAL,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_SET_LOCAL</span>,
</pre><pre class="insert-after">  OP_GET_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>You can probably predict the implementation.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_SET_LOCAL</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        <span class="i">vm</span>.<span class="i">stack</span>[<span class="i">slot</span>] = <span class="i">peek</span>(<span class="n">0</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_GET_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>It takes the assigned value from the top of the stack and stores it in the stack
slot corresponding to the local variable. Note that it doesn&rsquo;t pop the value
from the stack. Remember, assignment is an expression, and every expression
produces a value. The value of an assignment expression is the assigned value
itself, so the VM just leaves the value on the stack.</p>
<p>Our disassembler is incomplete without support for these two new instructions.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_POP&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_GET_LOCAL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_GET_LOCAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SET_LOCAL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_SET_LOCAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_GET_GLOBAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>The compiler compiles local variables to direct slot access. The local
variable&rsquo;s name never leaves the compiler to make it into the chunk at all.
That&rsquo;s great for performance, but not so great for introspection. When we
disassemble these instructions, we can&rsquo;t show the variable&rsquo;s name like we could
with globals. Instead, we just show the slot number.</p>
<aside name="debug">
<p>Erasing local variable names in the compiler is a real issue if we ever want to
implement a debugger for our VM. When users step through code, they expect to
see the values of local variables organized by their names. To support that,
we&rsquo;d need to output some additional information that tracks the name of each
local variable at each stack slot.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
add after <em>simpleInstruction</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">byteInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>,
                           <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>];
  <span class="i">printf</span>(<span class="s">&quot;%-16s %4d</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">name</span>, <span class="i">slot</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">2</span>;<span name="debug"> </span>
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>simpleInstruction</em>()</div>

<h3><a href="#another-scope-edge-case" id="another-scope-edge-case"><small>22&#8202;.&#8202;4&#8202;.&#8202;2</small>Another scope edge case</a></h3>
<p>We already sunk some time into handling a couple of weird edge cases around
scopes. We made sure shadowing works correctly. We report an error if two
variables in the same local scope have the same name. For reasons that aren&rsquo;t
entirely clear to me, variable scoping seems to have a lot of these wrinkles.
I&rsquo;ve never seen a language where it feels completely <span
name="elegant">elegant</span>.</p>
<aside name="elegant">
<p>No, not even Scheme.</p>
</aside>
<p>We&rsquo;ve got one more edge case to deal with before we end this chapter. Recall this strange beastie we first met in <a href="resolving-and-binding.html#resolving-variable-declarations">jlox&rsquo;s implementation of variable resolution</a>:</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;outer&quot;</span>;
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
  }
}
</pre></div>
<p>We slayed it then by splitting a variable&rsquo;s declaration into two phases, and
we&rsquo;ll do that again here:</p><img src="image/local-variables/phases.png" alt="An example variable declaration marked 'declared uninitialized' before the variable name and 'ready for use' after the initializer." />
<p>As soon as the variable declaration begins<span class="em">&mdash;</span>in other words, before its
initializer<span class="em">&mdash;</span>the name is declared in the current scope. The variable exists,
but in a special &ldquo;uninitialized&rdquo; state. Then we compile the initializer. If at
any point in that expression we resolve an identifier that points back to this
variable, we&rsquo;ll see that it is not initialized yet and report an error. After we
finish compiling the initializer, we mark the variable as initialized and ready
for use.</p>
<p>To implement this, when we declare a local, we need to indicate the
&ldquo;uninitialized&rdquo; state somehow. We could add a new field to Local, but let&rsquo;s be a
little more parsimonious with memory. Instead, we&rsquo;ll set the variable&rsquo;s scope
depth to a special sentinel value, <code>-1</code>.</p>
<div class="codehilite"><pre class="insert-before">  local-&gt;name = name;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addLocal</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">local</span>-&gt;<span class="i">depth</span> = -<span class="n">1</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addLocal</em>(), replace 1 line</div>

<p>Later, once the variable&rsquo;s initializer has been compiled, we mark it
initialized.</p>
<div class="codehilite"><pre class="insert-before">  if (current-&gt;scopeDepth &gt; 0) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>defineVariable</em>()</div>
<pre class="insert">    <span class="i">markInitialized</span>();
</pre><pre class="insert-after">    return;
  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>defineVariable</em>()</div>

<p>That is implemented like so:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>parseVariable</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">markInitialized</span>() {
  <span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>].<span class="i">depth</span> =
      <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parseVariable</em>()</div>

<p>So this is <em>really</em> what &ldquo;declaring&rdquo; and &ldquo;defining&rdquo; a variable means in the
compiler. &ldquo;Declaring&rdquo; is when the variable is added to the scope, and &ldquo;defining&rdquo;
is when it becomes available for use.</p>
<p>When we resolve a reference to a local variable, we check the scope depth to see
if it&rsquo;s fully defined.</p>
<div class="codehilite"><pre class="insert-before">    if (identifiersEqual(name, &amp;local-&gt;name)) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>resolveLocal</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">local</span>-&gt;<span class="i">depth</span> == -<span class="n">1</span>) {
        <span class="i">error</span>(<span class="s">&quot;Can&#39;t read local variable in its own initializer.&quot;</span>);
      }
</pre><pre class="insert-after">      return i;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>resolveLocal</em>()</div>

<p>If the variable has the sentinel depth, it must be a reference to a variable in
its own initializer, and we report that as an error.</p>
<p>That&rsquo;s it for this chapter! We added blocks, local variables, and real,
honest-to-God lexical scoping. Given that we introduced an entirely different
runtime representation for variables, we didn&rsquo;t have to write a lot of code. The
implementation ended up being pretty clean and efficient.</p>
<p>You&rsquo;ll notice that almost all of the code we wrote is in the compiler. Over in
the runtime, it&rsquo;s just two little instructions. You&rsquo;ll see this as a continuing
<span name="static">trend</span> in clox compared to jlox. One of the biggest
hammers in the optimizer&rsquo;s toolbox is pulling work forward into the compiler so
that you don&rsquo;t have to do it at runtime. In this chapter, that meant resolving
exactly which stack slot every local variable occupies. That way, at runtime, no
lookup or resolution needs to happen.</p>
<aside name="static">
<p>You can look at static types as an extreme example of this trend. A statically
typed language takes all of the type analysis and type error handling and sorts
it all out during compilation. Then the runtime doesn&rsquo;t have to waste any time
checking that values have the proper type for their operation. In fact, in some
statically typed languages like C, you don&rsquo;t even <em>know</em> the type at runtime.
The compiler completely erases any representation of a value&rsquo;s type leaving just
the bare bits.</p>
</aside>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Our simple local array makes it easy to calculate the stack slot of each
local variable. But it means that when the compiler resolves a reference to
a variable, we have to do a linear scan through the array.</p>
<p>Come up with something more efficient. Do you think the additional
complexity is worth it?</p>
</li>
<li>
<p>How do other languages handle code like this:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
</pre></div>
<p>What would you do if it was your language? Why?</p>
</li>
<li>
<p>Many languages make a distinction between variables that can be reassigned
and those that can&rsquo;t. In Java, the <code>final</code> modifier prevents you from
assigning to a variable. In JavaScript, a variable declared with <code>let</code> can
be assigned, but one declared using <code>const</code> can&rsquo;t. Swift treats <code>let</code> as
single-assignment and uses <code>var</code> for assignable variables. Scala and Kotlin
use <code>val</code> and <code>var</code>.</p>
<p>Pick a keyword for a single-assignment variable form to add to Lox. Justify
your choice, then implement it. An attempt to assign to a variable declared
using your new keyword should cause a compile error.</p>
</li>
<li>
<p>Extend clox to allow more than 256 local variables to be in scope at a time.</p>
</li>
</ol>
</div>

<footer>
<a href="jumping-back-and-forth.html" class="next">
  Next Chapter: &ldquo;Jumping Back and Forth&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Jumping Back and Forth &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Jumping Back and Forth<small>23</small></a></h3>

<ul>
    <li><a href="#if-statements"><small>23.1</small> If Statements</a></li>
    <li><a href="#logical-operators"><small>23.2</small> Logical Operators</a></li>
    <li><a href="#while-statements"><small>23.3</small> While Statements</a></li>
    <li><a href="#for-statements"><small>23.4</small> For Statements</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Considering Goto Harmful</a></li>
</ul>


<div class="prev-next">
    <a href="local-variables.html" title="Local Variables" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="calls-and-functions.html" title="Calls and Functions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="local-variables.html" title="Local Variables" class="prev">←</a>
<a href="calls-and-functions.html" title="Calls and Functions" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Jumping Back and Forth<small>23</small></a></h3>

<ul>
    <li><a href="#if-statements"><small>23.1</small> If Statements</a></li>
    <li><a href="#logical-operators"><small>23.2</small> Logical Operators</a></li>
    <li><a href="#while-statements"><small>23.3</small> While Statements</a></li>
    <li><a href="#for-statements"><small>23.4</small> For Statements</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Considering Goto Harmful</a></li>
</ul>


<div class="prev-next">
    <a href="local-variables.html" title="Local Variables" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="calls-and-functions.html" title="Calls and Functions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">23</div>
  <h1>Jumping Back and Forth</h1>

<blockquote>
<p>The order that our mind imagines is like a net, or like a ladder, built to
attain something. But afterward you must throw the ladder away, because you
discover that, even if it was useful, it was meaningless.</p>
<p><cite>Umberto Eco, <em>The Name of the Rose</em></cite></p>
</blockquote>
<p>It&rsquo;s taken a while to get here, but we&rsquo;re finally ready to add control flow to
our virtual machine. In the tree-walk interpreter we built for jlox, we
implemented Lox&rsquo;s control flow in terms of Java&rsquo;s. To execute a Lox <code>if</code>
statement, we used a Java <code>if</code> statement to run the chosen branch. That works,
but isn&rsquo;t entirely satisfying. By what magic does the <em>JVM itself</em> or a native
CPU implement <code>if</code> statements? Now that we have our own bytecode VM to hack on,
we can answer that.</p>
<p>When we talk about &ldquo;control flow&rdquo;, what are we referring to? By &ldquo;flow&rdquo; we mean
the way execution moves through the text of the program. Almost like there is a
little robot inside the computer wandering through our code, executing bits and
pieces here and there. Flow is the path that robot takes, and by <em>controlling</em>
the robot, we drive which pieces of code it executes.</p>
<p>In jlox, the robot&rsquo;s locus of attention<span class="em">&mdash;</span>the <em>current</em> bit of code<span class="em">&mdash;</span>was
implicit based on which AST nodes were stored in various Java variables and what
Java code we were in the middle of running. In clox, it is much more explicit.
The VM&rsquo;s <code>ip</code> field stores the address of the current bytecode instruction. The
value of that field is exactly &ldquo;where we are&rdquo; in the program.</p>
<p>Execution proceeds normally by incrementing the <code>ip</code>. But we can mutate that
variable however we want to. In order to implement control flow, all that&rsquo;s
necessary is to change the <code>ip</code> in more interesting ways. The simplest control
flow construct is an <code>if</code> statement with no <code>else</code> clause:</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">condition</span>) <span class="k">print</span>(<span class="s">&quot;condition was truthy&quot;</span>);
</pre></div>
<p>The VM evaluates the bytecode for the condition expression. If the result is
truthy, then it continues along and executes the <code>print</code> statement in the body.
The interesting case is when the condition is falsey. When that happens,
execution skips over the then branch and proceeds to the next statement.</p>
<p>To skip over a chunk of code, we simply set the <code>ip</code> field to the address of the
bytecode instruction following that code. To <em>conditionally</em> skip over some
code, we need an instruction that looks at the value on top of the stack. If
it&rsquo;s falsey, it adds a given offset to the <code>ip</code> to jump over a range of
instructions. Otherwise, it does nothing and lets execution proceed to the next
instruction as usual.</p>
<p>When we compile to bytecode, the explicit nested block structure of the code
evaporates, leaving only a flat series of instructions behind. Lox is a
<a href="https://en.wikipedia.org/wiki/Structured_programming">structured programming</a> language, but clox bytecode isn&rsquo;t. The right<span class="em">&mdash;</span>or
wrong, depending on how you look at it<span class="em">&mdash;</span>set of bytecode instructions could
jump into the middle of a block, or from one scope into another.</p>
<p>The VM will happily execute that, even if the result leaves the stack in an
unknown, inconsistent state. So even though the bytecode is unstructured, we&rsquo;ll
take care to ensure that our compiler only generates clean code that maintains
the same structure and nesting that Lox itself does.</p>
<p>This is exactly how real CPUs behave. Even though we might program them using
higher-level languages that mandate structured control flow, the compiler lowers
that down to raw jumps. At the bottom, it turns out goto is the only real
control flow.</p>
<p>Anyway, I didn&rsquo;t mean to get all philosophical. The important bit is that if we
have that one conditional jump instruction, that&rsquo;s enough to implement Lox&rsquo;s
<code>if</code> statement, as long as it doesn&rsquo;t have an <code>else</code> clause. So let&rsquo;s go ahead
and get started with that.</p>
<h2><a href="#if-statements" id="if-statements"><small>23&#8202;.&#8202;1</small>If Statements</a></h2>
<p>This many chapters in, you know the drill. Any new feature starts in the front
end and works its way through the pipeline. An <code>if</code> statement is, well, a
statement, so that&rsquo;s where we hook it into the parser.</p>
<div class="codehilite"><pre class="insert-before">  if (match(TOKEN_PRINT)) {
    printStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_IF</span>)) {
    <span class="i">ifStatement</span>();
</pre><pre class="insert-after">  } else if (match(TOKEN_LEFT_BRACE)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>When we see an <code>if</code> keyword, we hand off compilation to this function:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expressionStatement</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">ifStatement</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;if&#39;.&quot;</span>);
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after condition.&quot;</span>);<span name="paren"> </span>

  <span class="t">int</span> <span class="i">thenJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
  <span class="i">statement</span>();

  <span class="i">patchJump</span>(<span class="i">thenJump</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expressionStatement</em>()</div>

<aside name="paren">
<p>Have you ever noticed that the <code>(</code> after the <code>if</code> keyword doesn&rsquo;t actually do
anything useful? The language would be just as unambiguous and easy to parse
without it, like:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="i">condition</span>) <span class="k">print</span>(<span class="s">&quot;looks weird&quot;</span>);
</pre></div>
<p>The closing <code>)</code> is useful because it separates the condition expression from the
body. Some languages use a <code>then</code> keyword instead. But the opening <code>(</code> doesn&rsquo;t
do anything. It&rsquo;s just there because unmatched parentheses look bad to us
humans.</p>
</aside>
<p>First we compile the condition expression, bracketed by parentheses. At runtime,
that will leave the condition value on top of the stack. We&rsquo;ll use that to
determine whether to execute the then branch or skip it.</p>
<p>Then we emit a new <code>OP_JUMP_IF_FALSE</code> instruction. It has an operand for how
much to offset the <code>ip</code><span class="em">&mdash;</span>how many bytes of code to skip. If the condition is
falsey, it adjusts the <code>ip</code> by that amount. Something like this:</p>
<aside name="legend">
<p>The boxes with the torn edges here represent the blob of bytecode generated by
compiling some sub-clause of a control flow construct. So the &ldquo;condition
expression&rdquo; box is all of the instructions emitted when we compiled that
expression.</p>
</aside>
<p><span name="legend"></span></p><img src="image/jumping-back-and-forth/if-without-else.png" alt="Flowchart of the compiled bytecode of an if statement." />
<p>But we have a problem. When we&rsquo;re writing the <code>OP_JUMP_IF_FALSE</code> instruction&rsquo;s
operand, how do we know how far to jump? We haven&rsquo;t compiled the then branch
yet, so we don&rsquo;t know how much bytecode it contains.</p>
<p>To fix that, we use a classic trick called <strong>backpatching</strong>. We emit the jump
instruction first with a placeholder offset operand. We keep track of where that
half-finished instruction is. Next, we compile the then body. Once that&rsquo;s done,
we know how far to jump. So we go back and replace that placeholder offset with
the real one now that we can calculate it. Sort of like sewing a patch onto the
existing fabric of the compiled code.</p><img src="image/jumping-back-and-forth/patch.png" alt="A patch containing a number being sewn onto a sheet of bytecode." />
<p>We encode this trick into two helper functions.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitBytes</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">emitJump</span>(<span class="t">uint8_t</span> <span class="i">instruction</span>) {
  <span class="i">emitByte</span>(<span class="i">instruction</span>);
  <span class="i">emitByte</span>(<span class="n">0xff</span>);
  <span class="i">emitByte</span>(<span class="n">0xff</span>);
  <span class="k">return</span> <span class="i">currentChunk</span>()-&gt;<span class="i">count</span> - <span class="n">2</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitBytes</em>()</div>

<p>The first emits a bytecode instruction and writes a placeholder operand for the
jump offset. We pass in the opcode as an argument because later we&rsquo;ll have two
different instructions that use this helper. We use two bytes for the jump
offset operand. A 16-bit <span name="offset">offset</span> lets us jump over up
to 65,535 bytes of code, which should be plenty for our needs.</p>
<aside name="offset">
<p>Some instruction sets have separate &ldquo;long&rdquo; jump instructions that take larger
operands for when you need to jump a greater distance.</p>
</aside>
<p>The function returns the offset of the emitted instruction in the chunk. After
compiling the then branch, we take that offset and pass it to this:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">patchJump</span>(<span class="t">int</span> <span class="i">offset</span>) {
  <span class="c">// -2 to adjust for the bytecode for the jump offset itself.</span>
  <span class="t">int</span> <span class="i">jump</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span> - <span class="i">offset</span> - <span class="n">2</span>;

  <span class="k">if</span> (<span class="i">jump</span> &gt; <span class="a">UINT16_MAX</span>) {
    <span class="i">error</span>(<span class="s">&quot;Too much code to jump over.&quot;</span>);
  }

  <span class="i">currentChunk</span>()-&gt;<span class="i">code</span>[<span class="i">offset</span>] = (<span class="i">jump</span> &gt;&gt; <span class="n">8</span>) &amp; <span class="n">0xff</span>;
  <span class="i">currentChunk</span>()-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>] = <span class="i">jump</span> &amp; <span class="n">0xff</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitConstant</em>()</div>

<p>This goes back into the bytecode and replaces the operand at the given location
with the calculated jump offset. We call <code>patchJump()</code> right before we emit the
next instruction that we want the jump to land on, so it uses the current
bytecode count to determine how far to jump. In the case of an <code>if</code> statement,
that means right after we compile the then branch and before we compile the next
statement.</p>
<p>That&rsquo;s all we need at compile time. Let&rsquo;s define the new instruction.</p>
<div class="codehilite"><pre class="insert-before">  OP_PRINT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_JUMP_IF_FALSE</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Over in the VM, we get it working like so:</p>
<div class="codehilite"><pre class="insert-before">        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_JUMP_IF_FALSE</span>: {
        <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
        <span class="k">if</span> (<span class="i">isFalsey</span>(<span class="i">peek</span>(<span class="n">0</span>))) <span class="i">vm</span>.<span class="i">ip</span> += <span class="i">offset</span>;
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>This is the first instruction we&rsquo;ve added that takes a 16-bit operand. To read
that from the chunk, we use a new macro.</p>
<div class="codehilite"><pre class="insert-before">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#define READ_SHORT() \</span>
<span class="a">    (vm.ip += 2, (uint16_t)((vm.ip[-2] &lt;&lt; 8) | vm.ip[-1]))</span>
</pre><pre class="insert-after">#define READ_STRING() AS_STRING(READ_CONSTANT())
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>It yanks the next two bytes from the chunk and builds a 16-bit unsigned integer
out of them. As usual, we clean up our macro when we&rsquo;re done with it.</p>
<div class="codehilite"><pre class="insert-before">#undef READ_BYTE
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#undef READ_SHORT</span>
</pre><pre class="insert-after">#undef READ_CONSTANT
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>After reading the offset, we check the condition value on top of the stack.
<span name="if">If</span> it&rsquo;s falsey, we apply this jump offset to the <code>ip</code>.
Otherwise, we leave the <code>ip</code> alone and execution will automatically proceed to
the next instruction following the jump instruction.</p>
<p>In the case where the condition is falsey, we don&rsquo;t need to do any other work.
We&rsquo;ve offset the <code>ip</code>, so when the outer instruction dispatch loop turns again,
it will pick up execution at that new instruction, past all of the code in the
then branch.</p>
<aside name="if">
<p>I said we wouldn&rsquo;t use C&rsquo;s <code>if</code> statement to implement Lox&rsquo;s control flow, but
we do use one here to determine whether or not to offset the instruction
pointer. But we aren&rsquo;t really using C for <em>control flow</em>. If we wanted to, we
could do the same thing purely arithmetically. Let&rsquo;s assume we have a function
<code>falsey()</code> that takes a Lox Value and returns 1 if it&rsquo;s falsey or 0 otherwise.
Then we could implement the jump instruction like:</p>
<div class="codehilite"><pre><span class="k">case</span> <span class="a">OP_JUMP_IF_FALSE</span>: {
  <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
  <span class="i">vm</span>.<span class="i">ip</span> += <span class="i">falsey</span>() * <span class="i">offset</span>;
  <span class="k">break</span>;
}
</pre></div>
<p>The <code>falsey()</code> function would probably use some control flow to handle the
different value types, but that&rsquo;s an implementation detail of that function and
doesn&rsquo;t affect how our VM does its own control flow.</p>
</aside>
<p>Note that the jump instruction doesn&rsquo;t pop the condition value off the stack. So
we aren&rsquo;t totally done here, since this leaves an extra value floating around on
the stack. We&rsquo;ll clean that up soon. Ignoring that for the moment, we do have a
working <code>if</code> statement in Lox now, with only one little instruction required to
support it at runtime in the VM.</p>
<h3><a href="#else-clauses" id="else-clauses"><small>23&#8202;.&#8202;1&#8202;.&#8202;1</small>Else clauses</a></h3>
<p>An <code>if</code> statement without support for <code>else</code> clauses is like Morticia Addams
without Gomez. So, after we compile the then branch, we look for an <code>else</code>
keyword. If we find one, we compile the else branch.</p>
<div class="codehilite"><pre class="insert-before">  patchJump(thenJump);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>ifStatement</em>()</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_ELSE</span>)) <span class="i">statement</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>

<p>When the condition is falsey, we&rsquo;ll jump over the then branch. If there&rsquo;s an
else branch, the <code>ip</code> will land right at the beginning of its code. But that&rsquo;s
not enough, though. Here&rsquo;s the flow that leads to:</p><img src="image/jumping-back-and-forth/bad-else.png" alt="Flowchart of the compiled bytecode with the then branch incorrectly falling through to the else branch." />
<p>If the condition is truthy, we execute the then branch like we want. But after
that, execution rolls right on through into the else branch. Oops! When the
condition is true, after we run the then branch, we need to jump over the else
branch. That way, in either case, we only execute a single branch, like this:</p><img src="image/jumping-back-and-forth/if-else.png" alt="Flowchart of the compiled bytecode for an if with an else clause." />
<p>To implement that, we need another jump from the end of the then branch.</p>
<div class="codehilite"><pre class="insert-before">  statement();

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>ifStatement</em>()</div>
<pre class="insert">  <span class="t">int</span> <span class="i">elseJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP</span>);

</pre><pre class="insert-after">  patchJump(thenJump);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>

<p>We patch that offset after the end of the else body.</p>
<div class="codehilite"><pre class="insert-before">  if (match(TOKEN_ELSE)) statement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>ifStatement</em>()</div>
<pre class="insert">  <span class="i">patchJump</span>(<span class="i">elseJump</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>

<p>After executing the then branch, this jumps to the next statement after the else
branch. Unlike the other jump, this jump is unconditional. We always take it, so
we need another instruction that expresses that.</p>
<div class="codehilite"><pre class="insert-before">  OP_PRINT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_JUMP</span>,
</pre><pre class="insert-after">  OP_JUMP_IF_FALSE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>We interpret it like so:</p>
<div class="codehilite"><pre class="insert-before">        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_JUMP</span>: {
        <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
        <span class="i">vm</span>.<span class="i">ip</span> += <span class="i">offset</span>;
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_JUMP_IF_FALSE: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nothing too surprising here<span class="em">&mdash;</span>the only difference is that it doesn&rsquo;t check a
condition and always applies the offset.</p>
<p>We have then and else branches working now, so we&rsquo;re close. The last bit is to
clean up that condition value we left on the stack. Remember, each statement is
required to have zero stack effect<span class="em">&mdash;</span>after the statement is finished executing,
the stack should be as tall as it was before.</p>
<p>We could have the <code>OP_JUMP_IF_FALSE</code> instruction pop the condition itself, but
soon we&rsquo;ll use that same instruction for the logical operators where we don&rsquo;t
want the condition popped. Instead, we&rsquo;ll have the compiler emit a couple of
explicit <code>OP_POP</code> instructions when compiling an <code>if</code> statement. We need to take
care that every execution path through the generated code pops the condition.</p>
<p>When the condition is truthy, we pop it right before the code inside the then
branch.</p>
<div class="codehilite"><pre class="insert-before">  int thenJump = emitJump(OP_JUMP_IF_FALSE);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>ifStatement</em>()</div>
<pre class="insert">  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
</pre><pre class="insert-after">  statement();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>

<p>Otherwise, we pop it at the beginning of the else branch.</p>
<div class="codehilite"><pre class="insert-before">  patchJump(thenJump);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>ifStatement</em>()</div>
<pre class="insert">  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
</pre><pre class="insert-after">

  if (match(TOKEN_ELSE)) statement();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>

<p>This little instruction here also means that every <code>if</code> statement has an
implicit else branch even if the user didn&rsquo;t write an <code>else</code> clause. In the case
where they left it off, all the branch does is discard the condition value.</p>
<p>The full correct flow looks like this:</p><img src="image/jumping-back-and-forth/full-if-else.png" alt="Flowchart of the compiled bytecode including necessary pop instructions." />
<p>If you trace through, you can see that it always executes a single branch and
ensures the condition is popped first. All that remains is a little disassembler
support.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_PRINT&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_JUMP</span>:
      <span class="k">return</span> <span class="i">jumpInstruction</span>(<span class="s">&quot;OP_JUMP&quot;</span>, <span class="n">1</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_JUMP_IF_FALSE</span>:
      <span class="k">return</span> <span class="i">jumpInstruction</span>(<span class="s">&quot;OP_JUMP_IF_FALSE&quot;</span>, <span class="n">1</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>These two instructions have a new format with a 16-bit operand, so we add a new
utility function to disassemble them.</p>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
add after <em>byteInstruction</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">jumpInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">int</span> <span class="i">sign</span>,
                           <span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint16_t</span> <span class="i">jump</span> = (<span class="t">uint16_t</span>)(<span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>] &lt;&lt; <span class="n">8</span>);
  <span class="i">jump</span> |= <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">2</span>];
  <span class="i">printf</span>(<span class="s">&quot;%-16s %4d -&gt; %d</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">name</span>, <span class="i">offset</span>,
         <span class="i">offset</span> + <span class="n">3</span> + <span class="i">sign</span> * <span class="i">jump</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">3</span>;
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>byteInstruction</em>()</div>

<p>There we go, that&rsquo;s one complete control flow construct. If this were an &rsquo;80s
movie, the montage music would kick in and the rest of the control flow syntax
would take care of itself. Alas, the <span name="80s">&rsquo;80s</span> are long over,
so we&rsquo;ll have to grind it out ourselves.</p>
<aside name="80s">
<p>My enduring love of Depeche Mode notwithstanding.</p>
</aside>
<h2><a href="#logical-operators" id="logical-operators"><small>23&#8202;.&#8202;2</small>Logical Operators</a></h2>
<p>You probably remember this from jlox, but the logical operators <code>and</code> and <code>or</code>
aren&rsquo;t just another pair of binary operators like <code>+</code> and <code>-</code>. Because they
short-circuit and may not evaluate their right operand depending on the value of
the left one, they work more like control flow expressions.</p>
<p>They&rsquo;re basically a little variation on an <code>if</code> statement with an <code>else</code> clause.
The easiest way to explain them is to just show you the compiler code and the
control flow it produces in the resulting bytecode. Starting with <code>and</code>, we hook
it into the expression parsing table here:</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_NUMBER]        = {number,   NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_AND</span>]           = {<span class="a">NULL</span>,     <span class="i">and_</span>,   <span class="a">PREC_AND</span>},
</pre><pre class="insert-after">  [TOKEN_CLASS]         = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>That hands off to a new parser function.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>defineVariable</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">and_</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="t">int</span> <span class="i">endJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);

  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
  <span class="i">parsePrecedence</span>(<span class="a">PREC_AND</span>);

  <span class="i">patchJump</span>(<span class="i">endJump</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>defineVariable</em>()</div>

<p>At the point this is called, the left-hand side expression has already been
compiled. That means at runtime, its value will be on top of the stack. If that
value is falsey, then we know the entire <code>and</code> must be false, so we skip the
right operand and leave the left-hand side value as the result of the entire
expression. Otherwise, we discard the left-hand value and evaluate the right
operand which becomes the result of the whole <code>and</code> expression.</p>
<p>Those four lines of code right there produce exactly that. The flow looks like
this:</p><img src="image/jumping-back-and-forth/and.png" alt="Flowchart of the compiled bytecode of an 'and' expression." />
<p>Now you can see why <code>OP_JUMP_IF_FALSE</code> <span name="instr">leaves</span> the
value on top of the stack. When the left-hand side of the <code>and</code> is falsey, that
value sticks around to become the result of the entire expression.</p>
<aside name="instr">
<p>We&rsquo;ve got plenty of space left in our opcode range, so we could have separate
instructions for conditional jumps that implicitly pop and those that don&rsquo;t, I
suppose. But I&rsquo;m trying to keep things minimal for the book. In your bytecode
VM, it&rsquo;s worth exploring adding more specialized instructions and seeing how
they affect performance.</p>
</aside>
<h3><a href="#logical-or-operator" id="logical-or-operator"><small>23&#8202;.&#8202;2&#8202;.&#8202;1</small>Logical or operator</a></h3>
<p>The <code>or</code> operator is a little more complex. First we add it to the parse table.</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_NIL]           = {literal,  NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_OR</span>]            = {<span class="a">NULL</span>,     <span class="i">or_</span>,    <span class="a">PREC_OR</span>},
</pre><pre class="insert-after">  [TOKEN_PRINT]         = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>When that parser consumes an infix <code>or</code> token, it calls this:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>number</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">or_</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="t">int</span> <span class="i">elseJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
  <span class="t">int</span> <span class="i">endJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP</span>);

  <span class="i">patchJump</span>(<span class="i">elseJump</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);

  <span class="i">parsePrecedence</span>(<span class="a">PREC_OR</span>);
  <span class="i">patchJump</span>(<span class="i">endJump</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>number</em>()</div>

<p>In an <code>or</code> expression, if the left-hand side is <em>truthy</em>, then we skip over the
right operand. Thus we need to jump when a value is truthy. We could add a
separate instruction, but just to show how our compiler is free to map the
language&rsquo;s semantics to whatever instruction sequence it wants, I implemented it
in terms of the jump instructions we already have.</p>
<p>When the left-hand side is falsey, it does a tiny jump over the next statement.
That statement is an unconditional jump over the code for the right operand.
This little dance effectively does a jump when the value is truthy. The flow
looks like this:</p><img src="image/jumping-back-and-forth/or.png" alt="Flowchart of the compiled bytecode of a logical or expression." />
<p>If I&rsquo;m honest with you, this isn&rsquo;t the best way to do this. There are more
instructions to dispatch and more overhead. There&rsquo;s no good reason why <code>or</code>
should be slower than <code>and</code>. But it is kind of fun to see that it&rsquo;s possible to
implement both operators without adding any new instructions. Forgive me my
indulgences.</p>
<p>OK, those are the three <em>branching</em> constructs in Lox. By that, I mean, these
are the control flow features that only jump <em>forward</em> over code. Other
languages often have some kind of multi-way branching statement like <code>switch</code>
and maybe a conditional expression like <code>?:</code>, but Lox keeps it simple.</p>
<h2><a href="#while-statements" id="while-statements"><small>23&#8202;.&#8202;3</small>While Statements</a></h2>
<p>That takes us to the <em>looping</em> statements, which jump <em>backward</em> so that code
can be executed more than once. Lox only has two loop constructs, <code>while</code> and
<code>for</code>. A <code>while</code> loop is (much) simpler, so we start the party there.</p>
<div class="codehilite"><pre class="insert-before">    ifStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_WHILE</span>)) {
    <span class="i">whileStatement</span>();
</pre><pre class="insert-after">  } else if (match(TOKEN_LEFT_BRACE)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>When we reach a <code>while</code> token, we call:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>printStatement</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">whileStatement</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;while&#39;.&quot;</span>);
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after condition.&quot;</span>);

  <span class="t">int</span> <span class="i">exitJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
  <span class="i">statement</span>();

  <span class="i">patchJump</span>(<span class="i">exitJump</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>printStatement</em>()</div>

<p>Most of this mirrors <code>if</code> statements<span class="em">&mdash;</span>we compile the condition expression,
surrounded by mandatory parentheses. That&rsquo;s followed by a jump instruction that
skips over the subsequent body statement if the condition is falsey.</p>
<p>We patch the jump after compiling the body and take care to <span
name="pop">pop</span> the condition value from the stack on either path. The
only difference from an <code>if</code> statement is the loop. That looks like this:</p>
<aside name="pop">
<p>Really starting to second-guess my decision to use the same jump instructions
for the logical operators.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  statement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>whileStatement</em>()</div>
<pre class="insert">  <span class="i">emitLoop</span>(<span class="i">loopStart</span>);
</pre><pre class="insert-after">

  patchJump(exitJump);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>whileStatement</em>()</div>

<p>After the body, we call this function to emit a &ldquo;loop&rdquo; instruction. That
instruction needs to know how far back to jump. When jumping forward, we had to
emit the instruction in two stages since we didn&rsquo;t know how far we were going to
jump until after we emitted the jump instruction. We don&rsquo;t have that problem
now. We&rsquo;ve already compiled the point in code that we want to jump back to<span class="em">&mdash;</span>it&rsquo;s right before the condition expression.</p>
<p>All we need to do is capture that location as we compile it.</p>
<div class="codehilite"><pre class="insert-before">static void whileStatement() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>whileStatement</em>()</div>
<pre class="insert">  <span class="t">int</span> <span class="i">loopStart</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span>;
</pre><pre class="insert-after">  consume(TOKEN_LEFT_PAREN, &quot;Expect '(' after 'while'.&quot;);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>whileStatement</em>()</div>

<p>After executing the body of a <code>while</code> loop, we jump all the way back to before
the condition. That way, we re-evaluate the condition expression on each
iteration. We store the chunk&rsquo;s current instruction count in <code>loopStart</code> to
record the offset in the bytecode right before the condition expression we&rsquo;re
about to compile. Then we pass that into this helper function:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitBytes</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">emitLoop</span>(<span class="t">int</span> <span class="i">loopStart</span>) {
  <span class="i">emitByte</span>(<span class="a">OP_LOOP</span>);

  <span class="t">int</span> <span class="i">offset</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span> - <span class="i">loopStart</span> + <span class="n">2</span>;
  <span class="k">if</span> (<span class="i">offset</span> &gt; <span class="a">UINT16_MAX</span>) <span class="i">error</span>(<span class="s">&quot;Loop body too large.&quot;</span>);

  <span class="i">emitByte</span>((<span class="i">offset</span> &gt;&gt; <span class="n">8</span>) &amp; <span class="n">0xff</span>);
  <span class="i">emitByte</span>(<span class="i">offset</span> &amp; <span class="n">0xff</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitBytes</em>()</div>

<p>It&rsquo;s a bit like <code>emitJump()</code> and <code>patchJump()</code> combined. It emits a new loop
instruction, which unconditionally jumps <em>backwards</em> by a given offset. Like the
jump instructions, after that we have a 16-bit operand. We calculate the offset
from the instruction we&rsquo;re currently at to the <code>loopStart</code> point that we want to
jump back to. The <code>+ 2</code> is to take into account the size of the <code>OP_LOOP</code>
instruction&rsquo;s own operands which we also need to jump over.</p>
<p>From the VM&rsquo;s perspective, there really is no semantic difference between
<code>OP_LOOP</code> and <code>OP_JUMP</code>. Both just add an offset to the <code>ip</code>. We could have used
a single instruction for both and given it a signed offset operand. But I
figured it was a little easier to sidestep the annoying bit twiddling required
to manually pack a signed 16-bit integer into two bytes, and we&rsquo;ve got the
opcode space available, so why not use it?</p>
<p>The new instruction is here:</p>
<div class="codehilite"><pre class="insert-before">  OP_JUMP_IF_FALSE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_LOOP</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>And in the VM, we implement it thusly:</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_LOOP</span>: {
        <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
        <span class="i">vm</span>.<span class="i">ip</span> -= <span class="i">offset</span>;
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>The only difference from <code>OP_JUMP</code> is a subtraction instead of an addition.
Disassembly is similar too.</p>
<div class="codehilite"><pre class="insert-before">      return jumpInstruction(&quot;OP_JUMP_IF_FALSE&quot;, 1, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_LOOP</span>:
      <span class="k">return</span> <span class="i">jumpInstruction</span>(<span class="s">&quot;OP_LOOP&quot;</span>, -<span class="n">1</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>That&rsquo;s our <code>while</code> statement. It contains two jumps<span class="em">&mdash;</span>a conditional forward one
to escape the loop when the condition is not met, and an unconditional loop
backward after we have executed the body. The flow looks like this:</p><img src="image/jumping-back-and-forth/while.png" alt="Flowchart of the compiled bytecode of a while statement." />
<h2><a href="#for-statements" id="for-statements"><small>23&#8202;.&#8202;4</small>For Statements</a></h2>
<p>The other looping statement in Lox is the venerable <code>for</code> loop, inherited from
C. It&rsquo;s got a lot more going on with it compared to a <code>while</code> loop. It has three
clauses, all of which are optional:</p>
<p><span name="detail"></span></p>
<ul>
<li>
<p>The initializer can be a variable declaration or an expression. It runs once
at the beginning of the statement.</p>
</li>
<li>
<p>The condition clause is an expression. Like in a <code>while</code> loop, we exit the
loop when it evaluates to something falsey.</p>
</li>
<li>
<p>The increment expression runs once at the end of each loop iteration.</p>
</li>
</ul>
<aside name="detail">
<p>If you want a refresher, the corresponding chapter in part II goes through the
semantics <a href="control-flow.html#for-loops">in more detail</a>.</p>
</aside>
<p>In jlox, the parser desugared a <code>for</code> loop to a synthesized AST for a <code>while</code>
loop with some extra stuff before it and at the end of the body. We&rsquo;ll do
something similar, though we won&rsquo;t go through anything like an AST. Instead,
our bytecode compiler will use the jump and loop instructions we already have.</p>
<p>We&rsquo;ll work our way through the implementation a piece at a time, starting with
the <code>for</code> keyword.</p>
<div class="codehilite"><pre class="insert-before">    printStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_FOR</span>)) {
    <span class="i">forStatement</span>();
</pre><pre class="insert-after">  } else if (match(TOKEN_IF)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>It calls a helper function. If we only supported <code>for</code> loops with empty clauses
like <code>for (;;)</code>, then we could implement it like this:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expressionStatement</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">forStatement</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;for&#39;.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39;.&quot;</span>);

  <span class="t">int</span> <span class="i">loopStart</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span>;
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39;.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after for clauses.&quot;</span>);

  <span class="i">statement</span>();
  <span class="i">emitLoop</span>(<span class="i">loopStart</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expressionStatement</em>()</div>

<p>There&rsquo;s a bunch of mandatory punctuation at the top. Then we compile the body.
Like we did for <code>while</code> loops, we record the bytecode offset at the top of the
body and emit a loop to jump back to that point after it. We&rsquo;ve got a working
implementation of <span name="infinite">infinite</span> loops now.</p>
<aside name="infinite">
<p>Alas, without <code>return</code> statements, there isn&rsquo;t any way to terminate it short of
a runtime error.</p>
</aside>
<h3><a href="#initializer-clause" id="initializer-clause"><small>23&#8202;.&#8202;4&#8202;.&#8202;1</small>Initializer clause</a></h3>
<p>Now we&rsquo;ll add the first clause, the initializer. It executes only once, before
the body, so compiling is straightforward.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_LEFT_PAREN, &quot;Expect '(' after 'for'.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_SEMICOLON</span>)) {
    <span class="c">// No initializer.</span>
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_VAR</span>)) {
    <span class="i">varDeclaration</span>();
  } <span class="k">else</span> {
    <span class="i">expressionStatement</span>();
  }
</pre><pre class="insert-after">

  int loopStart = currentChunk()-&gt;count;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>(), replace 1 line</div>

<p>The syntax is a little complex since we allow either a variable declaration or
an expression. We use the presence of the <code>var</code> keyword to tell which we have.
For the expression case, we call <code>expressionStatement()</code> instead of
<code>expression()</code>. That looks for a semicolon, which we need here too, and also
emits an <code>OP_POP</code> instruction to discard the value. We don&rsquo;t want the
initializer to leave anything on the stack.</p>
<p>If a <code>for</code> statement declares a variable, that variable should be scoped to the
loop body. We ensure that by wrapping the whole statement in a scope.</p>
<div class="codehilite"><pre class="insert-before">static void forStatement() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">  <span class="i">beginScope</span>();
</pre><pre class="insert-after">  consume(TOKEN_LEFT_PAREN, &quot;Expect '(' after 'for'.&quot;);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>()</div>

<p>Then we close it at the end.</p>
<div class="codehilite"><pre class="insert-before">  emitLoop(loopStart);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">  <span class="i">endScope</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>()</div>

<h3><a href="#condition-clause" id="condition-clause"><small>23&#8202;.&#8202;4&#8202;.&#8202;2</small>Condition clause</a></h3>
<p>Next, is the condition expression that can be used to exit the loop.</p>
<div class="codehilite"><pre class="insert-before">  int loopStart = currentChunk()-&gt;count;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">int</span> <span class="i">exitJump</span> = -<span class="n">1</span>;
  <span class="k">if</span> (!<span class="i">match</span>(<span class="a">TOKEN_SEMICOLON</span>)) {
    <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after loop condition.&quot;</span>);

    <span class="c">// Jump out of the loop if the condition is false.</span>
    <span class="i">exitJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>); <span class="c">// Condition.</span>
  }

</pre><pre class="insert-after">  consume(TOKEN_RIGHT_PAREN, &quot;Expect ')' after for clauses.&quot;);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>(), replace 1 line</div>

<p>Since the clause is optional, we need to see if it&rsquo;s actually present. If the
clause is omitted, the next token must be a semicolon, so we look for that to
tell. If there isn&rsquo;t a semicolon, there must be a condition expression.</p>
<p>In that case, we compile it. Then, just like with while, we emit a conditional
jump that exits the loop if the condition is falsey. Since the jump leaves the
value on the stack, we pop it before executing the body. That ensures we discard
the value when the condition is true.</p>
<p>After the loop body, we need to patch that jump.</p>
<div class="codehilite"><pre class="insert-before">  emitLoop(loopStart);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">exitJump</span> != -<span class="n">1</span>) {
    <span class="i">patchJump</span>(<span class="i">exitJump</span>);
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>); <span class="c">// Condition.</span>
  }

</pre><pre class="insert-after">  endScope();
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>()</div>

<p>We do this only when there is a condition clause. If there isn&rsquo;t, there&rsquo;s no
jump to patch and no condition value on the stack to pop.</p>
<h3><a href="#increment-clause" id="increment-clause"><small>23&#8202;.&#8202;4&#8202;.&#8202;3</small>Increment clause</a></h3>
<p>I&rsquo;ve saved the best for last, the increment clause. It&rsquo;s pretty convoluted. It
appears textually before the body, but executes <em>after</em> it. If we parsed to an
AST and generated code in a separate pass, we could simply traverse into and
compile the <code>for</code> statement AST&rsquo;s body field before its increment clause.</p>
<p>Unfortunately, we can&rsquo;t compile the increment clause later, since our compiler
only makes a single pass over the code. Instead, we&rsquo;ll <em>jump over</em> the
increment, run the body, jump <em>back</em> up to the increment, run it, and then go to
the next iteration.</p>
<p>I know, a little weird, but hey, it beats manually managing ASTs in memory in C,
right? Here&rsquo;s the code:</p>
<div class="codehilite"><pre class="insert-before">  }

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (!<span class="i">match</span>(<span class="a">TOKEN_RIGHT_PAREN</span>)) {
    <span class="t">int</span> <span class="i">bodyJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP</span>);
    <span class="t">int</span> <span class="i">incrementStart</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span>;
    <span class="i">expression</span>();
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
    <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after for clauses.&quot;</span>);

    <span class="i">emitLoop</span>(<span class="i">loopStart</span>);
    <span class="i">loopStart</span> = <span class="i">incrementStart</span>;
    <span class="i">patchJump</span>(<span class="i">bodyJump</span>);
  }
</pre><pre class="insert-after">

  statement();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>(), replace 1 line</div>

<p>Again, it&rsquo;s optional. Since this is the last clause, when omitted, the next
token will be the closing parenthesis. When an increment is present, we need to
compile it now, but it shouldn&rsquo;t execute yet. So, first, we emit an
unconditional jump that hops over the increment clause&rsquo;s code to the body of the
loop.</p>
<p>Next, we compile the increment expression itself. This is usually an assignment.
Whatever it is, we only execute it for its side effect, so we also emit a pop to
discard its value.</p>
<p>The last part is a little tricky. First, we emit a loop instruction. This is the
main loop that takes us back to the top of the <code>for</code> loop<span class="em">&mdash;</span>right before the
condition expression if there is one. That loop happens right after the
increment, since the increment executes at the end of each loop iteration.</p>
<p>Then we change <code>loopStart</code> to point to the offset where the increment expression
begins. Later, when we emit the loop instruction after the body statement, this
will cause it to jump up to the <em>increment</em> expression instead of the top of the
loop like it does when there is no increment. This is how we weave the
increment in to run after the body.</p>
<p>It&rsquo;s convoluted, but it all works out. A complete loop with all the clauses
compiles to a flow like this:</p><img src="image/jumping-back-and-forth/for.png" alt="Flowchart of the compiled bytecode of a for statement." />
<p>As with implementing <code>for</code> loops in jlox, we didn&rsquo;t need to touch the runtime.
It all gets compiled down to primitive control flow operations the VM already
supports. In this chapter, we&rsquo;ve taken a big <span name="leap">leap</span>
forward<span class="em">&mdash;</span>clox is now Turing complete. We&rsquo;ve also covered quite a bit of new
syntax: three statements and two expression forms. Even so, it only took three
new simple instructions. That&rsquo;s a pretty good effort-to-reward ratio for the
architecture of our VM.</p>
<aside name="leap">
<p>I couldn&rsquo;t resist the pun. I regret nothing.</p>
</aside>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>In addition to <code>if</code> statements, most C-family languages have a multi-way
<code>switch</code> statement. Add one to clox. The grammar is:</p>
<div class="codehilite"><pre><span class="i">switchStmt</span>     → <span class="s">&quot;switch&quot;</span> <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span>
                 <span class="s">&quot;{&quot;</span> <span class="i">switchCase</span>* <span class="i">defaultCase</span>? <span class="s">&quot;}&quot;</span> ;
<span class="i">switchCase</span>     → <span class="s">&quot;case&quot;</span> <span class="i">expression</span> <span class="s">&quot;:&quot;</span> <span class="i">statement</span>* ;
<span class="i">defaultCase</span>    → <span class="s">&quot;default&quot;</span> <span class="s">&quot;:&quot;</span> <span class="i">statement</span>* ;
</pre></div>
<p>To execute a <code>switch</code> statement, first evaluate the parenthesized switch
value expression. Then walk the cases. For each case, evaluate its value
expression. If the case value is equal to the switch value, execute the
statements under the case and then exit the <code>switch</code> statement. Otherwise,
try the next case. If no case matches and there is a <code>default</code> clause,
execute its statements.</p>
<p>To keep things simpler, we&rsquo;re omitting fallthrough and <code>break</code> statements.
Each case automatically jumps to the end of the switch statement after its
statements are done.</p>
</li>
<li>
<p>In jlox, we had a challenge to add support for <code>break</code> statements. This
time, let&rsquo;s do <code>continue</code>:</p>
<div class="codehilite"><pre><span class="i">continueStmt</span>   → <span class="s">&quot;continue&quot;</span> <span class="s">&quot;;&quot;</span> ;
</pre></div>
<p>A <code>continue</code> statement jumps directly to the top of the nearest enclosing
loop, skipping the rest of the loop body. Inside a <code>for</code> loop, a <code>continue</code>
jumps to the increment clause, if there is one. It&rsquo;s a compile-time error to
have a <code>continue</code> statement not enclosed in a loop.</p>
<p>Make sure to think about scope. What should happen to local variables
declared inside the body of the loop or in blocks nested inside the loop
when a <code>continue</code> is executed?</p>
</li>
<li>
<p>Control flow constructs have been mostly unchanged since Algol 68. Language
evolution since then has focused on making code more declarative and high
level, so imperative control flow hasn&rsquo;t gotten much attention.</p>
<p>For fun, try to invent a useful novel control flow feature for Lox. It can
be a refinement of an existing form or something entirely new. In practice,
it&rsquo;s hard to come up with something useful enough at this low expressiveness
level to outweigh the cost of forcing a user to learn an unfamiliar notation
and behavior, but it&rsquo;s a good chance to practice your design skills.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: Considering Goto Harmful</a></h2>
<p>Discovering that all of our beautiful structured control flow in Lox is actually
compiled to raw unstructured jumps is like the moment in Scooby Doo when the
monster rips the mask off their face. It was goto all along! Except in this
case, the monster is <em>under</em> the mask. We all know goto is evil. But<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>why?</p>
<p>It is true that you can write outrageously unmaintainable code using goto. But I
don&rsquo;t think most programmers around today have seen that first hand. It&rsquo;s been a
long time since that style was common. These days, it&rsquo;s a boogie man we invoke
in scary stories around the campfire.</p>
<p>The reason we rarely confront that monster in person is because Edsger Dijkstra
slayed it with his famous letter &ldquo;Go To Statement Considered Harmful&rdquo;, published
in <em>Communications of the ACM</em> (March, 1968). Debate around structured
programming had been fierce for some time with adherents on both sides, but I
think Dijkstra deserves the most credit for effectively ending it. Most new
languages today have no unstructured jump statements.</p>
<p>A one-and-a-half page letter that almost single-handedly destroyed a language
feature must be pretty impressive stuff. If you haven&rsquo;t read it, I encourage you
to do so. It&rsquo;s a seminal piece of computer science lore, one of our tribe&rsquo;s
ancestral songs. Also, it&rsquo;s a nice, short bit of practice for reading academic
CS <span name="style">writing</span>, which is a useful skill to develop.</p>
<aside name="style">
<p>That is, if you can get past Dijkstra&rsquo;s insufferable faux-modest
self-aggrandizing writing style:</p>
<blockquote>
<p>More recently I discovered why the use of the go to statement has such
disastrous effects. <span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>At that time I did not attach too much importance to
this discovery; I now submit my considerations for publication because in very
recent discussions in which the subject turned up, I have been urged to do so.</p>
</blockquote>
<p>Ah, yet another one of my many discoveries. I couldn&rsquo;t even be bothered to write
it up until the clamoring masses begged me to.</p>
</aside>
<p>I&rsquo;ve read it through a number of times, along with a few critiques, responses,
and commentaries. I ended up with mixed feelings, at best. At a very high level,
I&rsquo;m with him. His general argument is something like this:</p>
<ol>
<li>
<p>As programmers, we write programs<span class="em">&mdash;</span>static text<span class="em">&mdash;</span>but what we care about
is the actual running program<span class="em">&mdash;</span>its dynamic behavior.</p>
</li>
<li>
<p>We&rsquo;re better at reasoning about static things than dynamic things. (He
doesn&rsquo;t provide any evidence to support this claim, but I accept it.)</p>
</li>
<li>
<p>Thus, the more we can make the dynamic execution of the program reflect its
textual structure, the better.</p>
</li>
</ol>
<p>This is a good start. Drawing our attention to the separation between the code
we write and the code as it runs inside the machine is an interesting insight.
Then he tries to define a &ldquo;correspondence&rdquo; between program text and execution.
For someone who spent literally his entire career advocating greater rigor in
programming, his definition is pretty hand-wavey. He says:</p>
<blockquote>
<p>Let us now consider how we can characterize the progress of a process. (You
may think about this question in a very concrete manner: suppose that a
process, considered as a time succession of actions, is stopped after an
arbitrary action, what data do we have to fix in order that we can redo the
process until the very same point?)</p>
</blockquote>
<p>Imagine it like this. You have two computers with the same program running on
the exact same inputs<span class="em">&mdash;</span>so totally deterministic. You pause one of them at an
arbitrary point in its execution. What data would you need to send to the other
computer to be able to stop it exactly as far along as the first one was?</p>
<p>If your program allows only simple statements like assignment, it&rsquo;s easy. You
just need to know the point after the last statement you executed. Basically a
breakpoint, the <code>ip</code> in our VM, or the line number in an error message. Adding
branching control flow like <code>if</code> and <code>switch</code> doesn&rsquo;t add any more to this. Even
if the marker points inside a branch, we can still tell where we are.</p>
<p>Once you add function calls, you need something more. You could have paused the
first computer in the middle of a function, but that function may be called from
multiple places. To pause the second machine at exactly the same point in <em>the
entire program&rsquo;s</em> execution, you need to pause it on the <em>right</em> call to that
function.</p>
<p>So you need to know not just the current statement, but, for function calls that
haven&rsquo;t returned yet, you need to know the locations of the callsites. In other
words, a call stack, though I don&rsquo;t think that term existed when Dijkstra wrote
this. Groovy.</p>
<p>He notes that loops make things harder. If you pause in the middle of a loop
body, you don&rsquo;t know how many iterations have run. So he says you also need to
keep an iteration count. And, since loops can nest, you need a stack of those
(presumably interleaved with the call stack pointers since you can be in loops
in outer calls too).</p>
<p>This is where it gets weird. So we&rsquo;re really building to something now, and you
expect him to explain how goto breaks all of this. Instead, he just says:</p>
<blockquote>
<p>The unbridled use of the go to statement has an immediate consequence that it
becomes terribly hard to find a meaningful set of coordinates in which to
describe the process progress.</p>
</blockquote>
<p>He doesn&rsquo;t prove that this is hard, or say why. He just says it. He does say
that one approach is unsatisfactory:</p>
<blockquote>
<p>With the go to statement one can, of course, still describe the progress
uniquely by a counter counting the number of actions performed since program
start (viz. a kind of normalized clock). The difficulty is that such a
coordinate, although unique, is utterly unhelpful.</p>
</blockquote>
<p>But<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>that&rsquo;s effectively what loop counters do, and he was fine with those.
It&rsquo;s not like every loop is a simple &ldquo;for every integer from 0 to 10&rdquo;
incrementing count. Many are <code>while</code> loops with complex conditionals.</p>
<p>Taking an example close to home, consider the core bytecode execution loop at
the heart of clox. Dijkstra argues that that loop is tractable because we can
simply count how many times the loop has run to reason about its progress. But
that loop runs once for each executed instruction in some user&rsquo;s compiled Lox
program. Does knowing that it executed 6,201 bytecode instructions really tell
us VM maintainers <em>anything</em> edifying about the state of the interpreter?</p>
<p>In fact, this particular example points to a deeper truth. Böhm and Jacopini
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">proved</a> that <em>any</em> control flow using goto can be transformed into one using
just sequencing, loops, and branches. Our bytecode interpreter loop is a living
example of that proof: it implements the unstructured control flow of the clox
bytecode instruction set without using any gotos itself.</p>
<p>That seems to offer a counter-argument to Dijkstra&rsquo;s claim: you <em>can</em> define a
correspondence for a program using gotos by transforming it to one that doesn&rsquo;t
and then use the correspondence from that program, which<span class="em">&mdash;</span>according to him<span class="em">&mdash;</span>is acceptable because it uses only branches and loops.</p>
<p>But, honestly, my argument here is also weak. I think both of us are basically
doing pretend math and using fake logic to make what should be an empirical,
human-centered argument. Dijkstra is right that some code using goto is really
bad. Much of that could and should be turned into clearer code by using
structured control flow.</p>
<p>By eliminating goto completely from languages, you&rsquo;re definitely prevented from
writing bad code using gotos. It may be that forcing users to use structured
control flow and making it an uphill battle to write goto-like code using those
constructs is a net win for all of our productivity.</p>
<p>But I do wonder sometimes if we threw out the baby with the bathwater. In the
absence of goto, we often resort to more complex structured patterns. The
&ldquo;switch inside a loop&rdquo; is a classic one. Another is using a guard variable to
exit out of a series of nested loops:</p><span name="break">
</span>
<div class="codehilite"><pre><span class="c">// See if the matrix contains a zero.</span>
<span class="t">bool</span> <span class="i">found</span> = <span class="k">false</span>;
<span class="k">for</span> (<span class="t">int</span> <span class="i">x</span> = <span class="n">0</span>; <span class="i">x</span> &lt; <span class="i">xSize</span>; <span class="i">x</span>++) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">y</span> = <span class="n">0</span>; <span class="i">y</span> &lt; <span class="i">ySize</span>; <span class="i">y</span>++) {
    <span class="k">for</span> (<span class="t">int</span> <span class="i">z</span> = <span class="n">0</span>; <span class="i">z</span> &lt; <span class="i">zSize</span>; <span class="i">z</span>++) {
      <span class="k">if</span> (<span class="i">matrix</span>[<span class="i">x</span>][<span class="i">y</span>][<span class="i">z</span>] == <span class="n">0</span>) {
        <span class="i">printf</span>(<span class="s">&quot;found&quot;</span>);
        <span class="i">found</span> = <span class="k">true</span>;
        <span class="k">break</span>;
      }
    }
    <span class="k">if</span> (<span class="i">found</span>) <span class="k">break</span>;
  }
  <span class="k">if</span> (<span class="i">found</span>) <span class="k">break</span>;
}
</pre></div>
<p>Is that really better than:</p>
<div class="codehilite"><pre><span class="k">for</span> (<span class="t">int</span> <span class="i">x</span> = <span class="n">0</span>; <span class="i">x</span> &lt; <span class="i">xSize</span>; <span class="i">x</span>++) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">y</span> = <span class="n">0</span>; <span class="i">y</span> &lt; <span class="i">ySize</span>; <span class="i">y</span>++) {
    <span class="k">for</span> (<span class="t">int</span> <span class="i">z</span> = <span class="n">0</span>; <span class="i">z</span> &lt; <span class="i">zSize</span>; <span class="i">z</span>++) {
      <span class="k">if</span> (<span class="i">matrix</span>[<span class="i">x</span>][<span class="i">y</span>][<span class="i">z</span>] == <span class="n">0</span>) {
        <span class="i">printf</span>(<span class="s">&quot;found&quot;</span>);
        <span class="k">goto</span> <span class="i">done</span>;
      }
    }
  }
}
<span class="i">done</span>:
</pre></div>
<aside name="break">
<p>You could do this without <code>break</code> statements<span class="em">&mdash;</span>themselves a limited goto-ish
construct<span class="em">&mdash;</span>by inserting <code>!found &amp;&amp;</code> at the beginning of the condition clause
of each loop.</p>
</aside>
<p>I guess what I really don&rsquo;t like is that we&rsquo;re making language design and
engineering decisions today based on fear. Few people today have any subtle
understanding of the problems and benefits of goto. Instead, we just think it&rsquo;s
&ldquo;considered harmful&rdquo;. Personally, I&rsquo;ve never found dogma a good starting place
for quality creative work.</p>
</div>

<footer>
<a href="calls-and-functions.html" class="next">
  Next Chapter: &ldquo;Calls and Functions&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Calls and Functions &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Calls and Functions<small>24</small></a></h3>

<ul>
    <li><a href="#function-objects"><small>24.1</small> Function Objects</a></li>
    <li><a href="#compiling-to-function-objects"><small>24.2</small> Compiling to Function Objects</a></li>
    <li><a href="#call-frames"><small>24.3</small> Call Frames</a></li>
    <li><a href="#function-declarations"><small>24.4</small> Function Declarations</a></li>
    <li><a href="#function-calls"><small>24.5</small> Function Calls</a></li>
    <li><a href="#return-statements"><small>24.6</small> Return Statements</a></li>
    <li><a href="#native-functions"><small>24.7</small> Native Functions</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="closures.html" title="Closures" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="prev">←</a>
<a href="closures.html" title="Closures" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Calls and Functions<small>24</small></a></h3>

<ul>
    <li><a href="#function-objects"><small>24.1</small> Function Objects</a></li>
    <li><a href="#compiling-to-function-objects"><small>24.2</small> Compiling to Function Objects</a></li>
    <li><a href="#call-frames"><small>24.3</small> Call Frames</a></li>
    <li><a href="#function-declarations"><small>24.4</small> Function Declarations</a></li>
    <li><a href="#function-calls"><small>24.5</small> Function Calls</a></li>
    <li><a href="#return-statements"><small>24.6</small> Return Statements</a></li>
    <li><a href="#native-functions"><small>24.7</small> Native Functions</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="closures.html" title="Closures" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">24</div>
  <h1>Calls and Functions</h1>

<blockquote>
<p>Any problem in computer science can be solved with another level of
indirection. Except for the problem of too many layers of indirection.</p>
<p><cite>David Wheeler</cite></p>
</blockquote>
<p>This chapter is a beast. I try to break features into bite-sized pieces, but
sometimes you gotta swallow the whole <span name="eat">meal</span>. Our next
task is functions. We could start with only function declarations, but that&rsquo;s
not very useful when you can&rsquo;t call them. We could do calls, but there&rsquo;s nothing
to call. And all of the runtime support needed in the VM to support both of
those isn&rsquo;t very rewarding if it isn&rsquo;t hooked up to anything you can see. So
we&rsquo;re going to do it all. It&rsquo;s a lot, but we&rsquo;ll feel good when we&rsquo;re done.</p>
<aside name="eat">
<p>Eating<span class="em">&mdash;</span>consumption<span class="em">&mdash;</span>is a weird metaphor for a creative act. But most of the
biological processes that produce &ldquo;output&rdquo; are a little less, ahem, decorous.</p>
</aside>
<h2><a href="#function-objects" id="function-objects"><small>24&#8202;.&#8202;1</small>Function Objects</a></h2>
<p>The most interesting structural change in the VM is around the stack. We already
<em>have</em> a stack for local variables and temporaries, so we&rsquo;re partway there. But
we have no notion of a <em>call</em> stack. Before we can make much progress, we&rsquo;ll
have to fix that. But first, let&rsquo;s write some code. I always feel better once I
start moving. We can&rsquo;t do much without having some kind of representation for
functions, so we&rsquo;ll start there. From the VM&rsquo;s perspective, what is a function?</p>
<p>A function has a body that can be executed, so that means some bytecode. We
could compile the entire program and all of its function declarations into one
big monolithic Chunk. Each function would have a pointer to the first
instruction of its code inside the Chunk.</p>
<p>This is roughly how compilation to native code works where you end up with one
solid blob of machine code. But for our bytecode VM, we can do something a
little higher level. I think a cleaner model is to give each function its own
Chunk. We&rsquo;ll want some other metadata too, so let&rsquo;s go ahead and stuff it all in
a struct now.</p>
<div class="codehilite"><pre class="insert-before">  struct Obj* next;
};
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>Obj</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">int</span> <span class="i">arity</span>;
  <span class="t">Chunk</span> <span class="i">chunk</span>;
  <span class="t">ObjString</span>* <span class="i">name</span>;
} <span class="t">ObjFunction</span>;
</pre><pre class="insert-after">

struct ObjString {
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>Obj</em></div>

<p>Functions are first class in Lox, so they need to be actual Lox objects. Thus
ObjFunction has the same Obj header that all object types share. The <code>arity</code>
field stores the number of parameters the function expects. Then, in addition to
the chunk, we store the function&rsquo;s <span name="name">name</span>. That will be
handy for reporting readable runtime errors.</p>
<aside name="name">
<p>Humans don&rsquo;t seem to find numeric bytecode offsets particularly illuminating in
crash dumps.</p>
</aside>
<p>This is the first time the &ldquo;object&rdquo; module has needed to reference Chunk, so we
get an include.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#include &quot;chunk.h&quot;</span>
</pre><pre class="insert-after">#include &quot;value.h&quot;
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Like we did with strings, we define some accessories to make Lox functions
easier to work with in C. Sort of a poor man&rsquo;s object orientation. First, we&rsquo;ll
declare a C function to create a new Lox function.</p>
<div class="codehilite"><pre class="insert-before">  uint32_t hash;
};

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjString</em></div>
<pre class="insert"><span class="t">ObjFunction</span>* <span class="i">newFunction</span>();
</pre><pre class="insert-after">ObjString* takeString(char* chars, int length);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>

<p>The implementation is over here:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateObject</em>()</div>
<pre><span class="t">ObjFunction</span>* <span class="i">newFunction</span>() {
  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjFunction</span>, <span class="a">OBJ_FUNCTION</span>);
  <span class="i">function</span>-&gt;<span class="i">arity</span> = <span class="n">0</span>;
  <span class="i">function</span>-&gt;<span class="i">name</span> = <span class="a">NULL</span>;
  <span class="i">initChunk</span>(&amp;<span class="i">function</span>-&gt;<span class="i">chunk</span>);
  <span class="k">return</span> <span class="i">function</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>

<p>We use our friend <code>ALLOCATE_OBJ()</code> to allocate memory and initialize the
object&rsquo;s header so that the VM knows what type of object it is. Instead of
passing in arguments to initialize the function like we did with ObjString, we
set the function up in a sort of blank state<span class="em">&mdash;</span>zero arity, no name, and no
code. That will get filled in later after the function is created.</p>
<p>Since we have a new kind of object, we need a new object type in the enum.</p>
<div class="codehilite"><pre class="insert-before">typedef enum {
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_FUNCTION</span>,
</pre><pre class="insert-after">  OBJ_STRING,
} ObjType;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>When we&rsquo;re done with a function object, we must return the bits it borrowed back
to the operating system.</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>: {
      <span class="t">ObjFunction</span>* <span class="i">function</span> = (<span class="t">ObjFunction</span>*)<span class="i">object</span>;
      <span class="i">freeChunk</span>(&amp;<span class="i">function</span>-&gt;<span class="i">chunk</span>);
      <span class="a">FREE</span>(<span class="t">ObjFunction</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_STRING: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>This switch case is <span name="free-name">responsible</span> for freeing the
ObjFunction itself as well as any other memory it owns. Functions own their
chunk, so we call Chunk&rsquo;s destructor-like function.</p>
<aside name="free-name">
<p>We don&rsquo;t need to explicitly free the function&rsquo;s name because it&rsquo;s an ObjString.
That means we can let the garbage collector manage its lifetime for us. Or, at
least, we&rsquo;ll be able to once we <a href="garbage-collection.html">implement a garbage collector</a>.</p>
</aside>
<p>Lox lets you print any object, and functions are first-class objects, so we
need to handle them too.</p>
<div class="codehilite"><pre class="insert-before">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>:
      <span class="i">printFunction</span>(<span class="a">AS_FUNCTION</span>(<span class="i">value</span>));
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_STRING:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>This calls out to:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>copyString</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">printFunction</span>(<span class="t">ObjFunction</span>* <span class="i">function</span>) {
  <span class="i">printf</span>(<span class="s">&quot;&lt;fn %s&gt;&quot;</span>, <span class="i">function</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>copyString</em>()</div>

<p>Since a function knows its name, it may as well say it.</p>
<p>Finally, we have a couple of macros for converting values to functions. First,
make sure your value actually <em>is</em> a function.</p>
<div class="codehilite"><pre class="insert-before">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)</span>
</pre><pre class="insert-after">#define IS_STRING(value)       isObjType(value, OBJ_STRING)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Assuming that evaluates to true, you can then safely cast the Value to an
ObjFunction pointer using this:</p>
<div class="codehilite"><pre class="insert-before">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))</span>
</pre><pre class="insert-after">#define AS_STRING(value)       ((ObjString*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>With that, our object model knows how to represent functions. I&rsquo;m feeling warmed
up now. You ready for something a little harder?</p>
<h2><a href="#compiling-to-function-objects" id="compiling-to-function-objects"><small>24&#8202;.&#8202;2</small>Compiling to Function Objects</a></h2>
<p>Right now, our compiler assumes it is always compiling to one single chunk. With
each function&rsquo;s code living in separate chunks, that gets more complex. When the
compiler reaches a function declaration, it needs to emit code into the
function&rsquo;s chunk when compiling its body. At the end of the function body, the
compiler needs to return to the previous chunk it was working with.</p>
<p>That&rsquo;s fine for code inside function bodies, but what about code that isn&rsquo;t? The
&ldquo;top level&rdquo; of a Lox program is also imperative code and we need a chunk to
compile that into. We can simplify the compiler and VM by placing that top-level
code inside an automatically defined function too. That way, the compiler is
always within some kind of function body, and the VM always runs code by
invoking a function. It&rsquo;s as if the entire program is <span
name="wrap">wrapped</span> inside an implicit <code>main()</code> function.</p>
<aside name="wrap">
<p>One semantic corner where that analogy breaks down is global variables. They
have special scoping rules different from local variables, so in that way, the
top level of a script isn&rsquo;t like a function body.</p>
</aside>
<p>Before we get to user-defined functions, then, let&rsquo;s do the reorganization to
support that implicit top-level function. It starts with the Compiler struct.
Instead of pointing directly to a Chunk that the compiler writes to, it instead
has a reference to the function object being built.</p>
<div class="codehilite"><pre class="insert-before">typedef struct {
</pre><div class="source-file"><em>compiler.c</em><br>
in struct <em>Compiler</em></div>
<pre class="insert">  <span class="t">ObjFunction</span>* <span class="i">function</span>;
  <span class="t">FunctionType</span> <span class="i">type</span>;

</pre><pre class="insert-after">  Local locals[UINT8_COUNT];
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Compiler</em></div>

<p>We also have a little FunctionType enum. This lets the compiler tell when it&rsquo;s
compiling top-level code versus the body of a function. Most of the compiler
doesn&rsquo;t care about this<span class="em">&mdash;</span>that&rsquo;s why it&rsquo;s a useful abstraction<span class="em">&mdash;</span>but in one or
two places the distinction is meaningful. We&rsquo;ll get to one later.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after struct <em>Local</em></div>
<pre><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">TYPE_FUNCTION</span>,
  <span class="a">TYPE_SCRIPT</span>
} <span class="t">FunctionType</span>;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>Local</em></div>

<p>Every place in the compiler that was writing to the Chunk now needs to go
through that <code>function</code> pointer. Fortunately, many <span
name="current">chapters</span> ago, we encapsulated access to the chunk in the
<code>currentChunk()</code> function. We only need to fix that and the rest of the compiler
is happy.</p>
<aside name="current">
<p>It&rsquo;s almost like I had a crystal ball that could see into the future and knew
we&rsquo;d need to change the code later. But, really, it&rsquo;s because I wrote all the
code for the book before any of the text.</p>
</aside>
<div class="codehilite"><pre class="insert-before">Compiler* current = NULL;
</pre><div class="source-file"><em>compiler.c</em><br>
add after variable <em>current</em><br>
replace 5 lines</div>
<pre class="insert">

<span class="k">static</span> <span class="t">Chunk</span>* <span class="i">currentChunk</span>() {
  <span class="k">return</span> &amp;<span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>;
}
</pre><pre class="insert-after">

static void errorAt(Token* token, const char* message) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>current</em>, replace 5 lines</div>

<p>The current chunk is always the chunk owned by the function we&rsquo;re in the middle
of compiling. Next, we need to actually create that function. Previously, the VM
passed a Chunk to the compiler which filled it with code. Instead, the compiler
will create and return a function that contains the compiled top-level code<span class="em">&mdash;</span>which is all we support right now<span class="em">&mdash;</span>of the user&rsquo;s program.</p>
<h3><a href="#creating-functions-at-compile-time" id="creating-functions-at-compile-time"><small>24&#8202;.&#8202;2&#8202;.&#8202;1</small>Creating functions at compile time</a></h3>
<p>We start threading this through in <code>compile()</code>, which is the main entry point
into the compiler.</p>
<div class="codehilite"><pre class="insert-before">  Compiler compiler;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="i">initCompiler</span>(&amp;<span class="i">compiler</span>, <span class="a">TYPE_SCRIPT</span>);
</pre><pre class="insert-after">

  parser.hadError = false;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 2 lines</div>

<p>There are a bunch of changes in how the compiler is initialized. First, we
initialize the new Compiler fields.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>initCompiler</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">initCompiler</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">FunctionType</span> <span class="i">type</span>) {
  <span class="i">compiler</span>-&gt;<span class="i">function</span> = <span class="a">NULL</span>;
  <span class="i">compiler</span>-&gt;<span class="i">type</span> = <span class="i">type</span>;
</pre><pre class="insert-after">  compiler-&gt;localCount = 0;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>initCompiler</em>(), replace 1 line</div>

<p>Then we allocate a new function object to compile into.</p>
<div class="codehilite"><pre class="insert-before">  compiler-&gt;scopeDepth = 0;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>initCompiler</em>()</div>
<pre class="insert">  <span class="i">compiler</span>-&gt;<span class="i">function</span> = <span class="i">newFunction</span>();
</pre><pre class="insert-after">  current = compiler;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>

<p><span name="null"></span></p>
<aside name="null">
<p>I know, it looks dumb to null the <code>function</code> field only to immediately assign it
a value a few lines later. More garbage collection-related paranoia.</p>
</aside>
<p>Creating an ObjFunction in the compiler might seem a little strange. A function
object is the <em>runtime</em> representation of a function, but here we are creating
it at compile time. The way to think of it is that a function is similar to a
string or number literal. It forms a bridge between the compile time and runtime
worlds. When we get to function <em>declarations</em>, those really <em>are</em> literals<span class="em">&mdash;</span>they are a notation that produces values of a built-in type. So the <span
name="closure">compiler</span> creates function objects during compilation.
Then, at runtime, they are simply invoked.</p>
<aside name="closure">
<p>We can create functions at compile time because they contain only data available
at compile time. The function&rsquo;s code, name, and arity are all fixed. When we add
closures in the <a href="closures.html">next chapter</a>, which capture variables at runtime,
the story gets more complex.</p>
</aside>
<p>Here is another strange piece of code:</p>
<div class="codehilite"><pre class="insert-before">  current = compiler;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>initCompiler</em>()</div>
<pre class="insert">

  <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span>++];
  <span class="i">local</span>-&gt;<span class="i">depth</span> = <span class="n">0</span>;
  <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">start</span> = <span class="s">&quot;&quot;</span>;
  <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">length</span> = <span class="n">0</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>

<p>Remember that the compiler&rsquo;s <code>locals</code> array keeps track of which stack slots are
associated with which local variables or temporaries. From now on, the compiler
implicitly claims stack slot zero for the VM&rsquo;s own internal use. We give it an
empty name so that the user can&rsquo;t write an identifier that refers to it. I&rsquo;ll
explain what this is about when it becomes useful.</p>
<p>That&rsquo;s the initialization side. We also need a couple of changes on the other
end when we finish compiling some code.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>endCompiler</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">ObjFunction</span>* <span class="i">endCompiler</span>() {
</pre><pre class="insert-after">  emitReturn();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>endCompiler</em>(), replace 1 line</div>

<p>Previously, when <code>interpret()</code> called into the compiler, it passed in a Chunk to
be written to. Now that the compiler creates the function object itself, we
return that function. We grab it from the current compiler here:</p>
<div class="codehilite"><pre class="insert-before">  emitReturn();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endCompiler</em>()</div>
<pre class="insert">  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">current</span>-&gt;<span class="i">function</span>;

</pre><pre class="insert-after">#ifdef DEBUG_PRINT_CODE
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>

<p>And then return it to <code>compile()</code> like so:</p>
<div class="codehilite"><pre class="insert-before">#endif
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endCompiler</em>()</div>
<pre class="insert">

  <span class="k">return</span> <span class="i">function</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>

<p>Now is a good time to make another tweak in this function. Earlier, we added
some diagnostic code to have the VM dump the disassembled bytecode so we could
debug the compiler. We should fix that to keep working now that the generated
chunk is wrapped in a function.</p>
<div class="codehilite"><pre class="insert-before">#ifdef DEBUG_PRINT_CODE
  if (!parser.hadError) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endCompiler</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">disassembleChunk</span>(<span class="i">currentChunk</span>(), <span class="i">function</span>-&gt;<span class="i">name</span> != <span class="a">NULL</span>
        ? <span class="i">function</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span> : <span class="s">&quot;&lt;script&gt;&quot;</span>);
</pre><pre class="insert-after">  }
#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>(), replace 1 line</div>

<p>Notice the check in here to see if the function&rsquo;s name is <code>NULL</code>? User-defined
functions have names, but the implicit function we create for the top-level code
does not, and we need to handle that gracefully even in our own diagnostic code.
Speaking of which:</p>
<div class="codehilite"><pre class="insert-before">static void printFunction(ObjFunction* function) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>printFunction</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">function</span>-&gt;<span class="i">name</span> == <span class="a">NULL</span>) {
    <span class="i">printf</span>(<span class="s">&quot;&lt;script&gt;&quot;</span>);
    <span class="k">return</span>;
  }
</pre><pre class="insert-after">  printf(&quot;&lt;fn %s&gt;&quot;, function-&gt;name-&gt;chars);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printFunction</em>()</div>

<p>There&rsquo;s no way for a <em>user</em> to get a reference to the top-level function and try
to print it, but our <code>DEBUG_TRACE_EXECUTION</code> <span
name="debug">diagnostic</span> code that prints the entire stack can and does.</p>
<aside name="debug">
<p>It is no fun if the diagnostic code we use to find bugs itself causes the VM to
segfault!</p>
</aside>
<p>Bumping up a level to <code>compile()</code>, we adjust its signature.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;vm.h&quot;

</pre><div class="source-file"><em>compiler.h</em><br>
function <em>compile</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="t">ObjFunction</span>* <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, function <em>compile</em>(), replace 1 line</div>

<p>Instead of taking a chunk, now it returns a function. Over in the
implementation:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>compile</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="t">ObjFunction</span>* <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
</pre><pre class="insert-after">  initScanner(source);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>compile</em>(), replace 1 line</div>

<p>Finally we get to some actual code. We change the very end of the function to
this:</p>
<div class="codehilite"><pre class="insert-before">  while (!match(TOKEN_EOF)) {
    declaration();
  }

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">endCompiler</span>();
  <span class="k">return</span> <span class="i">parser</span>.<span class="i">hadError</span> ? <span class="a">NULL</span> : <span class="i">function</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 2 lines</div>

<p>We get the function object from the compiler. If there were no compile errors,
we return it. Otherwise, we signal an error by returning <code>NULL</code>. This way, the
VM doesn&rsquo;t try to execute a function that may contain invalid bytecode.</p>
<p>Eventually, we will update <code>interpret()</code> to handle the new declaration of
<code>compile()</code>, but first we have some other changes to make.</p>
<h2><a href="#call-frames" id="call-frames"><small>24&#8202;.&#8202;3</small>Call Frames</a></h2>
<p>It&rsquo;s time for a big conceptual leap. Before we can implement function
declarations and calls, we need to get the VM ready to handle them. There are
two main problems we need to worry about:</p>
<h3><a href="#allocating-local-variables" id="allocating-local-variables"><small>24&#8202;.&#8202;3&#8202;.&#8202;1</small>Allocating local variables</a></h3>
<p>The compiler allocates stack slots for local variables. How should that work
when the set of local variables in a program is distributed across multiple
functions?</p>
<p>One option would be to keep them totally separate. Each function would get its
own dedicated set of slots in the VM stack that it would own <span
name="static">forever</span>, even when the function isn&rsquo;t being called. Each
local variable in the entire program would have a bit of memory in the VM that
it keeps to itself.</p>
<aside name="static">
<p>It&rsquo;s basically what you&rsquo;d get if you declared every local variable in a C
program using <code>static</code>.</p>
</aside>
<p>Believe it or not, early programming language implementations worked this way.
The first Fortran compilers statically allocated memory for each variable. The
obvious problem is that it&rsquo;s really inefficient. Most functions are not in the
middle of being called at any point in time, so sitting on unused memory for
them is wasteful.</p>
<p>The more fundamental problem, though, is recursion. With recursion, you can be
&ldquo;in&rdquo; multiple calls to the same function at the same time. Each needs its <span
name="fortran">own</span> memory for its local variables. In jlox, we solved
this by dynamically allocating memory for an environment each time a function
was called or a block entered. In clox, we don&rsquo;t want that kind of performance
cost on every function call.</p>
<aside name="fortran">
<p>Fortran avoided this problem by disallowing recursion entirely. Recursion was
considered an advanced, esoteric feature at the time.</p>
</aside>
<p>Instead, our solution lies somewhere between Fortran&rsquo;s static allocation and
jlox&rsquo;s dynamic approach. The value stack in the VM works on the observation that
local variables and temporaries behave in a last-in first-out fashion.
Fortunately for us, that&rsquo;s still true even when you add function calls into the
mix. Here&rsquo;s an example:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">first</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
  <span class="i">second</span>();
  <span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
}

<span class="k">fun</span> <span class="i">second</span>() {
  <span class="k">var</span> <span class="i">c</span> = <span class="n">3</span>;
  <span class="k">var</span> <span class="i">d</span> = <span class="n">4</span>;
}

<span class="i">first</span>();
</pre></div>
<p>Step through the program and look at which variables are in memory at each point
in time:</p><img src="image/calls-and-functions/calls.png" alt="Tracing through the execution of the previous program, showing the stack of variables at each step." />
<p>As execution flows through the two calls, every local variable obeys the
principle that any variable declared after it will be discarded before the first
variable needs to be. This is true even across calls. We know we&rsquo;ll be done with
<code>c</code> and <code>d</code> before we are done with <code>a</code>. It seems we should be able to allocate
local variables on the VM&rsquo;s value stack.</p>
<p>Ideally, we still determine <em>where</em> on the stack each variable will go at
compile time. That keeps the bytecode instructions for working with variables
simple and fast. In the above example, we could <span
name="imagine">imagine</span> doing so in a straightforward way, but that
doesn&rsquo;t always work out. Consider:</p>
<aside name="imagine">
<p>I say &ldquo;imagine&rdquo; because the compiler can&rsquo;t actually figure this out. Because
functions are first class in Lox, we can&rsquo;t determine which functions call which
others at compile time.</p>
</aside>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">first</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
  <span class="i">second</span>();
  <span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
  <span class="i">second</span>();
}

<span class="k">fun</span> <span class="i">second</span>() {
  <span class="k">var</span> <span class="i">c</span> = <span class="n">3</span>;
  <span class="k">var</span> <span class="i">d</span> = <span class="n">4</span>;
}

<span class="i">first</span>();
</pre></div>
<p>In the first call to <code>second()</code>, <code>c</code> and <code>d</code> would go into slots 1 and 2. But in
the second call, we need to have made room for <code>b</code>, so <code>c</code> and <code>d</code> need to be in
slots 2 and 3. Thus the compiler can&rsquo;t pin down an exact slot for each local
variable across function calls. But <em>within</em> a given function, the <em>relative</em>
locations of each local variable are fixed. Variable <code>d</code> is always in the slot
right after <code>c</code>. This is the key insight.</p>
<p>When a function is called, we don&rsquo;t know where the top of the stack will be
because it can be called from different contexts. But, wherever that top happens
to be, we do know where all of the function&rsquo;s local variables will be relative
to that starting point. So, like many problems, we solve our allocation problem
with a level of indirection.</p>
<p>At the beginning of each function call, the VM records the location of the first
slot where that function&rsquo;s own locals begin. The instructions for working with
local variables access them by a slot index relative to that, instead of
relative to the bottom of the stack like they do today. At compile time, we
calculate those relative slots. At runtime, we convert that relative slot to an
absolute stack index by adding the function call&rsquo;s starting slot.</p>
<p>It&rsquo;s as if the function gets a &ldquo;window&rdquo; or &ldquo;frame&rdquo; within the larger stack where
it can store its locals. The position of the <strong>call frame</strong> is determined at
runtime, but within and relative to that region, we know where to find things.</p><img src="image/calls-and-functions/window.png" alt="The stack at the two points when second() is called, with a window hovering over each one showing the pair of stack slots used by the function." />
<p>The historical name for this recorded location where the function&rsquo;s locals start
is a <strong>frame pointer</strong> because it points to the beginning of the function&rsquo;s call
frame. Sometimes you hear <strong>base pointer</strong>, because it points to the base stack
slot on top of which all of the function&rsquo;s variables live.</p>
<p>That&rsquo;s the first piece of data we need to track. Every time we call a function,
the VM determines the first stack slot where that function&rsquo;s variables begin.</p>
<h3><a href="#return-addresses" id="return-addresses"><small>24&#8202;.&#8202;3&#8202;.&#8202;2</small>Return addresses</a></h3>
<p>Right now, the VM works its way through the instruction stream by incrementing
the <code>ip</code> field. The only interesting behavior is around control flow
instructions which offset the <code>ip</code> by larger amounts. <em>Calling</em> a function is
pretty straightforward<span class="em">&mdash;</span>simply set <code>ip</code> to point to the first instruction in
that function&rsquo;s chunk. But what about when the function is done?</p>
<p>The VM needs to <span name="return">return</span> back to the chunk where the
function was called from and resume execution at the instruction immediately
after the call. Thus, for each function call, we need to track where we jump
back to when the call completes. This is called a <strong>return address</strong> because
it&rsquo;s the address of the instruction that the VM returns to after the call.</p>
<p>Again, thanks to recursion, there may be multiple return addresses for a single
function, so this is a property of each <em>invocation</em> and not the function
itself.</p>
<aside name="return">
<p>The authors of early Fortran compilers had a clever trick for implementing
return addresses. Since they <em>didn&rsquo;t</em> support recursion, any given function
needed only a single return address at any point in time. So when a function was
called at runtime, the program would <em>modify its own code</em> to change a jump
instruction at the end of the function to jump back to its caller. Sometimes the
line between genius and madness is hair thin.</p>
</aside>
<h3><a href="#the-call-stack" id="the-call-stack"><small>24&#8202;.&#8202;3&#8202;.&#8202;3</small>The call stack</a></h3>
<p>So for each live function invocation<span class="em">&mdash;</span>each call that hasn&rsquo;t returned yet<span class="em">&mdash;</span>we
need to track where on the stack that function&rsquo;s locals begin, and where the
caller should resume. We&rsquo;ll put this, along with some other stuff, in a new
struct.</p>
<div class="codehilite"><pre class="insert-before">#define STACK_MAX 256
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">ObjFunction</span>* <span class="i">function</span>;
  <span class="t">uint8_t</span>* <span class="i">ip</span>;
  <span class="t">Value</span>* <span class="i">slots</span>;
} <span class="t">CallFrame</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>

<p>A CallFrame represents a single ongoing function call. The <code>slots</code> field points
into the VM&rsquo;s value stack at the first slot that this function can use. I gave
it a plural name because<span class="em">&mdash;</span>thanks to C&rsquo;s weird &ldquo;pointers are sort of arrays&rdquo;
thing<span class="em">&mdash;</span>we&rsquo;ll treat it like an array.</p>
<p>The implementation of return addresses is a little different from what I
described above. Instead of storing the return address in the callee&rsquo;s frame,
the caller stores its own <code>ip</code>. When we return from a function, the VM will jump
to the <code>ip</code> of the caller&rsquo;s CallFrame and resume from there.</p>
<p>I also stuffed a pointer to the function being called in here. We&rsquo;ll use that to
look up constants and for a few other things.</p>
<p>Each time a function is called, we create one of these structs. We could <span
name="heap">dynamically</span> allocate them on the heap, but that&rsquo;s slow.
Function calls are a core operation, so they need to be as fast as possible.
Fortunately, we can make the same observation we made for variables: function
calls have stack semantics. If <code>first()</code> calls <code>second()</code>, the call to
<code>second()</code> will complete before <code>first()</code> does.</p>
<aside name="heap">
<p>Many Lisp implementations dynamically allocate stack frames because it
simplifies implementing <a href="https://en.wikipedia.org/wiki/Continuation">continuations</a>. If your language supports
continuations, then function calls do <em>not</em> always have stack semantics.</p>
</aside>
<p>So over in the VM, we create an array of these CallFrame structs up front and
treat it as a stack, like we do with the value array.</p>
<div class="codehilite"><pre class="insert-before">typedef struct {
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em><br>
replace 2 lines</div>
<pre class="insert">  <span class="t">CallFrame</span> <span class="i">frames</span>[<span class="a">FRAMES_MAX</span>];
  <span class="t">int</span> <span class="i">frameCount</span>;

</pre><pre class="insert-after">  Value stack[STACK_MAX];
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em>, replace 2 lines</div>

<p>This array replaces the <code>chunk</code> and <code>ip</code> fields we used to have directly in the
VM. Now each CallFrame has its own <code>ip</code> and its own pointer to the ObjFunction
that it&rsquo;s executing. From there, we can get to the function&rsquo;s chunk.</p>
<p>The new <code>frameCount</code> field in the VM stores the current height of the CallFrame
stack<span class="em">&mdash;</span>the number of ongoing function calls. To keep clox simple, the array&rsquo;s
capacity is fixed. This means, as in many language implementations, there is a
maximum call depth we can handle. For clox, it&rsquo;s defined here:</p>
<div class="codehilite"><pre class="insert-before">#include &quot;value.h&quot;

</pre><div class="source-file"><em>vm.h</em><br>
replace 1 line</div>
<pre class="insert"><span class="a">#define FRAMES_MAX 64</span>
<span class="a">#define STACK_MAX (FRAMES_MAX * UINT8_COUNT)</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, replace 1 line</div>

<p>We also redefine the value stack&rsquo;s <span name="plenty">size</span> in terms of
that to make sure we have plenty of stack slots even in very deep call trees.
When the VM starts up, the CallFrame stack is empty.</p>
<aside name="plenty">
<p>It is still possible to overflow the stack if enough function calls use enough
temporaries in addition to locals. A robust implementation would guard against
this, but I&rsquo;m trying to keep things simple.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  vm.stackTop = vm.stack;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>resetStack</em>()</div>
<pre class="insert">  <span class="i">vm</span>.<span class="i">frameCount</span> = <span class="n">0</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>resetStack</em>()</div>

<p>The &ldquo;vm.h&rdquo; header needs access to ObjFunction, so we add an include.</p>
<div class="codehilite"><pre class="insert-before">#define clox_vm_h

</pre><div class="source-file"><em>vm.h</em><br>
replace 1 line</div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
</pre><pre class="insert-after">#include &quot;table.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, replace 1 line</div>

<p>Now we&rsquo;re ready to move over to the VM&rsquo;s implementation file. We&rsquo;ve got some
grunt work ahead of us. We&rsquo;ve moved <code>ip</code> out of the VM struct and into
CallFrame. We need to fix every line of code in the VM that touches <code>ip</code> to
handle that. Also, the instructions that access local variables by stack slot
need to be updated to do so relative to the current CallFrame&rsquo;s <code>slots</code> field.</p>
<p>We&rsquo;ll start at the top and plow through it.</p>
<div class="codehilite"><pre class="insert-before">static InterpretResult run() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 4 lines</div>
<pre class="insert">  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];

<span class="a">#define READ_BYTE() (*frame-&gt;ip++)</span>

<span class="a">#define READ_SHORT() \</span>
<span class="a">    (frame-&gt;ip += 2, \</span>
<span class="a">    (uint16_t)((frame-&gt;ip[-2] &lt;&lt; 8) | frame-&gt;ip[-1]))</span>

<span class="a">#define READ_CONSTANT() \</span>
<span class="a">    (frame-&gt;function-&gt;chunk.constants.values[READ_BYTE()])</span>

</pre><pre class="insert-after">#define READ_STRING() AS_STRING(READ_CONSTANT())
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 4 lines</div>

<p>First, we store the current topmost CallFrame in a <span
name="local">local</span> variable inside the main bytecode execution function.
Then we replace the bytecode access macros with versions that access <code>ip</code>
through that variable.</p>
<aside name="local">
<p>We could access the current frame by going through the CallFrame array every
time, but that&rsquo;s verbose. More importantly, storing the frame in a local
variable encourages the C compiler to keep that pointer in a register. That
speeds up access to the frame&rsquo;s <code>ip</code>. There&rsquo;s no <em>guarantee</em> that the compiler
will do this, but there&rsquo;s a good chance it will.</p>
</aside>
<p>Now onto each instruction that needs a little tender loving care.</p>
<div class="codehilite"><pre class="insert-before">      case OP_GET_LOCAL: {
        uint8_t slot = READ_BYTE();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="i">push</span>(<span class="i">frame</span>-&gt;<span class="i">slots</span>[<span class="i">slot</span>]);
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>Previously, <code>OP_GET_LOCAL</code> read the given local slot directly from the VM&rsquo;s
stack array, which meant it indexed the slot starting from the bottom of the
stack. Now, it accesses the current frame&rsquo;s <code>slots</code> array, which means it
accesses the given numbered slot relative to the beginning of that frame.</p>
<p>Setting a local variable works the same way.</p>
<div class="codehilite"><pre class="insert-before">      case OP_SET_LOCAL: {
        uint8_t slot = READ_BYTE();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="i">frame</span>-&gt;<span class="i">slots</span>[<span class="i">slot</span>] = <span class="i">peek</span>(<span class="n">0</span>);
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>The jump instructions used to modify the VM&rsquo;s <code>ip</code> field. Now, they do the same
for the current frame&rsquo;s <code>ip</code>.</p>
<div class="codehilite"><pre class="insert-before">      case OP_JUMP: {
        uint16_t offset = READ_SHORT();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="i">frame</span>-&gt;<span class="i">ip</span> += <span class="i">offset</span>;
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>Same with the conditional jump:</p>
<div class="codehilite"><pre class="insert-before">      case OP_JUMP_IF_FALSE: {
        uint16_t offset = READ_SHORT();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="k">if</span> (<span class="i">isFalsey</span>(<span class="i">peek</span>(<span class="n">0</span>))) <span class="i">frame</span>-&gt;<span class="i">ip</span> += <span class="i">offset</span>;
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>And our backward-jumping loop instruction:</p>
<div class="codehilite"><pre class="insert-before">      case OP_LOOP: {
        uint16_t offset = READ_SHORT();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="i">frame</span>-&gt;<span class="i">ip</span> -= <span class="i">offset</span>;
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>We have some diagnostic code that prints each instruction as it executes to help
us debug our VM. That needs to work with the new structure too.</p>
<div class="codehilite"><pre class="insert-before">    printf(&quot;\n&quot;);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">    <span class="i">disassembleInstruction</span>(&amp;<span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>,
        (<span class="t">int</span>)(<span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>));
</pre><pre class="insert-after">#endif
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>Instead of passing in the VM&rsquo;s <code>chunk</code> and <code>ip</code> fields, now we read from the
current CallFrame.</p>
<p>You know, that wasn&rsquo;t too bad, actually. Most instructions just use the macros
so didn&rsquo;t need to be touched. Next, we jump up a level to the code that calls
<code>run()</code>.</p>
<div class="codehilite"><pre class="insert-before">InterpretResult interpret(const char* source) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>interpret</em>()<br>
replace 10 lines</div>
<pre class="insert">  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">compile</span>(<span class="i">source</span>);
  <span class="k">if</span> (<span class="i">function</span> == <span class="a">NULL</span>) <span class="k">return</span> <span class="a">INTERPRET_COMPILE_ERROR</span>;

  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">function</span>));
  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span>++];
  <span class="i">frame</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="i">frame</span>-&gt;<span class="i">ip</span> = <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>;
  <span class="i">frame</span>-&gt;<span class="i">slots</span> = <span class="i">vm</span>.<span class="i">stack</span>;
</pre><pre class="insert-after">

  InterpretResult result = run();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 10 lines</div>

<p>We finally get to wire up our earlier compiler changes to the back-end changes
we just made. First, we pass the source code to the compiler. It returns us a
new ObjFunction containing the compiled top-level code. If we get <code>NULL</code> back,
it means there was some compile-time error which the compiler has already
reported. In that case, we bail out since we can&rsquo;t run anything.</p>
<p>Otherwise, we store the function on the stack and prepare an initial CallFrame
to execute its code. Now you can see why the compiler sets aside stack slot zero<span class="em">&mdash;</span>that stores the function being called. In the new CallFrame, we point to the
function, initialize its <code>ip</code> to point to the beginning of the function&rsquo;s
bytecode, and set up its stack window to start at the very bottom of the VM&rsquo;s
value stack.</p>
<p>This gets the interpreter ready to start executing code. After finishing, the VM
used to free the hardcoded chunk. Now that the ObjFunction owns that code, we
don&rsquo;t need to do that anymore, so the end of <code>interpret()</code> is simply this:</p>
<div class="codehilite"><pre class="insert-before">  frame-&gt;slots = vm.stack;

</pre><div class="source-file"><em>vm.c</em><br>
in <em>interpret</em>()<br>
replace 4 lines</div>
<pre class="insert">  <span class="k">return</span> <span class="i">run</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 4 lines</div>

<p>The last piece of code referring to the old VM fields is <code>runtimeError()</code>. We&rsquo;ll
revisit that later in the chapter, but for now let&rsquo;s change it to this:</p>
<div class="codehilite"><pre class="insert-before">  fputs(&quot;\n&quot;, stderr);

</pre><div class="source-file"><em>vm.c</em><br>
in <em>runtimeError</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
  <span class="t">size_t</span> <span class="i">instruction</span> = <span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span> - <span class="n">1</span>;
  <span class="t">int</span> <span class="i">line</span> = <span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">lines</span>[<span class="i">instruction</span>];
</pre><pre class="insert-after">  fprintf(stderr, &quot;[line %d] in script\n&quot;, line);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>runtimeError</em>(), replace 2 lines</div>

<p>Instead of reading the chunk and <code>ip</code> directly from the VM, it pulls those from
the topmost CallFrame on the stack. That should get the function working again
and behaving as it did before.</p>
<p>Assuming we did all of that correctly, we got clox back to a runnable
state. Fire it up and it does<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>exactly what it did before. We haven&rsquo;t added
any new features yet, so this is kind of a let down. But all of the
infrastructure is there and ready for us now. Let&rsquo;s take advantage of it.</p>
<h2><a href="#function-declarations" id="function-declarations"><small>24&#8202;.&#8202;4</small>Function Declarations</a></h2>
<p>Before we can do call expressions, we need something to call, so we&rsquo;ll do
function declarations first. The <span name="fun">fun</span> starts with a
keyword.</p>
<aside name="fun">
<p>Yes, I am going to make a dumb joke about the <code>fun</code> keyword every time it
comes up.</p>
</aside>
<div class="codehilite"><pre class="insert-before">static void declaration() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declaration</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_FUN</span>)) {
    <span class="i">funDeclaration</span>();
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_VAR</span>)) {
</pre><pre class="insert-after">    varDeclaration();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>

<p>That passes control to here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>block</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">funDeclaration</span>() {
  <span class="t">uint8_t</span> <span class="i">global</span> = <span class="i">parseVariable</span>(<span class="s">&quot;Expect function name.&quot;</span>);
  <span class="i">markInitialized</span>();
  <span class="i">function</span>(<span class="a">TYPE_FUNCTION</span>);
  <span class="i">defineVariable</span>(<span class="i">global</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>block</em>()</div>

<p>Functions are first-class values, and a function declaration simply creates and
stores one in a newly declared variable. So we parse the name just like any
other variable declaration. A function declaration at the top level will bind
the function to a global variable. Inside a block or other function, a function
declaration creates a local variable.</p>
<p>In an earlier chapter, I explained how variables <a href="local-variables.html#another-scope-edge-case">get defined in two
stages</a>. This ensures you can&rsquo;t access a variable&rsquo;s value inside the
variable&rsquo;s own initializer. That would be bad because the variable doesn&rsquo;t
<em>have</em> a value yet.</p>
<p>Functions don&rsquo;t suffer from this problem. It&rsquo;s safe for a function to refer to
its own name inside its body. You can&rsquo;t <em>call</em> the function and execute the body
until after it&rsquo;s fully defined, so you&rsquo;ll never see the variable in an
uninitialized state. Practically speaking, it&rsquo;s useful to allow this in order to
support recursive local functions.</p>
<p>To make that work, we mark the function declaration&rsquo;s variable &ldquo;initialized&rdquo; as
soon as we compile the name, before we compile the body. That way the name can
be referenced inside the body without generating an error.</p>
<p>We do need one check, though.</p>
<div class="codehilite"><pre class="insert-before">static void markInitialized() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>markInitialized</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> == <span class="n">0</span>) <span class="k">return</span>;
</pre><pre class="insert-after">  current-&gt;locals[current-&gt;localCount - 1].depth =
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>markInitialized</em>()</div>

<p>Before, we called <code>markInitialized()</code> only when we already knew we were in a
local scope. Now, a top-level function declaration will also call this function.
When that happens, there is no local variable to mark initialized<span class="em">&mdash;</span>the
function is bound to a global variable.</p>
<p>Next, we compile the function itself<span class="em">&mdash;</span>its parameter list and block body. For
that, we use a separate helper function. That helper generates code that
leaves the resulting function object on top of the stack. After that, we call
<code>defineVariable()</code> to store that function back into the variable we declared for
it.</p>
<p>I split out the code to compile the parameters and body because we&rsquo;ll reuse it
later for parsing method declarations inside classes. Let&rsquo;s build it
incrementally, starting with this:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>block</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">function</span>(<span class="t">FunctionType</span> <span class="i">type</span>) {
  <span class="t">Compiler</span> <span class="i">compiler</span>;
  <span class="i">initCompiler</span>(&amp;<span class="i">compiler</span>, <span class="i">type</span>);
  <span class="i">beginScope</span>();<span name="no-end-scope"> </span>

  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after function name.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after parameters.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_BRACE</span>, <span class="s">&quot;Expect &#39;{&#39; before function body.&quot;</span>);
  <span class="i">block</span>();

  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">endCompiler</span>();
  <span class="i">emitBytes</span>(<span class="a">OP_CONSTANT</span>, <span class="i">makeConstant</span>(<span class="a">OBJ_VAL</span>(<span class="i">function</span>)));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>block</em>()</div>

<aside name="no-end-scope">
<p>This <code>beginScope()</code> doesn&rsquo;t have a corresponding <code>endScope()</code> call. Because we
end Compiler completely when we reach the end of the function body, there&rsquo;s no
need to close the lingering outermost scope.</p>
</aside>
<p>For now, we won&rsquo;t worry about parameters. We parse an empty pair of parentheses
followed by the body. The body starts with a left curly brace, which we parse
here. Then we call our existing <code>block()</code> function, which knows how to compile
the rest of a block including the closing brace.</p>
<h3><a href="#a-stack-of-compilers" id="a-stack-of-compilers"><small>24&#8202;.&#8202;4&#8202;.&#8202;1</small>A stack of compilers</a></h3>
<p>The interesting parts are the compiler stuff at the top and bottom. The Compiler
struct stores data like which slots are owned by which local variables, how many
blocks of nesting we&rsquo;re currently in, etc. All of that is specific to a single
function. But now the front end needs to handle compiling multiple functions
<span name="nested">nested</span> within each other.</p>
<aside name="nested">
<p>Remember that the compiler treats top-level code as the body of an implicit
function, so as soon as we add <em>any</em> function declarations, we&rsquo;re in a world of
nested functions.</p>
</aside>
<p>The trick for managing that is to create a separate Compiler for each function
being compiled. When we start compiling a function declaration, we create a new
Compiler on the C stack and initialize it. <code>initCompiler()</code> sets that Compiler
to be the current one. Then, as we compile the body, all of the functions that
emit bytecode write to the chunk owned by the new Compiler&rsquo;s function.</p>
<p>After we reach the end of the function&rsquo;s block body, we call <code>endCompiler()</code>.
That yields the newly compiled function object, which we store as a constant in
the <em>surrounding</em> function&rsquo;s constant table. But, wait, how do we get back to
the surrounding function? We lost it when <code>initCompiler()</code> overwrote the current
compiler pointer.</p>
<p>We fix that by treating the series of nested Compiler structs as a stack. Unlike
the Value and CallFrame stacks in the VM, we won&rsquo;t use an array. Instead, we use
a linked list. Each Compiler points back to the Compiler for the function that
encloses it, all the way back to the root Compiler for the top-level code.</p>
<div class="codehilite"><pre class="insert-before">} FunctionType;

</pre><div class="source-file"><em>compiler.c</em><br>
add after enum <em>FunctionType</em><br>
replace 1 line</div>
<pre class="insert"><span class="k">typedef</span> <span class="k">struct</span> <span class="t">Compiler</span> {
  <span class="k">struct</span> <span class="t">Compiler</span>* <span class="i">enclosing</span>;
</pre><pre class="insert-after">  ObjFunction* function;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>FunctionType</em>, replace 1 line</div>

<p>Inside the Compiler struct, we can&rsquo;t reference the Compiler <em>typedef</em> since that
declaration hasn&rsquo;t finished yet. Instead, we give a name to the struct itself
and use that for the field&rsquo;s type. C is weird.</p>
<p>When initializing a new Compiler, we capture the about-to-no-longer-be-current
one in that pointer.</p>
<div class="codehilite"><pre class="insert-before">static void initCompiler(Compiler* compiler, FunctionType type) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>initCompiler</em>()</div>
<pre class="insert">  <span class="i">compiler</span>-&gt;<span class="i">enclosing</span> = <span class="i">current</span>;
</pre><pre class="insert-after">  compiler-&gt;function = NULL;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>

<p>Then when a Compiler finishes, it pops itself off the stack by restoring the
previous compiler to be the new current one.</p>
<div class="codehilite"><pre class="insert-before">#endif

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endCompiler</em>()</div>
<pre class="insert">  <span class="i">current</span> = <span class="i">current</span>-&gt;<span class="i">enclosing</span>;
</pre><pre class="insert-after">  return function;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>

<p>Note that we don&rsquo;t even need to <span name="compiler">dynamically</span>
allocate the Compiler structs. Each is stored as a local variable in the C stack<span class="em">&mdash;</span>either in <code>compile()</code> or <code>function()</code>. The linked list of Compilers threads
through the C stack. The reason we can get an unbounded number of them is
because our compiler uses recursive descent, so <code>function()</code> ends up calling
itself recursively when you have nested function declarations.</p>
<aside name="compiler">
<p>Using the native stack for Compiler structs does mean our compiler has a
practical limit on how deeply nested function declarations can be. Go too far
and you could overflow the C stack. If we want the compiler to be more robust
against pathological or even malicious code<span class="em">&mdash;</span>a real concern for tools like
JavaScript VMs<span class="em">&mdash;</span>it would be good to have our compiler artificially limit the
amount of function nesting it permits.</p>
</aside>
<h3><a href="#function-parameters" id="function-parameters"><small>24&#8202;.&#8202;4&#8202;.&#8202;2</small>Function parameters</a></h3>
<p>Functions aren&rsquo;t very useful if you can&rsquo;t pass arguments to them, so let&rsquo;s do
parameters next.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_LEFT_PAREN, &quot;Expect '(' after function name.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>function</em>()</div>
<pre class="insert">  <span class="k">if</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_PAREN</span>)) {
    <span class="k">do</span> {
      <span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">arity</span>++;
      <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">arity</span> &gt; <span class="n">255</span>) {
        <span class="i">errorAtCurrent</span>(<span class="s">&quot;Can&#39;t have more than 255 parameters.&quot;</span>);
      }
      <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">parseVariable</span>(<span class="s">&quot;Expect parameter name.&quot;</span>);
      <span class="i">defineVariable</span>(<span class="i">constant</span>);
    } <span class="k">while</span> (<span class="i">match</span>(<span class="a">TOKEN_COMMA</span>));
  }
</pre><pre class="insert-after">  consume(TOKEN_RIGHT_PAREN, &quot;Expect ')' after parameters.&quot;);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>function</em>()</div>

<p>Semantically, a parameter is simply a local variable declared in the outermost
lexical scope of the function body. We get to use the existing compiler support
for declaring named local variables to parse and compile parameters. Unlike
local variables, which have initializers, there&rsquo;s no code here to initialize the
parameter&rsquo;s value. We&rsquo;ll see how they are initialized later when we do argument
passing in function calls.</p>
<p>While we&rsquo;re at it, we note the function&rsquo;s arity by counting how many parameters
we parse. The other piece of metadata we store with a function is its name. When
compiling a function declaration, we call <code>initCompiler()</code> right after we parse
the function&rsquo;s name. That means we can grab the name right then from the
previous token.</p>
<div class="codehilite"><pre class="insert-before">  current = compiler;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>initCompiler</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">type</span> != <span class="a">TYPE_SCRIPT</span>) {
    <span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">name</span> = <span class="i">copyString</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">start</span>,
                                         <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">length</span>);
  }
</pre><pre class="insert-after">

  Local* local = &amp;current-&gt;locals[current-&gt;localCount++];
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>

<p>Note that we&rsquo;re careful to create a copy of the name string. Remember, the
lexeme points directly into the original source code string. That string may get
freed once the code is finished compiling. The function object we create in the
compiler outlives the compiler and persists until runtime. So it needs its own
heap-allocated name string that it can keep around.</p>
<p>Rad. Now we can compile function declarations, like this:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">areWeHavingItYet</span>() {
  <span class="k">print</span> <span class="s">&quot;Yes we are!&quot;</span>;
}

<span class="k">print</span> <span class="i">areWeHavingItYet</span>;
</pre></div>
<p>We just can&rsquo;t do anything <span name="useful">useful</span> with them.</p>
<aside name="useful">
<p>We can print them! I guess that&rsquo;s not very useful, though.</p>
</aside>
<h2><a href="#function-calls" id="function-calls"><small>24&#8202;.&#8202;5</small>Function Calls</a></h2>
<p>By the end of this section, we&rsquo;ll start to see some interesting behavior. The
next step is calling functions. We don&rsquo;t usually think of it this way, but a
function call expression is kind of an infix <code>(</code> operator. You have a
high-precedence expression on the left for the thing being called<span class="em">&mdash;</span>usually
just a single identifier. Then the <code>(</code> in the middle, followed by the argument
expressions separated by commas, and a final <code>)</code> to wrap it up at the end.</p>
<p>That odd grammatical perspective explains how to hook the syntax into our
parsing table.</p>
<div class="codehilite"><pre class="insert-before">ParseRule rules[] = {
</pre><div class="source-file"><em>compiler.c</em><br>
add after <em>unary</em>()<br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_LEFT_PAREN</span>]    = {<span class="i">grouping</span>, <span class="i">call</span>,   <span class="a">PREC_CALL</span>},
</pre><pre class="insert-after">  [TOKEN_RIGHT_PAREN]   = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>unary</em>(), replace 1 line</div>

<p>When the parser encounters a left parenthesis following an expression, it
dispatches to a new parser function.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>binary</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">call</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="i">argumentList</span>();
  <span class="i">emitBytes</span>(<span class="a">OP_CALL</span>, <span class="i">argCount</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>binary</em>()</div>

<p>We&rsquo;ve already consumed the <code>(</code> token, so next we compile the arguments using a
separate <code>argumentList()</code> helper. That function returns the number of arguments
it compiled. Each argument expression generates code that leaves its value on
the stack in preparation for the call. After that, we emit a new <code>OP_CALL</code>
instruction to invoke the function, using the argument count as an operand.</p>
<p>We compile the arguments using this friend:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>defineVariable</em>()</div>
<pre><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">argumentList</span>() {
  <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="n">0</span>;
  <span class="k">if</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_PAREN</span>)) {
    <span class="k">do</span> {
      <span class="i">expression</span>();
      <span class="i">argCount</span>++;
    } <span class="k">while</span> (<span class="i">match</span>(<span class="a">TOKEN_COMMA</span>));
  }
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after arguments.&quot;</span>);
  <span class="k">return</span> <span class="i">argCount</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>defineVariable</em>()</div>

<p>That code should look familiar from jlox. We chew through arguments as long as
we find commas after each expression. Once we run out, we consume the final
closing parenthesis and we&rsquo;re done.</p>
<p>Well, almost. Back in jlox, we added a compile-time check that you don&rsquo;t pass
more than 255 arguments to a call. At the time, I said that was because clox
would need a similar limit. Now you can see why<span class="em">&mdash;</span>since we stuff the argument
count into the bytecode as a single-byte operand, we can only go up to 255. We
need to verify that in this compiler too.</p>
<div class="codehilite"><pre class="insert-before">      expression();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>argumentList</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">argCount</span> == <span class="n">255</span>) {
        <span class="i">error</span>(<span class="s">&quot;Can&#39;t have more than 255 arguments.&quot;</span>);
      }
</pre><pre class="insert-after">      argCount++;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>argumentList</em>()</div>

<p>That&rsquo;s the front end. Let&rsquo;s skip over to the back end, with a quick stop in the
middle to declare the new instruction.</p>
<div class="codehilite"><pre class="insert-before">  OP_LOOP,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_CALL</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<h3><a href="#binding-arguments-to-parameters" id="binding-arguments-to-parameters"><small>24&#8202;.&#8202;5&#8202;.&#8202;1</small>Binding arguments to parameters</a></h3>
<p>Before we get to the implementation, we should think about what the stack looks
like at the point of a call and what we need to do from there. When we reach the
call instruction, we have already executed the expression for the function being
called, followed by its arguments. Say our program looks like this:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">sum</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>) {
  <span class="k">return</span> <span class="i">a</span> + <span class="i">b</span> + <span class="i">c</span>;
}

<span class="k">print</span> <span class="n">4</span> + <span class="i">sum</span>(<span class="n">5</span>, <span class="n">6</span>, <span class="n">7</span>);
</pre></div>
<p>If we pause the VM right on the <code>OP_CALL</code> instruction for that call to <code>sum()</code>,
the stack looks like this:</p><img src="image/calls-and-functions/argument-stack.png" alt="Stack: 4, fn sum, 5, 6, 7." />
<p>Picture this from the perspective of <code>sum()</code> itself. When the compiler compiled
<code>sum()</code>, it automatically allocated slot zero. Then, after that, it allocated
local slots for the parameters <code>a</code>, <code>b</code>, and <code>c</code>, in order. To perform a call to
<code>sum()</code>, we need a CallFrame initialized with the function being called and a
region of stack slots that it can use. Then we need to collect the arguments
passed to the function and get them into the corresponding slots for the
parameters.</p>
<p>When the VM starts executing the body of <code>sum()</code>, we want its stack window to
look like this:</p><img src="image/calls-and-functions/parameter-window.png" alt="The same stack with the sum() function's call frame window surrounding fn sum, 5, 6, and 7." />
<p>Do you notice how the argument slots that the caller sets up and the parameter
slots the callee needs are both in exactly the right order? How convenient! This
is no coincidence. When I talked about each CallFrame having its own window into
the stack, I never said those windows must be <em>disjoint</em>. There&rsquo;s nothing
preventing us from overlapping them, like this:</p><img src="image/calls-and-functions/overlapping-windows.png" alt="The same stack with the top-level call frame covering the entire stack and the sum() function's call frame window surrounding fn sum, 5, 6, and 7." />
<p><span name="lua">The</span> top of the caller&rsquo;s stack contains the function
being called followed by the arguments in order. We know the caller doesn&rsquo;t have
any other slots above those in use because any temporaries needed when
evaluating argument expressions have been discarded by now. The bottom of the
callee&rsquo;s stack overlaps so that the parameter slots exactly line up with where
the argument values already live.</p>
<aside name="lua">
<p>Different bytecode VMs and real CPU architectures have different <em>calling
conventions</em>, which is the specific mechanism they use to pass arguments, store
the return address, etc. The mechanism I use here is based on Lua&rsquo;s clean, fast
virtual machine.</p>
</aside>
<p>This means that we don&rsquo;t need to do <em>any</em> work to &ldquo;bind an argument to a
parameter&rdquo;. There&rsquo;s no copying values between slots or across environments. The
arguments are already exactly where they need to be. It&rsquo;s hard to beat that for
performance.</p>
<p>Time to implement the call instruction.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_CALL</span>: {
        <span class="t">int</span> <span class="i">argCount</span> = <span class="a">READ_BYTE</span>();
        <span class="k">if</span> (!<span class="i">callValue</span>(<span class="i">peek</span>(<span class="i">argCount</span>), <span class="i">argCount</span>)) {
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We need to know the function being called and the number of arguments passed to
it. We get the latter from the instruction&rsquo;s operand. That also tells us where
to find the function on the stack by counting past the argument slots from the
top of the stack. We hand that data off to a separate <code>callValue()</code> function. If
that returns <code>false</code>, it means the call caused some sort of runtime error. When
that happens, we abort the interpreter.</p>
<p>If <code>callValue()</code> is successful, there will be a new frame on the CallFrame stack
for the called function. The <code>run()</code> function has its own cached pointer to the
current frame, so we need to update that.</p>
<div class="codehilite"><pre class="insert-before">          return INTERPRET_RUNTIME_ERROR;
        }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Since the bytecode dispatch loop reads from that <code>frame</code> variable, when the VM
goes to execute the next instruction, it will read the <code>ip</code> from the newly
called function&rsquo;s CallFrame and jump to its code. The work for executing that
call begins here:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>peek</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">callValue</span>(<span class="t">Value</span> <span class="i">callee</span>, <span class="t">int</span> <span class="i">argCount</span>) {
  <span class="k">if</span> (<span class="a">IS_OBJ</span>(<span class="i">callee</span>)) {
    <span class="k">switch</span> (<span class="a">OBJ_TYPE</span>(<span class="i">callee</span>)) {
      <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>:<span name="switch"> </span>
        <span class="k">return</span> <span class="i">call</span>(<span class="a">AS_FUNCTION</span>(<span class="i">callee</span>), <span class="i">argCount</span>);
      <span class="k">default</span>:
        <span class="k">break</span>; <span class="c">// Non-callable object type.</span>
    }
  }
  <span class="i">runtimeError</span>(<span class="s">&quot;Can only call functions and classes.&quot;</span>);
  <span class="k">return</span> <span class="k">false</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>peek</em>()</div>

<aside name="switch">
<p>Using a <code>switch</code> statement to check a single type is overkill now, but will make
sense when we add cases to handle other callable types.</p>
</aside>
<p>There&rsquo;s more going on here than just initializing a new CallFrame. Because Lox
is dynamically typed, there&rsquo;s nothing to prevent a user from writing bad code
like:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">notAFunction</span> = <span class="n">123</span>;
<span class="i">notAFunction</span>();
</pre></div>
<p>If that happens, the runtime needs to safely report an error and halt. So the
first thing we do is check the type of the value that we&rsquo;re trying to call. If
it&rsquo;s not a function, we error out. Otherwise, the actual call happens here:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>peek</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">call</span>(<span class="t">ObjFunction</span>* <span class="i">function</span>, <span class="t">int</span> <span class="i">argCount</span>) {
  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span>++];
  <span class="i">frame</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="i">frame</span>-&gt;<span class="i">ip</span> = <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>;
  <span class="i">frame</span>-&gt;<span class="i">slots</span> = <span class="i">vm</span>.<span class="i">stackTop</span> - <span class="i">argCount</span> - <span class="n">1</span>;
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>peek</em>()</div>

<p>This simply initializes the next CallFrame on the stack. It stores a pointer to
the function being called and points the frame&rsquo;s <code>ip</code> to the beginning of the
function&rsquo;s bytecode. Finally, it sets up the <code>slots</code> pointer to give the frame
its window into the stack. The arithmetic there ensures that the arguments
already on the stack line up with the function&rsquo;s parameters:</p><img src="image/calls-and-functions/arithmetic.png" alt="The arithmetic to calculate frame-&gt;slots from stackTop and argCount." />
<p>The funny little <code>- 1</code> is to account for stack slot zero which the compiler set
aside for when we add methods later. The parameters start at slot one so we
make the window start one slot earlier to align them with the arguments.</p>
<p>Before we move on, let&rsquo;s add the new instruction to our disassembler.</p>
<div class="codehilite"><pre class="insert-before">      return jumpInstruction(&quot;OP_LOOP&quot;, -1, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_CALL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_CALL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>And one more quick side trip. Now that we have a handy function for initiating a
CallFrame, we may as well use it to set up the first frame for executing the
top-level code.</p>
<div class="codehilite"><pre class="insert-before">  push(OBJ_VAL(function));
</pre><div class="source-file"><em>vm.c</em><br>
in <em>interpret</em>()<br>
replace 4 lines</div>
<pre class="insert">  <span class="i">call</span>(<span class="i">function</span>, <span class="n">0</span>);
</pre><pre class="insert-after">

  return run();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 4 lines</div>

<p>OK, now back to calls<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h3><a href="#runtime-error-checking" id="runtime-error-checking"><small>24&#8202;.&#8202;5&#8202;.&#8202;2</small>Runtime error checking</a></h3>
<p>The overlapping stack windows work based on the assumption that a call passes
exactly one argument for each of the function&rsquo;s parameters. But, again, because
Lox ain&rsquo;t statically typed, a foolish user could pass too many or too few
arguments. In Lox, we&rsquo;ve defined that to be a runtime error, which we report
like so:</p>
<div class="codehilite"><pre class="insert-before">static bool call(ObjFunction* function, int argCount) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>call</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">argCount</span> != <span class="i">function</span>-&gt;<span class="i">arity</span>) {
    <span class="i">runtimeError</span>(<span class="s">&quot;Expected %d arguments but got %d.&quot;</span>,
        <span class="i">function</span>-&gt;<span class="i">arity</span>, <span class="i">argCount</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }

</pre><pre class="insert-after">  CallFrame* frame = &amp;vm.frames[vm.frameCount++];
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>call</em>()</div>

<p>Pretty straightforward. This is why we store the arity of each function inside
the ObjFunction for it.</p>
<p>There&rsquo;s another error we need to report that&rsquo;s less to do with the user&rsquo;s
foolishness than our own. Because the CallFrame array has a fixed size, we need
to ensure a deep call chain doesn&rsquo;t overflow it.</p>
<div class="codehilite"><pre class="insert-before">  }

</pre><div class="source-file"><em>vm.c</em><br>
in <em>call</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">vm</span>.<span class="i">frameCount</span> == <span class="a">FRAMES_MAX</span>) {
    <span class="i">runtimeError</span>(<span class="s">&quot;Stack overflow.&quot;</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }

</pre><pre class="insert-after">  CallFrame* frame = &amp;vm.frames[vm.frameCount++];
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>call</em>()</div>

<p>In practice, if a program gets anywhere close to this limit, there&rsquo;s most likely
a bug in some runaway recursive code.</p>
<h3><a href="#printing-stack-traces" id="printing-stack-traces"><small>24&#8202;.&#8202;5&#8202;.&#8202;3</small>Printing stack traces</a></h3>
<p>While we&rsquo;re on the subject of runtime errors, let&rsquo;s spend a little time making
them more useful. Stopping on a runtime error is important to prevent the VM
from crashing and burning in some ill-defined way. But simply aborting doesn&rsquo;t
help the user fix their code that <em>caused</em> that error.</p>
<p>The classic tool to aid debugging runtime failures is a <strong>stack trace</strong><span class="em">&mdash;</span>a
print out of each function that was still executing when the program died, and
where the execution was at the point that it died. Now that we have a call stack
and we&rsquo;ve conveniently stored each function&rsquo;s name, we can show that entire
stack when a runtime error disrupts the harmony of the user&rsquo;s existence. It
looks like this:</p>
<div class="codehilite"><pre class="insert-before">  fputs(&quot;\n&quot;, stderr);

</pre><div class="source-file"><em>vm.c</em><br>
in <em>runtimeError</em>()<br>
replace 4 lines</div>
<pre class="insert">  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">i</span>];
    <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">frame</span>-&gt;<span class="i">function</span>;
    <span class="t">size_t</span> <span class="i">instruction</span> = <span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span> - <span class="n">1</span>;
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;[line %d] in &quot;</span>,<span name="minus"> </span>
            <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">lines</span>[<span class="i">instruction</span>]);
    <span class="k">if</span> (<span class="i">function</span>-&gt;<span class="i">name</span> == <span class="a">NULL</span>) {
      <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;script</span><span class="e">\n</span><span class="s">&quot;</span>);
    } <span class="k">else</span> {
      <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;%s()</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">function</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
    }
  }

</pre><pre class="insert-after">  resetStack();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>runtimeError</em>(), replace 4 lines</div>

<aside name="minus">
<p>The <code>- 1</code> is because the IP is already sitting on the next instruction to be
executed but we want the stack trace to point to the previous failed
instruction.</p>
</aside>
<p>After printing the error message itself, we walk the call stack from <span
name="top">top</span> (the most recently called function) to bottom (the
top-level code). For each frame, we find the line number that corresponds to the
current <code>ip</code> inside that frame&rsquo;s function. Then we print that line number along
with the function name.</p>
<aside name="top">
<p>There is some disagreement on which order stack frames should be shown in a
trace. Most put the innermost function as the first line and work their way
towards the bottom of the stack. Python prints them out in the opposite order.
So reading from top to bottom tells you how your program got to where it is, and
the last line is where the error actually occurred.</p>
<p>There&rsquo;s a logic to that style. It ensures you can always see the innermost
function even if the stack trace is too long to fit on one screen. On the other
hand, the &ldquo;<a href="https://en.wikipedia.org/wiki/Inverted_pyramid_(journalism)">inverted pyramid</a>&rdquo; from journalism tells us we should put the most
important information <em>first</em> in a block of text. In a stack trace, that&rsquo;s the
function where the error actually occurred. Most other language implementations
do that.</p>
</aside>
<p>For example, if you run this broken program:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">a</span>() { <span class="i">b</span>(); }
<span class="k">fun</span> <span class="i">b</span>() { <span class="i">c</span>(); }
<span class="k">fun</span> <span class="i">c</span>() {
  <span class="i">c</span>(<span class="s">&quot;too&quot;</span>, <span class="s">&quot;many&quot;</span>);
}

<span class="i">a</span>();
</pre></div>
<p>It prints out:</p>
<div class="codehilite"><pre>Expected 0 arguments but got 2.
[line 4] in c()
[line 2] in b()
[line 1] in a()
[line 7] in script
</pre></div>
<p>That doesn&rsquo;t look too bad, does it?</p>
<h3><a href="#returning-from-functions" id="returning-from-functions"><small>24&#8202;.&#8202;5&#8202;.&#8202;4</small>Returning from functions</a></h3>
<p>We&rsquo;re getting close. We can call functions, and the VM will execute them. But we
can&rsquo;t <em>return</em> from them yet. We&rsquo;ve had an <code>OP_RETURN</code> instruction for quite
some time, but it&rsquo;s always had some kind of temporary code hanging out in it
just to get us out of the bytecode loop. The time has arrived for a real
implementation.</p>
<div class="codehilite"><pre class="insert-before">      case OP_RETURN: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">        <span class="t">Value</span> <span class="i">result</span> = <span class="i">pop</span>();
        <span class="i">vm</span>.<span class="i">frameCount</span>--;
        <span class="k">if</span> (<span class="i">vm</span>.<span class="i">frameCount</span> == <span class="n">0</span>) {
          <span class="i">pop</span>();
          <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
        }

        <span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">frame</span>-&gt;<span class="i">slots</span>;
        <span class="i">push</span>(<span class="i">result</span>);
        <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
        <span class="k">break</span>;
</pre><pre class="insert-after">      }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>When a function returns a value, that value will be on top of the stack. We&rsquo;re
about to discard the called function&rsquo;s entire stack window, so we pop that
return value off and hang on to it. Then we discard the CallFrame for the
returning function. If that was the very last CallFrame, it means we&rsquo;ve finished
executing the top-level code. The entire program is done, so we pop the main
script function from the stack and then exit the interpreter.</p>
<p>Otherwise, we discard all of the slots the callee was using for its parameters
and local variables. That includes the same slots the caller used to pass the
arguments. Now that the call is done, the caller doesn&rsquo;t need them anymore. This
means the top of the stack ends up right at the beginning of the returning
function&rsquo;s stack window.</p>
<p>We push the return value back onto the stack at that new, lower location. Then
we update the <code>run()</code> function&rsquo;s cached pointer to the current frame. Just like
when we began a call, on the next iteration of the bytecode dispatch loop, the
VM will read <code>ip</code> from that frame, and execution will jump back to the caller,
right where it left off, immediately after the <code>OP_CALL</code> instruction.</p><img src="image/calls-and-functions/return.png" alt="Each step of the return process: popping the return value, discarding the call frame, pushing the return value." />
<p>Note that we assume here that the function <em>did</em> actually return a value, but
a function can implicitly return by reaching the end of its body:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">noReturn</span>() {
  <span class="k">print</span> <span class="s">&quot;Do stuff&quot;</span>;
  <span class="c">// No return here.</span>
}

<span class="k">print</span> <span class="i">noReturn</span>(); <span class="c">// ???</span>
</pre></div>
<p>We need to handle that correctly too. The language is specified to implicitly
return <code>nil</code> in that case. To make that happen, we add this:</p>
<div class="codehilite"><pre class="insert-before">static void emitReturn() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>emitReturn</em>()</div>
<pre class="insert">  <span class="i">emitByte</span>(<span class="a">OP_NIL</span>);
</pre><pre class="insert-after">  emitByte(OP_RETURN);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>emitReturn</em>()</div>

<p>The compiler calls <code>emitReturn()</code> to write the <code>OP_RETURN</code> instruction at the
end of a function body. Now, before that, it emits an instruction to push <code>nil</code>
onto the stack. And with that, we have working function calls! They can even
take parameters! It almost looks like we know what we&rsquo;re doing here.</p>
<h2><a href="#return-statements" id="return-statements"><small>24&#8202;.&#8202;6</small>Return Statements</a></h2>
<p>If you want a function that returns something other than the implicit <code>nil</code>, you
need a <code>return</code> statement. Let&rsquo;s get that working.</p>
<div class="codehilite"><pre class="insert-before">    ifStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_RETURN</span>)) {
    <span class="i">returnStatement</span>();
</pre><pre class="insert-after">  } else if (match(TOKEN_WHILE)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>When the compiler sees a <code>return</code> keyword, it goes here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>printStatement</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">returnStatement</span>() {
  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_SEMICOLON</span>)) {
    <span class="i">emitReturn</span>();
  } <span class="k">else</span> {
    <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after return value.&quot;</span>);
    <span class="i">emitByte</span>(<span class="a">OP_RETURN</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>printStatement</em>()</div>

<p>The return value expression is optional, so the parser looks for a semicolon
token to tell if a value was provided. If there is no return value, the
statement implicitly returns <code>nil</code>. We implement that by calling <code>emitReturn()</code>,
which emits an <code>OP_NIL</code> instruction. Otherwise, we compile the return value
expression and return it with an <code>OP_RETURN</code> instruction.</p>
<p>This is the same <code>OP_RETURN</code> instruction we&rsquo;ve already implemented<span class="em">&mdash;</span>we don&rsquo;t
need any new runtime code. This is quite a difference from jlox. There, we had
to use exceptions to unwind the stack when a <code>return</code> statement was executed.
That was because you could return from deep inside some nested blocks. Since
jlox recursively walks the AST, that meant there were a bunch of Java method
calls we needed to escape out of.</p>
<p>Our bytecode compiler flattens that all out. We do recursive descent during
parsing, but at runtime, the VM&rsquo;s bytecode dispatch loop is completely flat.
There is no recursion going on at the C level at all. So returning, even from
within some nested blocks, is as straightforward as returning from the end of
the function&rsquo;s body.</p>
<p>We&rsquo;re not totally done, though. The new <code>return</code> statement gives us a new
compile error to worry about. Returns are useful for returning from functions
but the top level of a Lox program is imperative code too. You shouldn&rsquo;t be able
to <span name="worst">return</span> from there.</p>
<div class="codehilite"><pre><span class="k">return</span> <span class="s">&quot;What?!&quot;</span>;
</pre></div>
<aside name="worst">
<p>Allowing <code>return</code> at the top level isn&rsquo;t the worst idea in the world. It would
give you a natural way to terminate a script early. You could maybe even use a
returned number to indicate the process&rsquo;s exit code.</p>
</aside>
<p>We&rsquo;ve specified that it&rsquo;s a compile error to have a <code>return</code> statement outside
of any function, which we implement like so:</p>
<div class="codehilite"><pre class="insert-before">static void returnStatement() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>returnStatement</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">type</span> == <span class="a">TYPE_SCRIPT</span>) {
    <span class="i">error</span>(<span class="s">&quot;Can&#39;t return from top-level code.&quot;</span>);
  }

</pre><pre class="insert-after">  if (match(TOKEN_SEMICOLON)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>returnStatement</em>()</div>

<p>This is one of the reasons we added that FunctionType enum to the compiler.</p>
<h2><a href="#native-functions" id="native-functions"><small>24&#8202;.&#8202;7</small>Native Functions</a></h2>
<p>Our VM is getting more powerful. We&rsquo;ve got functions, calls, parameters,
returns. You can define lots of different functions that can call each other in
interesting ways. But, ultimately, they can&rsquo;t really <em>do</em> anything. The only
user-visible thing a Lox program can do, regardless of its complexity, is print.
To add more capabilities, we need to expose them to the user.</p>
<p>A programming language implementation reaches out and touches the material world
through <strong>native functions</strong>. If you want to be able to write programs that
check the time, read user input, or access the file system, we need to add
native functions<span class="em">&mdash;</span>callable from Lox but implemented in C<span class="em">&mdash;</span>that expose those
capabilities.</p>
<p>At the language level, Lox is fairly complete<span class="em">&mdash;</span>it&rsquo;s got closures, classes,
inheritance, and other fun stuff. One reason it feels like a toy language is
because it has almost no native capabilities. We could turn it into a real
language by adding a long list of them.</p>
<p>However, grinding through a pile of OS operations isn&rsquo;t actually very
educational. Once you&rsquo;ve seen how to bind one piece of C code to Lox, you get
the idea. But you do need to see <em>one</em>, and even a single native function
requires us to build out all the machinery for interfacing Lox with C. So we&rsquo;ll
go through that and do all the hard work. Then, when that&rsquo;s done, we&rsquo;ll add one
tiny native function just to prove that it works.</p>
<p>The reason we need new machinery is because, from the implementation&rsquo;s
perspective, native functions are different from Lox functions. When they are
called, they don&rsquo;t push a CallFrame, because there&rsquo;s no bytecode code for that
frame to point to. They have no bytecode chunk. Instead, they somehow reference
a piece of native C code.</p>
<p>We handle this in clox by defining native functions as an entirely different
object type.</p>
<div class="codehilite"><pre class="insert-before">} ObjFunction;
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjFunction</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="t">Value</span> (*<span class="t">NativeFn</span>)(<span class="t">int</span> <span class="i">argCount</span>, <span class="t">Value</span>* <span class="i">args</span>);

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">NativeFn</span> <span class="i">function</span>;
} <span class="t">ObjNative</span>;
</pre><pre class="insert-after">

struct ObjString {
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjFunction</em></div>

<p>The representation is simpler than ObjFunction<span class="em">&mdash;</span>merely an Obj header and a
pointer to the C function that implements the native behavior. The native
function takes the argument count and a pointer to the first argument on the
stack. It accesses the arguments through that pointer. Once it&rsquo;s done, it
returns the result value.</p>
<p>As always, a new object type carries some accoutrements with it. To create an
ObjNative, we declare a constructor-like function.</p>
<div class="codehilite"><pre class="insert-before">ObjFunction* newFunction();
</pre><div class="source-file"><em>object.h</em><br>
add after <em>newFunction</em>()</div>
<pre class="insert"><span class="t">ObjNative</span>* <span class="i">newNative</span>(<span class="t">NativeFn</span> <span class="i">function</span>);
</pre><pre class="insert-after">ObjString* takeString(char* chars, int length);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>newFunction</em>()</div>

<p>We implement that like so:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>newFunction</em>()</div>
<pre><span class="t">ObjNative</span>* <span class="i">newNative</span>(<span class="t">NativeFn</span> <span class="i">function</span>) {
  <span class="t">ObjNative</span>* <span class="i">native</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjNative</span>, <span class="a">OBJ_NATIVE</span>);
  <span class="i">native</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="k">return</span> <span class="i">native</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>newFunction</em>()</div>

<p>The constructor takes a C function pointer to wrap in an ObjNative. It sets up
the object header and stores the function. For the header, we need a new object
type.</p>
<div class="codehilite"><pre class="insert-before">typedef enum {
  OBJ_FUNCTION,
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_NATIVE</span>,
</pre><pre class="insert-after">  OBJ_STRING,
} ObjType;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>The VM also needs to know how to deallocate a native function object.</p>
<div class="codehilite"><pre class="insert-before">    }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_NATIVE</span>:
      <span class="a">FREE</span>(<span class="t">ObjNative</span>, <span class="i">object</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_STRING: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>There isn&rsquo;t much here since ObjNative doesn&rsquo;t own any extra memory. The other
capability all Lox objects support is being printed.</p>
<div class="codehilite"><pre class="insert-before">      break;
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_NATIVE</span>:
      <span class="i">printf</span>(<span class="s">&quot;&lt;native fn&gt;&quot;</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_STRING:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>In order to support dynamic typing, we have a macro to see if a value is a
native function.</p>
<div class="codehilite"><pre class="insert-before">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_NATIVE(value)       isObjType(value, OBJ_NATIVE)</span>
</pre><pre class="insert-after">#define IS_STRING(value)       isObjType(value, OBJ_STRING)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Assuming that returns true, this macro extracts the C function pointer from a
Value representing a native function:</p>
<div class="codehilite"><pre class="insert-before">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_NATIVE(value) \</span>
<span class="a">    (((ObjNative*)AS_OBJ(value))-&gt;function)</span>
</pre><pre class="insert-after">#define AS_STRING(value)       ((ObjString*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>All of this baggage lets the VM treat native functions like any other object.
You can store them in variables, pass them around, throw them birthday parties,
etc. Of course, the operation we actually care about is <em>calling</em> them<span class="em">&mdash;</span>using
one as the left-hand operand in a call expression.</p>
<p>Over in <code>callValue()</code> we add another type case.</p>
<div class="codehilite"><pre class="insert-before">      case OBJ_FUNCTION:<span name="switch"> </span>
        return call(AS_FUNCTION(callee), argCount);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OBJ_NATIVE</span>: {
        <span class="t">NativeFn</span> <span class="i">native</span> = <span class="a">AS_NATIVE</span>(<span class="i">callee</span>);
        <span class="t">Value</span> <span class="i">result</span> = <span class="i">native</span>(<span class="i">argCount</span>, <span class="i">vm</span>.<span class="i">stackTop</span> - <span class="i">argCount</span>);
        <span class="i">vm</span>.<span class="i">stackTop</span> -= <span class="i">argCount</span> + <span class="n">1</span>;
        <span class="i">push</span>(<span class="i">result</span>);
        <span class="k">return</span> <span class="k">true</span>;
      }
</pre><pre class="insert-after">      default:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>

<p>If the object being called is a native function, we invoke the C function right
then and there. There&rsquo;s no need to muck with CallFrames or anything. We just
hand off to C, get the result, and stuff it back in the stack. This makes native
functions as fast as we can get.</p>
<p>With this, users should be able to call native functions, but there aren&rsquo;t any
to call. Without something like a foreign function interface, users can&rsquo;t define
their own native functions. That&rsquo;s our job as VM implementers. We&rsquo;ll start with
a helper to define a new native function exposed to Lox programs.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>runtimeError</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">defineNative</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">NativeFn</span> <span class="i">function</span>) {
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">copyString</span>(<span class="i">name</span>, (<span class="t">int</span>)<span class="i">strlen</span>(<span class="i">name</span>))));
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">newNative</span>(<span class="i">function</span>)));
  <span class="i">tableSet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="a">AS_STRING</span>(<span class="i">vm</span>.<span class="i">stack</span>[<span class="n">0</span>]), <span class="i">vm</span>.<span class="i">stack</span>[<span class="n">1</span>]);
  <span class="i">pop</span>();
  <span class="i">pop</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>runtimeError</em>()</div>

<p>It takes a pointer to a C function and the name it will be known as in Lox.
We wrap the function in an ObjNative and then store that in a global variable
with the given name.</p>
<p>You&rsquo;re probably wondering why we push and pop the name and function on the
stack. That looks weird, right? This is the kind of stuff you have to worry
about when <span name="worry">garbage</span> collection gets involved. Both
<code>copyString()</code> and <code>newNative()</code> dynamically allocate memory. That means once we
have a GC, they can potentially trigger a collection. If that happens, we need
to ensure the collector knows we&rsquo;re not done with the name and ObjFunction so
that it doesn&rsquo;t free them out from under us. Storing them on the value stack
accomplishes that.</p>
<aside name="worry">
<p>Don&rsquo;t worry if you didn&rsquo;t follow all that. It will make a lot more sense once we
get around to <a href="garbage-collection.html">implementing the GC</a>.</p>
</aside>
<p>It feels silly, but after all of that work, we&rsquo;re going to add only one
little native function.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after variable <em>vm</em></div>
<pre><span class="k">static</span> <span class="t">Value</span> <span class="i">clockNative</span>(<span class="t">int</span> <span class="i">argCount</span>, <span class="t">Value</span>* <span class="i">args</span>) {
  <span class="k">return</span> <span class="a">NUMBER_VAL</span>((<span class="t">double</span>)<span class="i">clock</span>() / <span class="a">CLOCKS_PER_SEC</span>);
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after variable <em>vm</em></div>

<p>This returns the elapsed time since the program started running, in seconds. It&rsquo;s
handy for benchmarking Lox programs. In Lox, we&rsquo;ll name it <code>clock()</code>.</p>
<div class="codehilite"><pre class="insert-before">  initTable(&amp;vm.strings);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">

  <span class="i">defineNative</span>(<span class="s">&quot;clock&quot;</span>, <span class="i">clockNative</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>To get to the C standard library <code>clock()</code> function, the &ldquo;vm&rdquo; module needs an
include.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;string.h&gt;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert"><span class="a">#include &lt;time.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>

<p>That was a lot of material to work through, but we did it! Type this in and try
it out:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">fib</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> &lt; <span class="n">2</span>) <span class="k">return</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">fib</span>(<span class="i">n</span> - <span class="n">2</span>) + <span class="i">fib</span>(<span class="i">n</span> - <span class="n">1</span>);
}

<span class="k">var</span> <span class="i">start</span> = <span class="i">clock</span>();
<span class="k">print</span> <span class="i">fib</span>(<span class="n">35</span>);
<span class="k">print</span> <span class="i">clock</span>() - <span class="i">start</span>;
</pre></div>
<p>We can write a really inefficient recursive Fibonacci function. Even better, we
can measure just <span name="faster"><em>how</em></span> inefficient it is. This is, of
course, not the smartest way to calculate a Fibonacci number. But it is a good
way to stress test a language implementation&rsquo;s support for function calls. On my
machine, running this in clox is about five times faster than in jlox. That&rsquo;s
quite an improvement.</p>
<aside name="faster">
<p>It&rsquo;s a little slower than a comparable Ruby program run in Ruby 2.4.3p205, and
about 3x faster than one run in Python 3.7.3. And we still have a lot of simple
optimizations we can do in our VM.</p>
</aside>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Reading and writing the <code>ip</code> field is one of the most frequent operations
inside the bytecode loop. Right now, we access it through a pointer to the
current CallFrame. That requires a pointer indirection which may force the
CPU to bypass the cache and hit main memory. That can be a real performance
sink.</p>
<p>Ideally, we&rsquo;d keep the <code>ip</code> in a native CPU register. C doesn&rsquo;t let us
<em>require</em> that without dropping into inline assembly, but we can structure
the code to encourage the compiler to make that optimization. If we store
the <code>ip</code> directly in a C local variable and mark it <code>register</code>, there&rsquo;s a
good chance the C compiler will accede to our polite request.</p>
<p>This does mean we need to be careful to load and store the local <code>ip</code> back
into the correct CallFrame when starting and ending function calls.
Implement this optimization. Write a couple of benchmarks and see how it
affects the performance. Do you think the extra code complexity is worth it?</p>
</li>
<li>
<p>Native function calls are fast in part because we don&rsquo;t validate that the
call passes as many arguments as the function expects. We really should, or
an incorrect call to a native function without enough arguments could cause
the function to read uninitialized memory. Add arity checking.</p>
</li>
<li>
<p>Right now, there&rsquo;s no way for a native function to signal a runtime error.
In a real implementation, this is something we&rsquo;d need to support because
native functions live in the statically typed world of C but are called
from dynamically typed Lox land. If a user, say, tries to pass a string to
<code>sqrt()</code>, that native function needs to report a runtime error.</p>
<p>Extend the native function system to support that. How does this capability
affect the performance of native calls?</p>
</li>
<li>
<p>Add some more native functions to do things you find useful. Write some
programs using those. What did you add? How do they affect the feel of the
language and how practical it is?</p>
</li>
</ol>
</div>

<footer>
<a href="closures.html" class="next">
  Next Chapter: &ldquo;Closures&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
