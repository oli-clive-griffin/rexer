diff --git a/demo/input.risp b/demo/input.risp
index e51baaa..ca9804a 100644
--- a/demo/input.risp
+++ b/demo/input.risp
@@ -1,13 +1,13 @@
 (let
     (l (list 1 2 3))
     (fold
-        (fn (f list)
+        (lambda (f list)
             (let
-                (inner (fn (ilist acc)
+                (inner (lambda (ilist acc)
                             (if (empty? ilist)
                                 acc
                                 (inner
                                     (cdr ilist)
-                                    (f acc (first ilist))))))
-                (inner (cdr list) (first list)))))
+                                    (f acc (car ilist))))))
+                (inner (cdr list) (car list)))))
     (fold + l))
diff --git a/demo/prelude.risp b/demo/prelude.risp
deleted file mode 100644
index e69de29..0000000
diff --git a/src/builtins.rs b/src/builtins.rs
index 17e2df5..bfa29fa 100644
--- a/src/builtins.rs
+++ b/src/builtins.rs
@@ -1,150 +1,163 @@
-use std::str;
-
-use crate::runtime_value::RuntimeValue;
+use crate::parser::Sexpr;
 
 #[derive(Debug, Clone, PartialEq)]
-pub struct RustFunc(fn(&[RuntimeValue]) -> RuntimeValue);
+pub struct BuiltIn {
+    // pub name: &'static str,
+    pub symbol: &'static str,
+    eval: fn(&[Sexpr]) -> Sexpr,
+}
 
-impl RustFunc {
-    pub fn eval(&self, args: &[RuntimeValue]) -> RuntimeValue {
-        (self.0)(args)
+impl BuiltIn {
+    pub fn eval(&self, args: &[Sexpr]) -> Sexpr {
+        (self.eval)(args)
     }
 }
 
-const LIST: RustFunc = RustFunc(|args| RuntimeValue::List(args.to_vec()));
+const LIST: BuiltIn = BuiltIn {
+    symbol: "list",
+    eval: |args| Sexpr::List(args.to_vec()),
+};
 
-const CONS: RustFunc = RustFunc(|args| {
-    if args.len() != 2 {
-        panic!("cons must be called with two arguments");
-    }
-    match &args[1] {
-        RuntimeValue::List(list) => {
-            let mut new = list.clone();
-            new.insert(0, args[0].clone());
-            RuntimeValue::List(new)
+const CONS: BuiltIn = BuiltIn {
+    symbol: "cons",
+    eval: |args| {
+        if args.len() != 2 {
+            panic!("cons must be called with two arguments");
         }
-        _ => panic!("cons must be called with a list as the second argument"),
-    }
-});
-
-const CAR: RustFunc = RustFunc(|args| {
-    if args.len() != 1 {
-        panic!("car must be called with one argument");
-    }
-    match &args[0] {
-        RuntimeValue::List(list) => list[0].clone(),
-        _ => panic!("car must be called with a list as the first argument"),
-    }
-});
-
-const CDR: RustFunc = RustFunc(|args| {
-    if args.len() != 1 {
-        panic!("cdr must be called with one argument");
-    }
-    match &args[0] {
-        RuntimeValue::List(list) => {
-            let mut new = list.clone();
-            new.remove(0);
-            RuntimeValue::List(new)
+        match &args[1] {
+            Sexpr::List(list) => {
+                let mut new = list.clone();
+                new.insert(0, args[0].clone());
+                Sexpr::List(new)
+            }
+            _ => panic!("cons must be called with a list as the second argument"),
         }
-        _ => panic!("cdr must be called with a list as the first argument"),
-    }
-});
-
-const FIRST: RustFunc = RustFunc(|args| {
-    if args.len() != 1 {
-        panic!("first must be called with one argument");
-    };
-    match &args[0] {
-        RuntimeValue::List(list) => list[0].clone(),
-        _ => panic!("first must be called with a list as the first argument"),
-    }
-});
-
-const LAST: RustFunc = RustFunc(|args| {
-    if args.len() != 1 {
-        panic!("first must be called with one argument");
-    };
-    match &args[0] {
-        RuntimeValue::List(list) => list.last().unwrap().clone(),
-        _ => panic!("first must be called with a list as the first argument"),
-    }
-});
-
-const EMPTYP: RustFunc = RustFunc(|args| {
-    if args.len() != 1 {
-        panic!("emptyp must be called with one argument");
-    };
-    match &args[0] {
-        RuntimeValue::List(list) => RuntimeValue::Boolean(list.is_empty()),
-        _ => panic!("emptyp must be called with a list as the first argument"),
-    }
-});
+    },
+};
+
+const CAR: BuiltIn = BuiltIn {
+    symbol: "car",
+    eval: |args| {
+        if args.len() != 1 {
+            panic!("car must be called with one argument");
+        }
+        match &args[0] {
+            Sexpr::List(list) => list[0].clone(),
+            _ => panic!("car must be called with a list as the first argument"),
+        }
+    },
+};
+
+const CDR: BuiltIn = BuiltIn {
+    symbol: "cdr",
+    eval: |args| {
+        if args.len() != 1 {
+            panic!("cdr must be called with one argument, got {}", args.len());
+        }
+        match &args[0] {
+            Sexpr::List(list) => {
+                let mut new = list.clone();
+                new.remove(0);
+                Sexpr::List(new)
+            }
+            _ => panic!("cdr must be called with a list as the first argument"),
+        }
+    },
+};
+
+const ADD: BuiltIn = BuiltIn {
+    symbol: "+",
+    eval: |args| {
+        let out = args.iter().fold(0, |acc, x| match x {
+            Sexpr::Int(i) => acc + i,
+            // Sexpr::Float(i) => acc as f64 + i,
+            _ => panic!("add must be called with a list of integers"),
+        });
+        Sexpr::Int(out)
+    },
+};
+
+const SUB: BuiltIn = BuiltIn {
+    symbol: "-",
+    eval: |args| {
+        let mut init = match args[0] {
+            Sexpr::Int(i) => i,
+            // Sexpr::Float(i) => i as f64,
+            _ => panic!("sub must be called with a list of integers"),
+        };
+        for i in 1..args.len() {
+            match args[i] {
+                Sexpr::Int(j) => init -= j,
+                // Sexpr::Float(j) => init -= j as f64,
+                _ => panic!("sub must be called with a list of integers"),
+            }
+        }
+        Sexpr::Int(init)
+    },
+};
+
+const MUL: BuiltIn = BuiltIn {
+    symbol: "*",
+    eval: |args| {
+        let out = args.iter().fold(1, |acc, x| match x {
+            Sexpr::Int(i) => acc * i,
+            // Sexpr::Float(i) => acc as f64 * i,
+            _ => panic!("mul must be called with a list of integers"),
+        });
+        Sexpr::Int(out)
+    },
+};
+
+const DIV: BuiltIn = BuiltIn {
+    symbol: "/",
+    eval: |args| {
+        let mut init = match args[0] {
+            Sexpr::Int(i) => i,
+            // Sexpr::Float(i) => i as f64,
+            _ => panic!("div must be called with a list of integers"),
+        };
+        for i in 1..args.len() {
+            match args[i] {
+                Sexpr::Int(j) => init /= j,
+                // Sexpr::Float(j) => init /= j as f64,
+                _ => panic!("div must be called with a list of integers"),
+            }
+        }
+        Sexpr::Int(init)
+    },
+};
+
+const EMPTY: BuiltIn = BuiltIn {
+    symbol: "empty?",
+    eval: |args| {
+        if args.len() != 1 {
+            panic!("empty must be called with one argument");
+        }
+        match &args[0] {
+            Sexpr::List(list) => Sexpr::Bool(list.is_empty()),
+            _ => panic!("empty must be called with a list as the first argument"),
+        }
+    },
+};
 
-pub const BUILTINTS: [(&str, RustFunc); 7] = [
-    ("cons", CONS),
-    ("car", CAR),
-    ("cdr", CDR),
-    ("list", LIST),
-    ("first", FIRST),
-    ("last", LAST),
-    ("empty?", EMPTYP),
-];
+pub const BUILTINTS: [BuiltIn; 9] = [CONS, CAR, CDR, LIST, EMPTY, ADD, SUB, MUL, DIV];
 
 #[cfg(test)]
 mod tests {
     use super::*;
 
-    #[test]
-    fn test_cdr() {
-        let args = vec![RuntimeValue::List(vec![
-            RuntimeValue::Int(1),
-            RuntimeValue::Int(2),
-        ])];
-        assert_eq!(
-            CDR.eval(&args),
-            RuntimeValue::List(vec![RuntimeValue::Int(2),])
-        );
-    }
-
-    #[test]
-    fn test_car() {
-        let args = vec![RuntimeValue::List(vec![
-            RuntimeValue::Int(1),
-            RuntimeValue::Int(2),
-        ])];
-        assert_eq!(CAR.eval(&args), RuntimeValue::Int(1),);
-    }
-
     #[test]
     fn test_cons() {
         let args = vec![
-            RuntimeValue::Int(1),
-            RuntimeValue::List(vec![RuntimeValue::Int(2), RuntimeValue::Int(3)]),
+            Sexpr::Int(1),
+            Sexpr::List(vec![Sexpr::Int(2), Sexpr::Int(3)]),
         ];
         assert_eq!(
             CONS.eval(&args),
-            RuntimeValue::List(vec![
-                RuntimeValue::Int(1),
-                RuntimeValue::Int(2),
-                RuntimeValue::Int(3),
-            ])
-        );
-    }
-
-    #[test]
-    fn test_list() {
-        let args = vec![
-            RuntimeValue::Int(1),
-            RuntimeValue::Int(2),
-            RuntimeValue::Int(3),
-        ];
-        assert_eq!(
-            LIST.eval(&args),
-            RuntimeValue::List(vec![
-                RuntimeValue::Int(1),
-                RuntimeValue::Int(2),
-                RuntimeValue::Int(3),
+            Sexpr::List(vec![
+                Sexpr::Int(1),
+                Sexpr::Int(2),
+                Sexpr::Int(3),
             ])
         );
     }
diff --git a/src/evaluator.rs b/src/evaluator.rs
index 3313b6b..58601c9 100644
--- a/src/evaluator.rs
+++ b/src/evaluator.rs
@@ -1,249 +1,328 @@
 use core::panic;
 use std::collections::HashMap;
+use std::iter;
 
 use crate::builtins::BUILTINTS;
-use crate::lexer::{Literal, NumericLiteral, Operator};
-use crate::parser::Node;
-use crate::runtime_value::Function;
-use crate::runtime_value::RuntimeValue;
-use crate::structural_parser::{Form, SpecialForm, StructuredNode};
+use crate::parser::{Ast, Sexpr};
 
+#[derive(Debug, Clone, PartialEq)]
 struct Scope {
     // could make this a list of hashmaps that's search from the top down
     // would negate the need to duplicate the scope when adding items
-    bindings: HashMap<String, RuntimeValue>,
+    bindings: HashMap<String, Sexpr>,
 }
 
 impl Scope {
     fn new() -> Scope {
         Scope {
             bindings: HashMap::from_iter(
-                BUILTINTS.map(|(name, builtin)| (name.to_owned(), RuntimeValue::BuiltIn(builtin))),
+                BUILTINTS.map(|builtin| (builtin.symbol.to_string(), Sexpr::BuiltIn(builtin))),
             ),
         }
     }
 
-    fn with_bindings(&self, bindings: Vec<(String, RuntimeValue)>) -> Scope {
+    fn with_bindings(&self, bindings: &[(String, Sexpr)]) -> Scope {
         let mut new_bindings = self.bindings.clone();
-        new_bindings.extend(bindings);
+        new_bindings.extend(bindings.iter().cloned());
+
         Scope {
             bindings: new_bindings,
         }
     }
 }
 
-impl Function {
-    fn eval(self, args: &[RuntimeValue], scope: &Scope) -> RuntimeValue {
-        if self.params.len() != args.len() {
-            panic!("Function called with incorrect number of arguments");
+impl Sexpr {
+    fn eval(self, scope: &Scope) -> Sexpr {
+        match self {
+            Sexpr::List(list) => eval_list(list, scope),
+            Sexpr::Symbol(sym) => scope
+                .bindings
+                .get(&sym)
+                .unwrap_or_else(|| panic!("Symbol not found in scope: {}", sym))
+                .clone(),
+            Sexpr::String(_)
+            | Sexpr::Bool(_)
+            | Sexpr::Int(_)
+            | Sexpr::Float(_)
+            | Sexpr::Lambda {
+                parameters: _,
+                body: _,
+            }
+            | Sexpr::Macro {
+                parameters: _,
+                body: _,
+            }
+            | Sexpr::BuiltIn(_) => self,
         }
-
-        // zip the args and params together
-        let bindings = self
-            .params
-            .iter()
-            .cloned()
-            .zip(args.iter().cloned())
-            .collect::<Vec<(String, RuntimeValue)>>();
-
-        self.body.eval(&scope.with_bindings(bindings))
     }
 }
 
-impl RuntimeValue {
-    fn from_literal(lit: Literal) -> RuntimeValue {
-        match lit {
-            Literal::Numeric(n) => match n {
-                NumericLiteral::Int(i) => RuntimeValue::Int(i),
-                NumericLiteral::Float(f) => RuntimeValue::Float(f),
-            },
-            Literal::String(s) => RuntimeValue::String(s),
-            Literal::Boolean(b) => RuntimeValue::Boolean(b),
+fn eval_list(list: Vec<Sexpr>, scope: &Scope) -> Sexpr {
+    match &list[0] {
+        // handle special forms:
+        Sexpr::Symbol(symbol) => match symbol.as_str() {
+            "lambda" => eval_rest_as_function_declaration(&list[1..], scope),
+            "macro" => eval_rest_as_macro_declaration(&list[1..], scope),
+            "if" => eval_rest_as_if(&list[1..], scope),
+            "let" => eval_rest_as_let(&list[1..], scope),
+            "quote" => eval_rest_as_quote(&list[1..]),
+            _ => {
+                let head = list[0].clone().eval(scope);
+                eval_list(
+                    iter::once(head)
+                        .chain(list[1..].iter().cloned())
+                        .collect::<Vec<Sexpr>>(),
+                    scope,
+                )
+            }
+        },
+        Sexpr::Lambda { parameters, body } => {
+            let arguments = list[1..]
+                .iter()
+                .cloned()
+                .map(|arg| arg.eval(scope))
+                .collect::<Vec<Sexpr>>();
+
+            if parameters.len() != arguments.len() {
+                panic!("Function called with incorrect number of arguments");
+            }
+
+            // zip the args and params together
+            let bindings = (*parameters)
+                .iter()
+                .cloned()
+                .zip(arguments.iter().cloned())
+                .collect::<Vec<(String, Sexpr)>>();
+
+            let func_scope = scope.with_bindings(&bindings);
+            body.clone().eval(&func_scope)
         }
-    }
-}
+        Sexpr::Macro { parameters, body } => {
+            // DON'T EVALUATE THE MACRO BODY
+            let arguments = &list[1..];
 
-impl Operator {
-    fn eval(&self, args: &[RuntimeValue]) -> RuntimeValue {
-        args.iter()
-            .cloned()
-            .reduce(|acc, val| self.binary(acc, val))
-            .unwrap()
-    }
+            if parameters.len() != arguments.len() {
+                panic!("Macro called with incorrect number of arguments");
+            }
 
-    fn binary(&self, a: RuntimeValue, b: RuntimeValue) -> RuntimeValue {
-        match self {
-            Operator::Add => a + b,
-            Operator::Div => a / b,
-            Operator::Mul => a * b,
-            Operator::Sub => a - b,
+            // zip the args and params together
+            let bindings = parameters
+                .iter()
+                .cloned()
+                .zip(arguments.iter().cloned())
+                .collect::<Vec<(String, Sexpr)>>();
+
+            let macro_scope = scope.with_bindings(&bindings);
+            body.clone().eval(&macro_scope).eval(scope)
+        }
+        Sexpr::List(list) => eval_list(
+            iter::once(list[0].clone().eval(scope))
+                .chain(list[1..].iter().cloned())
+                .collect::<Vec<Sexpr>>(),
+            scope,
+        ),
+        Sexpr::String(_) => panic!("Cannot call string value"),
+        Sexpr::Bool(_) => panic!("Cannot call boolean value"),
+        Sexpr::Int(_) => panic!("Cannot call int value"),
+        Sexpr::Float(_) => panic!("Cannot call float value"),
+        Sexpr::BuiltIn(builtin) => {
+            let arguments = list[1..]
+                .iter()
+                .cloned()
+                .map(|arg| arg.eval(scope))
+                .collect::<Vec<Sexpr>>();
+            builtin.eval(&arguments)
         }
     }
 }
 
-impl StructuredNode {
-    fn eval(self, scope: &Scope) -> RuntimeValue {
-        match self {
-            StructuredNode::Form(form) => form.eval(scope),
-            StructuredNode::Ident(ident) => scope
-                .bindings
-                .get(&ident)
-                .unwrap_or_else(|| panic!("Identifier {ident} not found in scope"))
-                .clone(),
-            StructuredNode::Literal(lit) => RuntimeValue::from_literal(lit),
-            StructuredNode::Op(op) => RuntimeValue::Op(op),
-        }
+fn eval_rest_as_function_declaration(rest: &[Sexpr], scope: &Scope) -> Sexpr {
+    let args = parse_as_args(&rest[0]);
+    let fn_body = &rest[1];
+
+    // TODO closues ???
+    // substitute scope into fn_body ???
+    // actually should be easy as everything is pure and passed by value
+    let _ = scope;
+
+    Sexpr::Lambda {
+        parameters: args,
+        body: Box::new(fn_body.clone()),
     }
 }
 
-impl SpecialForm {
-    fn eval(self, scope: &Scope) -> RuntimeValue {
-        match self {
-            SpecialForm::Fn(form) => {
-                // form.args
-                // let args = parse_as_args(&form.args);
-                // let fn_body = &form.body;
-
-                // todo substitute scope into fn_body
-                // let _ = scope;
-
-                RuntimeValue::Function(Function {
-                    params: form.args,
-                    body: *form.body,
-                })
-            }
-            SpecialForm::If(form) => {
-                if form.condition.eval(scope).bool() {
-                    form.if_body.eval(scope)
-                } else {
-                    form.else_body.eval(scope)
-                }
-            }
-            SpecialForm::Let(form) => {
-                let bindings = form_let_bindings(&form.bindings, scope);
-                form.expr.eval(&scope.with_bindings(bindings))
-            }
-            SpecialForm::Quote(form) => quote(form.expr),
-        }
+fn eval_rest_as_macro_declaration(rest: &[Sexpr], scope: &Scope) -> Sexpr {
+    let args = parse_as_args(&rest[0]);
+    let fn_body = &rest[1];
+
+    // todo substitute scope into fn_body
+    let _ = scope;
+
+    Sexpr::Macro {
+        parameters: args,
+        body: Box::new(fn_body.clone()),
     }
 }
 
-impl Form {
-    fn eval(self, scope: &Scope) -> RuntimeValue {
-        match self {
-            Form::Special(form) => form.eval(scope),
-            Form::Regular(node) => eval_normal_form(node, scope),
-        }
+fn eval_rest_as_let(rest: &[Sexpr], scope: &Scope) -> Sexpr {
+    let binding_exprs = rest[..rest.len() - 1].to_vec();
+    let expr = rest.last().expect("let must have a body");
+    let bindings = generate_let_bindings(binding_exprs, scope);
+    expr.clone().eval(&scope.with_bindings(&bindings))
+}
+
+fn eval_rest_as_if(rest: &[Sexpr], scope: &Scope) -> Sexpr {
+    if rest.len() != 3 {
+        panic!("malformed if statement: Must have 3 arguments");
+    }
+    let condition = rest[0].clone();
+    let if_body = rest[1].clone();
+    let else_body = rest[2].clone();
+
+    // TODO: encapse this is Sexpr.bool()
+    if let Sexpr::Bool(cond) = condition.eval(scope) {
+        (if cond { if_body } else { else_body }).eval(scope)
+    } else {
+        panic!("If condition must be a boolean");
     }
 }
 
-fn eval_normal_form(list: Vec<StructuredNode>, scope: &Scope) -> RuntimeValue {
-    let vals = list
-        .iter()
-        .map(|arg| arg.clone().eval(scope))
-        .collect::<Vec<RuntimeValue>>();
-
-    let head_val = vals[0].clone();
-    let args_vals = &vals[1..];
-
-    match head_val {
-        RuntimeValue::Op(op) => op.eval(args_vals),
-        RuntimeValue::BuiltIn(builtin) => builtin.eval(args_vals),
-        RuntimeValue::Function(func) => func.clone().eval(args_vals, scope),
-        RuntimeValue::Int(_) => panic!("Cannot call int value. list: {:?}", list),
-        RuntimeValue::List(_) => panic!("Cannot call list value"),
-        RuntimeValue::Float(_) => panic!("Cannot call float value"),
-        RuntimeValue::String(_) => panic!("Cannot call string value"),
-        RuntimeValue::Boolean(_) => panic!("Cannot call boolean value"),
-        RuntimeValue::Symbol(_) => panic!("Cannot call symbol value"),
+/// takes a list of nodes of the form (Node::Quote, Node::List(..))
+/// returns a list of the evaulat
+fn eval_rest_as_quote(list: &[Sexpr]) -> Sexpr {
+    if list.len() != 1 {
+        panic!("quote must be called with one argument");
     }
+    quote(list[0].clone())
 }
 
-fn quote(node: Node) -> RuntimeValue {
+fn quote(node: Sexpr) -> Sexpr {
     match node {
-        Node::Ident(ident) => RuntimeValue::Symbol(ident.clone()),
-        Node::Literal(lit) => RuntimeValue::from_literal(lit),
-        Node::Op(op) => RuntimeValue::Op(op),
-        Node::List(node_list) => RuntimeValue::List(node_list.iter().cloned().map(quote).collect()),
-        Node::Fn => todo!("not sure how we should handle quoting `Node::Fn`"),
-        Node::If => todo!("not sure how we should handle quoting `Node::If`"),
-        Node::Let => todo!("not sure how we should handle quoting `Node::Let`"),
-        Node::Quote => todo!("not sure how we should handle quoting `Node::Quote`"),
+        Sexpr::List(list) => Sexpr::List(list.iter().map(|node| quote(node.clone())).collect()),
+        Sexpr::Lambda {
+            parameters: _,
+            body: _,
+        } => {
+            panic!("this shouldn't happen (quoting a Lambda value)")
+        }
+        Sexpr::Macro {
+            parameters: _,
+            body: _,
+        } => {
+            panic!("this shouldn't happen (quoting a Macro value)")
+        }
+        Sexpr::BuiltIn(_) => {
+            panic!("this shouldn't happen (quoting a BuiltIn value)")
+        }
+        Sexpr::Symbol(_) | Sexpr::String(_) | Sexpr::Bool(_) | Sexpr::Int(_) | Sexpr::Float(_) => {
+            node
+        }
     }
 }
 
-fn form_let_bindings(
-    list: &[(String, StructuredNode)],
-    scope: &Scope,
-) -> Vec<(String, RuntimeValue)> {
+fn generate_let_bindings(list: Vec<Sexpr>, scope: &Scope) -> Vec<(String, Sexpr)> {
     list.iter()
         .cloned()
-        .map(|(name, expr)| (name, expr.eval(scope)))
-        .collect::<Vec<(String, RuntimeValue)>>()
+        .map(|node| match node {
+            Sexpr::List(nodes) => {
+                if nodes.len() != 2 {
+                    panic!("let binding must be a list of two elements");
+                }
+                if let Sexpr::Symbol(ident) = &nodes[0] {
+                    let val = nodes[1].clone().eval(scope);
+                    (ident.clone(), val.clone())
+                } else {
+                    panic!("left side of let binding must be an identifier");
+                }
+            }
+            _ => panic!("All bindings must be lists"),
+        })
+        .collect::<Vec<(String, Sexpr)>>()
+}
+
+fn parse_as_args(expr: &Sexpr) -> Vec<String> {
+    if let Sexpr::List(args) = expr {
+        args.iter()
+            .map(|e| {
+                if let Sexpr::Symbol(ident) = e {
+                    ident.clone()
+                } else {
+                    panic!("Function arguments must be identifiers")
+                }
+            })
+            .collect::<Vec<String>>()
+    } else {
+        panic!("Function arguments must be a list")
+    }
 }
 
 /// for now, assume that the AST is a single SExpr
 /// and just evaluate it.
 /// Obvious next steps are to allow for multiple SExprs (lines)
 /// and to manage a global scope being passed between them.
-pub fn evaluate(ast: StructuredNode) {
-    println!("{:#?}", ast.eval(&Scope::new()));
+pub fn evaluate(ast: Ast) {
+    println!("{:#?}", ast.root.eval(&Scope::new()));
 }
 
 #[cfg(test)]
 mod tests {
-    use crate::structural_parser::structure_ast;
-
     use super::*;
 
     #[test]
     fn test1() {
-        let ast = structure_ast(Node::List(vec![
-            Node::Op(Operator::Add),
-            Node::Literal(Literal::Numeric(NumericLiteral::Int(1))),
-            Node::Literal(Literal::Numeric(NumericLiteral::Int(2))),
-        ]));
-        let output = ast.eval(&Scope::new());
-        assert_eq!(output, RuntimeValue::Int(3));
+        let ast = Ast {
+            root: Sexpr::List(vec![
+                Sexpr::Symbol("+".to_string()),
+                Sexpr::Int(1),
+                Sexpr::Int(2),
+            ]),
+        };
+        let output = ast.root.eval(&Scope::new());
+        assert_eq!(output, Sexpr::Int(3));
     }
 
     #[test]
     fn test2() {
-        let ast = structure_ast(Node::List(vec![
-            Node::Op(Operator::Add),
-            Node::Literal(Literal::Numeric(NumericLiteral::Int(1))),
-            Node::Literal(Literal::Numeric(NumericLiteral::Int(2))),
-            Node::List(vec![
-                Node::Op(Operator::Sub),
-                Node::Literal(Literal::Numeric(NumericLiteral::Int(4))),
-                Node::Literal(Literal::Numeric(NumericLiteral::Int(3))),
-            ]),
-            Node::Literal(Literal::Numeric(NumericLiteral::Int(5))),
-            Node::List(vec![
-                Node::Op(Operator::Mul),
-                Node::Literal(Literal::Numeric(NumericLiteral::Int(1))),
-                Node::Literal(Literal::Numeric(NumericLiteral::Float(2.3))),
+        let ast = Ast {
+            root: Sexpr::List(vec![
+                Sexpr::Symbol("+".to_string()),
+                Sexpr::Int(1),
+                Sexpr::Int(2),
+                Sexpr::List(vec![
+                    Sexpr::Symbol("-".to_string()),
+                    Sexpr::Int(4),
+                    Sexpr::Int(3),
+                ]),
+                Sexpr::Int(5),
+                Sexpr::List(vec![
+                    Sexpr::Symbol("*".to_string()),
+                    Sexpr::Int(1),
+                    // Sexpr::Float(2.3),
+                    Sexpr::Int(2),
+                ]),
             ]),
-        ]));
-        let res = ast.eval(&Scope::new());
-        assert_eq!(res, RuntimeValue::Float(11.3))
+        };
+        let res = ast.root.eval(&Scope::new());
+        assert_eq!(res, Sexpr::Int(11))
     }
 
     #[test]
     fn test3() {
-        let ast = structure_ast(Node::List(vec![
-            Node::Let,
-            Node::List(vec![
-                Node::Ident("x".to_owned()),
-                Node::Literal(Literal::Numeric(NumericLiteral::Int(2))),
-            ]),
-            Node::List(vec![
-                Node::Op(Operator::Mul),
-                Node::Ident("x".to_owned()),
-                Node::Literal(Literal::Numeric(NumericLiteral::Int(3))),
+        let ast = Ast {
+            root: Sexpr::List(vec![
+                Sexpr::Symbol("let".to_string()),
+                Sexpr::List(vec![
+                    Sexpr::Symbol("x".to_string()),
+                    Sexpr::Int(2),
+                ]),
+                Sexpr::List(vec![
+                    Sexpr::Symbol("*".to_string()),
+                    Sexpr::Symbol("x".to_string()),
+                    Sexpr::Int(3),
+                ]),
             ]),
-        ]));
-        let res = ast.eval(&Scope::new());
-        assert_eq!(res, RuntimeValue::Int(6))
+        };
+        let res = ast.root.eval(&Scope::new());
+        assert_eq!(res, Sexpr::Int(6))
     }
 }
diff --git a/src/lexer.rs b/src/lexer.rs
index b12208b..4788448 100644
--- a/src/lexer.rs
+++ b/src/lexer.rs
@@ -4,13 +4,13 @@ pub enum LR {
     Right,
 }
 
-#[derive(Debug, PartialEq, Clone, Copy)]
-pub enum Operator {
-    Add,
-    Sub,
-    Mul,
-    Div,
-}
+// #[derive(Debug, PartialEq, Clone, Copy)]
+// pub enum Operator {
+//     Add,
+//     Sub,
+//     Mul,
+//     Div,
+// }
 
 #[derive(Debug, PartialEq, Clone, Copy)]
 pub enum NumericLiteral {
@@ -28,18 +28,18 @@ pub enum Literal {
 #[derive(Debug, PartialEq)]
 pub enum Token {
     Parenthesis(LR),
-    Operator(Operator),
+    // Operator(Operator),
     Literal(Literal),
-    Identifier(String),
+    Symbol(String),
     Comma,
 }
 
 impl Token {
-    fn from_string(s: &String) -> Token {
-        match s.as_str() {
+    fn from_string(s: &str) -> Token {
+        match s {
             "true" => Token::Literal(Literal::Boolean(true)),
             "false" => Token::Literal(Literal::Boolean(false)),
-            _ => Token::Identifier(s.to_string()),
+            _ => Token::Symbol(s.to_string()),
         }
     }
 
@@ -62,11 +62,7 @@ impl Token {
             '(' => Token::Parenthesis(LR::Left),
             ')' => Token::Parenthesis(LR::Right),
             ',' => Token::Comma,
-            '+' => Token::Operator(Operator::Add),
-            '-' => Token::Operator(Operator::Sub),
-            '*' => Token::Operator(Operator::Mul),
-            '/' => Token::Operator(Operator::Div),
-            _ => panic!("Unexpected char: {}", c),
+            c => Token::Symbol(c.to_string()),
         }
     }
 }
@@ -75,7 +71,7 @@ enum LexerState {
     None, // single char tokens
     NumberLiteral(String),
     StringLiteral(String), // no escaping, could do by `StringLiteral(Escaped)`
-    Identifier(String),    // could resolve to a keyword, identifier, or boolean
+    Symbol(String),    // could resolve to a keyword, identifier, or boolean
 }
 
 fn remove_comments(s: String) -> String {
@@ -100,12 +96,8 @@ pub fn lex(s: &String) -> Vec<Token> {
         let c = chars[i];
 
         match state {
-            LexerState::Identifier(ref mut s) => {
-                // allow anything apart from whitespace, parens, and commas
-                // in identifiers.
-                // NOTE: this doesn't mean identifiers can start with anything,
-                // they must start with a letter
-                if c != '(' && c != ')' && c != ' ' && c != ',' {
+            LexerState::Symbol(ref mut s) => {
+                if c != ' ' && c != '(' && c != ')' && c != ','{
                     s.push(c);
                     i += 1;
                 } else {
@@ -146,12 +138,9 @@ pub fn lex(s: &String) -> Vec<Token> {
                     c if c.is_numeric() => {
                         state = LexerState::NumberLiteral(c.to_string());
                     }
-                    c if c.is_alphanumeric() => {
-                        state = LexerState::Identifier(c.to_string());
-                    }
                     ' ' => {}
-                    _ => {
-                        panic!("Unexpected character: `{}`", c);
+                    c => {
+                        state = LexerState::Symbol(c.to_string());
                     }
                 }
                 i += 1;
@@ -160,7 +149,7 @@ pub fn lex(s: &String) -> Vec<Token> {
     }
 
     match state {
-        LexerState::Identifier(s) => tokens.push(Token::from_string(&s)),
+        LexerState::Symbol(s) => tokens.push(Token::from_string(&s)),
         LexerState::NumberLiteral(s) => tokens.push(Token::from_numeric(&s)),
         LexerState::StringLiteral(_) => panic!("Unexpected end of input"),
         LexerState::None => (),
@@ -174,21 +163,12 @@ mod tests {
     use super::*;
 
     #[test]
-    fn test_int_literal() {
+    fn test_number_literal() {
         let input = "123".to_string();
         let expected = vec![Token::Literal(Literal::Numeric(NumericLiteral::Int(123)))];
         assert_eq!(lex(&input), expected);
     }
 
-    #[test]
-    fn test_float_literal() {
-        let input = "1.23".to_string();
-        let expected = vec![Token::Literal(Literal::Numeric(NumericLiteral::Float(
-            1.23,
-        )))];
-        assert_eq!(lex(&input), expected);
-    }
-
     #[test]
     fn test_string_literal() {
         let input = "\"hello\"".to_string();
@@ -198,21 +178,8 @@ mod tests {
 
     #[test]
     fn test_identifier() {
-        let input = "variable_name".to_string();
-        let expected = vec![Token::Identifier("variable_name".to_string())];
-        assert_eq!(lex(&input), expected);
-    }
-
-    #[test]
-    fn test_operators() {
-        let input = "(+ - *)".to_string();
-        let expected = vec![
-            Token::Parenthesis(LR::Left),
-            Token::Operator(Operator::Add),
-            Token::Operator(Operator::Sub),
-            Token::Operator(Operator::Mul),
-            Token::Parenthesis(LR::Right),
-        ];
+        let input = "variableName".to_string();
+        let expected = vec![Token::Symbol("variableName".to_string())];
         assert_eq!(lex(&input), expected);
     }
 
@@ -221,8 +188,8 @@ mod tests {
         let input = "(define x 10)".to_string();
         let expected = vec![
             Token::Parenthesis(LR::Left),
-            Token::Identifier("define".to_string()),
-            Token::Identifier("x".to_string()),
+            Token::Symbol("define".to_string()),
+            Token::Symbol("x".to_string()),
             Token::Literal(Literal::Numeric(NumericLiteral::Int(10))),
             Token::Parenthesis(LR::Right),
         ];
diff --git a/src/macros.rs b/src/macros.rs
new file mode 100644
index 0000000..995b4c4
--- /dev/null
+++ b/src/macros.rs
@@ -0,0 +1,63 @@
+use std::collections::HashMap;
+
+use crate::parser::Node;
+
+
+pub struct Macro {
+    pub params: Vec<String>,
+    pub body: Node,
+}
+
+struct Scope {
+    bindings: HashMap<String, Macro>,
+}
+
+// (macro (identity node) node)
+// (macro (switch a b) '(b a))
+//
+// ((identity switch) 3 inc)
+// expand -> (switch 3 inc)
+// expand -> (inc 3)
+
+/// scope.bindings: {
+///   "switch": Macro { code: ... }
+/// }
+///
+
+fn eval_macro(themacro: Macro, )
+
+pub fn expand(node: Node, scope: Scope) -> Node {
+    return match node {
+        // optionally find a macro associated to the identifier
+
+        // expand all children
+        Node::List(list) => {
+            let expanded_list = list.iter().cloned().map(|item| expand(item, scope)).collect();
+            match list[0] {
+                Node::Symbol(name) => {
+                    if let Some(val) = scope.bindings.get(&name) {
+                        val
+                    }
+                    todo!();
+                }
+                Node::List(_) => todo!(),
+                Node::Literal(_) => todo!(),
+                Node::Op(_) => todo!(),
+                Node::Fn => todo!(),
+                Node::If => todo!(),
+                Node::Let => todo!(),
+                Node::Quote => todo!(),
+            };
+            todo!()
+        },
+        
+        // leaf nodes
+        Node::Literal(_) => node,
+        Node::Ident(_) => node,
+        Node::Op(_) => node,
+        Node::Fn => node,
+        Node::If => node,
+        Node::Let => node,
+        Node::Quote => node,
+    }
+}
diff --git a/src/main.rs b/src/main.rs
index c8494cf..55aa8dd 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -2,8 +2,6 @@ mod builtins;
 mod evaluator;
 mod lexer;
 mod parser;
-mod runtime_value;
-mod structural_parser;
 
 fn main() {
     let args: Vec<String> = std::env::args().collect();
@@ -17,7 +15,6 @@ fn main() {
         std::fs::read_to_string(file_path).expect("Something went wrong reading the file");
 
     let tokens = lexer::lex(&contents);
-    let ast_root = parser::parse(tokens);
-    let structured_ast = structural_parser::structure_ast(ast_root);
-    evaluator::evaluate(structured_ast);
+    let ast = parser::parse(tokens);
+    evaluator::evaluate(ast);
 }
diff --git a/src/parser.rs b/src/parser.rs
index f348888..aa27088 100644
--- a/src/parser.rs
+++ b/src/parser.rs
@@ -1,21 +1,31 @@
-pub use crate::lexer::{Literal, NumericLiteral, Operator};
-use crate::lexer::{Token, LR};
+pub use crate::lexer::{Literal, NumericLiteral};
+use crate::{builtins::BuiltIn, lexer::{Token, LR}};
+
+#[derive(Debug, PartialEq)]
+pub struct Ast {
+    pub root: Sexpr,
+}
 
 #[derive(Debug, PartialEq, Clone)]
-pub enum Node {
-    List(Vec<Node>), // doesn't allow for quoting, but this does: // List(Quoted, Vec<SExpr>), // impl later
-    Ident(String),
-    Literal(Literal),
-    Op(Operator),
-    Fn,
-    If,
-    Let,
-    Quote,
-    // impl later:
-    // Def,
+pub enum Sexpr {
+    List(Vec<Sexpr>), // doesn't allow for quoting, but this does: // List(Quoted, Vec<SExpr>), // impl later
+    Symbol(String),
+    String(String),
+    Bool(bool),
+    Int(i64),
+    Float(f64),
+    Lambda {
+        parameters: Vec<String>,
+        body: Box<Sexpr>,
+    },
+    Macro {
+        parameters: Vec<String>,
+        body: Box<Sexpr>,
+    },
+    BuiltIn(BuiltIn)
 }
 
-fn parse_list(rest_tokens: &[Token]) -> (Node, usize) {
+fn parse_list(rest_tokens: &[Token]) -> (Sexpr, usize) {
     let mut list = vec![];
 
     let mut i = 0;
@@ -33,10 +43,10 @@ fn parse_list(rest_tokens: &[Token]) -> (Node, usize) {
         i += i_diff;
     }
 
-    (Node::List(list), i)
+    (Sexpr::List(list), i)
 }
 
-fn parse_sexpr(rest_tokens: &[Token]) -> (Node, usize) {
+fn parse_sexpr(rest_tokens: &[Token]) -> (Sexpr, usize) {
     let first = &rest_tokens[0];
 
     match first {
@@ -44,15 +54,27 @@ fn parse_sexpr(rest_tokens: &[Token]) -> (Node, usize) {
             let (s_expr, i_diff) = parse_list(&rest_tokens[1..]);
             (s_expr, i_diff + 1)
         }
-        Token::Operator(op) => (Node::Op(*op), 1), // copied
-        Token::Literal(lit) => (Node::Literal(lit.clone()), 1),
-        Token::Identifier(ident) => match ident.as_str() {
-            "fn" => (Node::Fn, 1),
-            "if" => (Node::If, 1),
-            "let" => (Node::Let, 1),
-            "quote" => (Node::Quote, 1),
-            _ => (Node::Ident(ident.clone()), 1),
-        },
+        // Token::Operator(op) => {
+        //     let op = match op {
+        //         Operator::Add => Sexpr::Symbol("+".to_string()),
+        //         Operator::Sub => Sexpr::Symbol("-".to_string()),
+        //         Operator::Mul => Sexpr::Symbol("*".to_string()),
+        //         Operator::Div => Sexpr::Symbol("/".to_string()), // use a proper enum pattern
+        //     };
+        //     (op, 1)
+        // }
+        Token::Literal(lit) => {
+            let sexpr = match lit {
+                Literal::Numeric(num) => match num {
+                    NumericLiteral::Int(i) => Sexpr::Int(*i),
+                    NumericLiteral::Float(f) => Sexpr::Float(*f),
+                },
+                Literal::String(s) => Sexpr::String(s.clone()),
+                Literal::Boolean(b) => Sexpr::Bool(*b),
+            };
+            (sexpr, 1)
+        }
+        Token::Symbol(sym) => (Sexpr::Symbol(sym.clone()), 1),
         // These should not happen because they are handled in parse_list
         // could this be handled better by tightening up the types?
         // basically it's the responsibility of parse_list to handle these
@@ -63,10 +85,10 @@ fn parse_sexpr(rest_tokens: &[Token]) -> (Node, usize) {
     }
 }
 
-pub fn parse(tokens: Vec<Token>) -> Node {
+pub fn parse(tokens: Vec<Token>) -> Ast {
     let (s_expr, i_diff) = parse_sexpr(&tokens[..]);
     assert!(i_diff == tokens.len()); // for now, expect to parse all tokens from a single s_expr
-    s_expr
+    Ast { root: s_expr }
 }
 
 #[cfg(test)]
@@ -79,25 +101,22 @@ mod tests {
     fn test1() {
         let input = vec![Token::Literal(Literal::Numeric(NumericLiteral::Int(123)))];
 
-        assert_eq!(
-            parse(input),
-            Node::Literal(Literal::Numeric(NumericLiteral::Int(123)))
-        );
+        assert_eq!(parse(input).root, Sexpr::Int(123));
     }
 
     #[test]
     fn test2() {
-        let root = parse(lex(&"(+ 1 (- 4 3))".to_string()));
+        let Ast { root } = parse(lex(&"(+ 1 (- 4 3))".to_string()));
 
         assert_eq!(
             root,
-            Node::List(vec![
-                Node::Op(Operator::Add),
-                Node::Literal(Literal::Numeric(NumericLiteral::Int(1))),
-                Node::List(vec![
-                    Node::Op(Operator::Sub),
-                    Node::Literal(Literal::Numeric(NumericLiteral::Int(4))),
-                    Node::Literal(Literal::Numeric(NumericLiteral::Int(3))),
+            Sexpr::List(vec![
+                Sexpr::Symbol("+".to_string()),
+                Sexpr::Int(1),
+                Sexpr::List(vec![
+                    Sexpr::Symbol("-".to_string()),
+                    Sexpr::Int(4),
+                    Sexpr::Int(3)
                 ])
             ])
         );
diff --git a/src/runtime_value.rs b/src/runtime_value.rs
deleted file mode 100644
index 400a8c6..0000000
--- a/src/runtime_value.rs
+++ /dev/null
@@ -1,92 +0,0 @@
-use crate::{builtins::RustFunc, lexer::Operator, structural_parser::StructuredNode};
-use core::panic;
-use std::ops;
-
-#[derive(Debug, Clone, PartialEq)]
-pub struct Function {
-    pub params: Vec<String>,
-    pub body: StructuredNode,
-}
-
-#[derive(Debug, Clone, PartialEq)]
-pub enum RuntimeValue {
-    Int(i64),
-    Float(f64),
-    Boolean(bool),
-    String(String),
-    Symbol(String),
-    Function(Function),
-    Op(Operator),
-    List(Vec<RuntimeValue>),
-    BuiltIn(RustFunc),
-}
-
-impl RuntimeValue {
-    pub fn bool(&self) -> bool {
-        match self {
-            RuntimeValue::Boolean(b) => *b,
-            RuntimeValue::Int(int) => *int != 0,
-            RuntimeValue::Float(float) => *float != 0.0,
-            RuntimeValue::String(string) => string.is_empty(),
-            RuntimeValue::Function(Function { params: _, body: _ }) => true,
-            RuntimeValue::Op(_) => true,
-            RuntimeValue::List(list) => !list.is_empty(),
-            RuntimeValue::BuiltIn(_) => true,
-            RuntimeValue::Symbol(_) => true,
-        }
-    }
-}
-
-impl ops::Add for RuntimeValue {
-    type Output = Self;
-
-    fn add(self, rhs: Self) -> Self::Output {
-        match (self, rhs) {
-            (RuntimeValue::Int(a), RuntimeValue::Int(b)) => RuntimeValue::Int(a + b),
-            (RuntimeValue::Float(a), RuntimeValue::Float(b)) => RuntimeValue::Float(a + b),
-            (RuntimeValue::Int(a), RuntimeValue::Float(b)) => RuntimeValue::Float(a as f64 + b),
-            (RuntimeValue::Float(a), RuntimeValue::Int(b)) => RuntimeValue::Float(a + b as f64),
-            (RuntimeValue::String(a), RuntimeValue::String(b)) => RuntimeValue::String(a + &b),
-            (s, r) => panic!("Cannot add {:?} and {:?}", s, r),
-        }
-    }
-}
-
-impl ops::Mul for RuntimeValue {
-    type Output = Self;
-    fn mul(self, rhs: Self) -> Self::Output {
-        match (self, rhs) {
-            (RuntimeValue::Int(a), RuntimeValue::Int(b)) => RuntimeValue::Int(a * b),
-            (RuntimeValue::Float(a), RuntimeValue::Float(b)) => RuntimeValue::Float(a * b),
-            (RuntimeValue::Int(a), RuntimeValue::Float(b)) => RuntimeValue::Float(a as f64 * b),
-            (RuntimeValue::Float(a), RuntimeValue::Int(b)) => RuntimeValue::Float(a * b as f64),
-            (s, r) => panic!("Cannot multiply {:?} and {:?}", s, r),
-        }
-    }
-}
-
-impl ops::Sub for RuntimeValue {
-    type Output = Self;
-    fn sub(self, rhs: Self) -> Self::Output {
-        match (self, rhs) {
-            (RuntimeValue::Int(a), RuntimeValue::Int(b)) => RuntimeValue::Int(a - b),
-            (RuntimeValue::Float(a), RuntimeValue::Float(b)) => RuntimeValue::Float(a - b),
-            (RuntimeValue::Int(a), RuntimeValue::Float(b)) => RuntimeValue::Float(a as f64 - b),
-            (RuntimeValue::Float(a), RuntimeValue::Int(b)) => RuntimeValue::Float(a - b as f64),
-            (s, r) => panic!("Cannot subtract {:?} and {:?}", s, r),
-        }
-    }
-}
-
-impl ops::Div for RuntimeValue {
-    type Output = Self;
-    fn div(self, rhs: Self) -> Self::Output {
-        match (self, rhs) {
-            (RuntimeValue::Int(a), RuntimeValue::Int(b)) => RuntimeValue::Int(a / b),
-            (RuntimeValue::Float(a), RuntimeValue::Float(b)) => RuntimeValue::Float(a / b),
-            (RuntimeValue::Int(a), RuntimeValue::Float(b)) => RuntimeValue::Float(a as f64 / b),
-            (RuntimeValue::Float(a), RuntimeValue::Int(b)) => RuntimeValue::Float(a / b as f64),
-            (s, r) => panic!("Cannot divide {:?} and {:?}", s, r),
-        }
-    }
-}
diff --git a/src/structural_parser.rs b/src/structural_parser.rs
deleted file mode 100644
index 50562c0..0000000
--- a/src/structural_parser.rs
+++ /dev/null
@@ -1,130 +0,0 @@
-/// Parses an AST into a more structurally valid AST, so that structural checking
-/// can be front-loaded and decoupled from evaluation.
-/// for example, when later evaluating (fn (x) (+ x 1)), it'd be great if we could
-/// be sure that the structure of the `fn` form is valid, so that we don't have to
-/// check that while evaluating the function statement.
-use crate::{
-    lexer::{Literal, Operator},
-    parser::Node,
-};
-
-#[derive(Debug, PartialEq, Clone)]
-pub enum Form {
-    Special(SpecialForm),
-    Regular(Vec<StructuredNode>),
-}
-
-#[derive(Debug, PartialEq, Clone)]
-pub struct FnForm {
-    pub args: Vec<String>,
-    pub body: Box<StructuredNode>, // for example, we might want: (let (get-size (fn () 1)) (get-size))
-}
-
-#[derive(Debug, PartialEq, Clone)]
-pub struct IfForm {
-    pub condition: Box<StructuredNode>,
-    pub if_body: Box<StructuredNode>,
-    pub else_body: Box<StructuredNode>,
-}
-
-#[derive(Debug, PartialEq, Clone)]
-pub struct LetForm {
-    pub bindings: Vec<(String, StructuredNode)>,
-    pub expr: Box<StructuredNode>,
-}
-
-#[derive(Debug, PartialEq, Clone)]
-pub struct QuoteForm {
-    pub expr: Node, // I think this can be anything
-}
-
-#[derive(Debug, PartialEq, Clone)]
-pub enum SpecialForm {
-    Fn(FnForm),
-    If(IfForm),
-    Let(LetForm),
-    Quote(QuoteForm),
-}
-
-#[derive(Debug, PartialEq, Clone)]
-pub enum StructuredNode {
-    Form(Form),
-    Ident(String),
-    Literal(Literal),
-    Op(Operator), // TODO just use builtin
-}
-
-pub fn structure_ast(root: Node) -> StructuredNode {
-    match root {
-        Node::List(nodes) => StructuredNode::Form(parse_form(nodes)), // .iter().map(|node| structure_ast(node)).flatten().collect(),
-        Node::Ident(ident) => StructuredNode::Ident(ident.clone()),
-        Node::Literal(lit) => StructuredNode::Literal(lit.clone()),
-        Node::Op(op) => StructuredNode::Op(op),
-        Node::Fn => panic!("Node::Fn should not be evaluated"),
-        Node::If => panic!("Node::If should not be evaluated"),
-        Node::Let => panic!("Node::Let should not be evaluated"),
-        Node::Quote => panic!("Node::Quote should not be evaluated"),
-    }
-}
-
-/// structurally parses a list into a form so that structural checking can
-/// be decoupled from evaluation
-fn parse_form(list: Vec<Node>) -> Form {
-    match list[0] {
-        Node::Fn => match &list[1..] {
-            [Node::List(args), bodyexpr] => {
-                let args = args
-                    .iter()
-                    .map(|arg_node| match arg_node {
-                        Node::Ident(ident) => ident.clone(),
-                        _ => panic!("Function arguments must be identifiers"),
-                    })
-                    .collect();
-                Form::Special(SpecialForm::Fn(FnForm {
-                    args,
-                    body: Box::new(structure_ast(bodyexpr.clone())),
-                }))
-            }
-            _ => panic!("Fn form must be called with a list of arguments and a body"),
-        },
-        Node::If => match &list[1..] {
-            [condition, if_body, else_body] => Form::Special(SpecialForm::If(IfForm {
-                condition: Box::new(structure_ast(condition.clone())),
-                if_body: Box::new(structure_ast(if_body.clone())),
-                else_body: Box::new(structure_ast(else_body.clone())),
-            })),
-            _ => panic!("If form must be called with a condition, if body, and else body"),
-        },
-        Node::Let => {
-            if list.len() < 3 {
-                panic!("Let form must be called with a list of bindings and an expr");
-            }
-            let bindings = &list[1..list.len() - 1];
-            let expr = list.last().unwrap();
-            return Form::Special(SpecialForm::Let(LetForm {
-                bindings: bindings
-                    .iter()
-                    .map(|node| match node {
-                        Node::List(nodes) => match &nodes[..] {
-                            [Node::Ident(ident), expr] => {
-                                (ident.clone(), structure_ast(expr.clone()))
-                            }
-                            _ => panic!("let binding must be a list of two elements"),
-                        },
-                        _ => panic!("All bindings must be lists"),
-                    })
-                    .collect(),
-                expr: Box::new(structure_ast(expr.clone())),
-            }));
-        }
-        Node::Quote => match &list[1..] {
-            [expr] => Form::Special(SpecialForm::Quote(QuoteForm { expr: expr.clone() })),
-            _ => panic!("Quote form must be called with an expr"),
-        },
-        _ => Form::Regular(
-            list.iter()
-                .map(|node| structure_ast(node.clone()))
-                .collect(),
-        ),
-    }
-}
